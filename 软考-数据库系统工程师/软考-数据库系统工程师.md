[toc]

## 上午题

![img](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243532.png)

![image-20240330141555858](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243533.png)

![image-20240330141609494](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243534.png)

## 下午题

![image-20240403154303893](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243535.png)

![image-20240403154334909](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243536.png)

![image-20240330142052528](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243537.png)

![image-20240330141617846](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243538.png)

# 计算机系统知识

![image-20240322093241860](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243539.png)

## 计算机系统的组成

### 计算机硬件组成

计算机系统由硬件系统和软件系统组成。硬件由**运算器、控制器、存储器**、输入设备、输出设备5部分组成；软件由系统软件、应用软件组成。



- **cpu的组成：**运算器，控制器，寄存器（64位）和内部总线等部件组成



> **CPU的基本功能：**
>
> a)    **程序控制**。CPU通过执行指令来控制程序的执行顺序，这是CPU的重要功能。
>
> b)   **操作控制**。一条指令功能的实现需要若干操作信号配合来完成，cpu产生每条指令的操作信号并将操作信号送往对应的部件，控制相应的部件按指令的功能要求进行操作。
>
> c)    **时间控制**。CPU对各种操作进行时间上的控制，即指令执行过程中操作信号的出现时间、持续时间及出现的时间顺序都需要进行严格控制。
>
> > 以上三个都是控制器，下面是运算器
>
> d)   **数据处理——CPU的根本任务，算数运算逻辑运算**
>
> 此外，**cpu还需要对系统内部和外部的中断（异常）做出响应**，进行相应的处理

###  中央处理单元

运算器：对数据进行处理的部件，主要完成**算术和逻辑运算**；

> **运算器包含：**
>
> - **算数逻辑单元ALU（Arithmetic and logic unit）：数据的算数运算和逻辑运算**
>
> - **累加寄存器AC（Accumulator）：为ALU提供一个工作区，用来暂存数据（运算结果或源操作数的存放区）**
>
>   > **以上两个常考**
>
> - **数据缓冲寄存器DR（Data Register）：写内存时，暂存指令或数据**
>
> - **状态条件寄存器PSW（Program Status Word）：存状态标志与控制标志（条形码内如，如溢出标志等）**

控制器：**从主存中取出指令**，并指出下一条指令在主存中的位置，**取出的指令经指令寄存器送往指令译码器**，经过对指令的分析发出相应的控制和定时信息；

> **控制器的组成部分为：**
>
> - **程序计数器（pc）Program Counter：存储下一条要执行指令的地址（指针）**
>
> - **指令寄存器（ir）Instruction Register：存储即将执行的指令（操作码和地址码）**
>
>   > **以上两个常考**
>
> - **指令译码器（id）Instruction Decoder：对操作进行分析解释**
>
> - **地址寄存器（ar）Address Register：保存当前cpu所访问的内存地址**
>

- 计算机硬件的典型结构
  - 单总线结构
  - **双总线结构(以cpu为中心、以存储器为中心)**
  - 采用通道的大型系统结构。



![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243540.png)

### 计算机周期

> 各种计算机周期
>
> 1. **时钟频率：xx Ghz**
> 2. **总线周期：cpu完成一次内存访问（读写）或IO接口操作所需要的时间；一个总线周期通常由n个时钟周期组成**
>
> 3. **时钟（振荡）周期：时钟频率（xx Ghz）的倒数，是计算机中最基本、最小的时间单位。如2.4Ghz的时钟周期为1/2.4**
>
> 4. **机器（cpu）周期：指完成一个基本操作（如取指、读存储器），以读取一个指令的最短时间来规定cpu周期。其包含多个时钟周期**
>
> 5. **指令周期：包含   取值-》分析-》执行  的时间，其可能包含0-多条总线周期**
> 6. **存储周期：主存储器两次启动操作之间需要的最小时间间隔，即存储器周期时间**
>
> 其中：**时钟周期 < 机器（cpu）周期 ~= 总线周期 < 指令周期**
>
> ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243541.png)

## 计算机数据表示

### 存储单位

数据的最小存储单位是bit（比特/位），**一个b为一个二进制位（做存储空间的题时一定要转换成二进制先）**，一个字节（B）为8个二进制位

> **k、m、g是数量单位，每个单位相差1024倍**
>
> **b，B是存储单位**
>
> **即1B=8bit，1kB=8kb**
>
> **运算方式：不要硬算，化简为2 的幂指数来计算**

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243542.png)

> **做题步骤：①先将十六进制的多少位（字节）算出来**
>
> **②将该十六进制数用2^n n次方的十进制形式表示出来**
>
> **③根据题目再进行相应的乘法除法运算**

### R进制

> **二进制0b**；**十六0x或H**

基本概念

> - 数制：r进制
> - 基数：就是每一位的数码可以有多少个数字来表示。其实就是所谓的进制，十进制，基数为十，数码可以取的值有10个，分别是0~9。
> - **数码**：该r进制可以使用的符号
> - 数位：个位十位百位
> - **位权**：个位数上的1 的权值为 10^0，十位数上的1 的权值为 10^1 ，百位数上的1 的权值为 10^2 。

- **二进制转八/十六进制：分3/4个一组**

  > 相反同理

- r进制转十进制：位权展开法，从0，1，2，3..累加

- 十进制转r进制：取余后从下往上取值

### 算数逻辑运算

- 加减乘除

  > 二进制的除法运算，属于**模二运算**，模二运算的特点是：**没有进位**。
  >
  > 模二加法：0+0=0 0+1=1 1+0=1 1+1=0
  >
  > 模二减法：0-0=0 0-1=1 1-0=1 1-1=0
  >
  > 模二乘法：0x0=0 0x1=0 1x0=0 1x1=1

- 二进制的与运算（逻辑乘），用**^**，and，-表示

- 或运算（逻辑加），用**v**，+，or表示

- 异或用一个用**O包围的+**，**xor，^**表示

  > **上述的是位运算符，异则是1，编程里，^表示的是异或运算，&才是并**
  >
  > > **逻辑运算符**
  > >
  > > - 与：^
  > > - 或：v
  > > - **非：$\neg$**
  >
  > > **位运算符**
  > >
  > > - 与：&
  > > - 或：|
  > > - **异或：^**

### 数据在计算机中的表示方法（机器码和码制）

> 各种数据在计算机中表示的形式称为**机器数**，**0开头表示正号，1开头表示负号**，**小数点隐含表示且不占位置**。**机器数对应的实际数据称为真值**。机器数分为无符号数（unsigned)和有符号数（正和负数）。无符号数表示正数。

- 原码：真值，0开头正，1开头负，默认是8位，没有添0

- **反码：负数就取反（开头1不动），正数相同**

- **补码：正数相同，负数为反码+1**

  > 即**负数的补码=原码取反+1；负数的原码同样=补码+1**
  >
  > 补码是为了消除+0和-0
  >
  > 常用于加减法

- 移码：=补码，但是开头符号位取反

  > 常用于浮点数的阶码

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243543.png)

| 机器码   | 能够表示的不同的有符号整数（定点小数）个数 |
| -------- | ------------------------------------------ |
| 原码     | **2^n - 1** = 2^(n-1) + 2^(n-1) + 1        |
| 反码     | **2^n - 1**                                |
| **补码** | **2^n**                                    |
| 移码     | **2^n**                                    |

> 因为补码负数时+了1，所以原码和反码比补码和移码少一位，补码比他们多一位

> **例：用8位二进制表示**
>
> - **原码**：-127-127共有254+相同的两个0=**255个数 = 2^n - 1**
> - **反码**：-127-127共有254+相同的两个0=**255个数 = 2^n - 1**
> - **补码**：-128-127共有255+两个0=**256个数 = 2^n**

### 定点数和浮点数

- 定点整数：符号真值.（小数点在最右）

- 顶点小数：符号.真值（小数点在真值前面）

- **浮点数：N=M*R^e**

  > **N是数符，M是尾数，e是指数（阶码），R是基数（阶码的底）**
  >
  > **浮点数计算方法：**
  >
  > - **对阶：使次方相同（规则：小变大，增加几位，末尾就移除几位）**
  > - **尾数计算相加减**
  > - **结果格式化**（负数变成1.0xxxx或正数变成0.1xxxx）
  >
  > **浮点数所能表示的数值范围是由阶码确定的，所表示的数值精度由尾数决定**
  >
  > ![image-20240330185624552](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243544.png)

### 校验码（不考）

- **码距**：就单个编码A：00而言，其码距为1，因为其只需要改变一位就变成另一个编码。在两个编码中，**从A码到B码转换所需要改变的位数称为码距**，如A：00要转换为B：11，码距为2。一般来说，码距越大，越利于纠错和检错。
- **奇偶校验码：在编码中增加1位校验位来使编码中1的个数为奇数（奇校验）或者偶数（偶校验）**，从而**使码距变为2（一个是校验码另一个是本身的错误）**。例如：
- 奇校验：编码中，含有奇数个1，发送给接收方，接收方收到后，会计算收到的编码有多少个1，如果是奇数个，则无误，是偶数个（+0），则有误（+1）。
- 偶校验同理，只是编码中有偶数个1，由上述，**奇偶校验只能检1位错，并且无法纠错。**

### crc冗余校验码

- CRC的全称是循环冗余校验（Cyclic Redundancy Check）。**CRC只能检错，不能纠错。使用CRC编码，需要先约定一个生成多项式G（x）。**生成多项式的最高位和最低位必须是1。假设原始信息有m位，则对应多项式M（x）。生成校验码思想就是在原始信息位后追加若干校验位，使得追加的信息能被G（x）整除。接收方接收到带校验位的信息，然后用G（x）整除。余数为0，则没有错误；反之则发生错误。

  > 例：假设原始信息串为10110，CRC的生成多项式为G（x）＝x＾4＋x＋1，求CRC校验码。
  >
  > （1）在原始信息位后面添0，假设生成多项式的阶为r，则**在原始信息位后添加r个0**，本题中，G（x）阶为4，则在原始信息串后加4个0，得到的新串为101100000，**作为被除数**。
  >
  > （2）**由多项式得到除数，多项中x的幂指数存在的位置1，不存在的位置0。本题中，x的幂指数为0，1，4的变量都存在，而幂指数为2，3的不存在，因此得到除数10011。**
  >
  > （3）**生成CRC校验码，将前两步得出的被除数和除数进行模2除法运算（即不进位也不借位的除法运算**）。**除法过程（好像是异或运算）**如下图所示。
  >
  > ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243545.png)
  >
  > **得到余数1111（余数的位数要和阶数要和r相同）。**
  >
  > **注意：余数不足r，则余数左边用若干个0补齐。如求得余数为11，r＝4，则补两个0得到0011。**
  >
  > > 该余数也就是crc的校验位
  >
  > （4）**生成最终发送信息串，将余数（校验位）添加到原始信息后（变成校验码）**。上例中，原始信息为10110，添加余数1111后，结果为101101111。发送方将此数据发送给接收方。
  >
  > （5）**接收方进行校验**。接收方的CRC校验过程与生成过程类似，**接收方接收了带校验和的帧后，用多项式G（x）来除**。余数为0，则表示信息无错；否则要求发送方进行重传。
  >
  > 注意：**收发信息双方需使用相同的生成多项式。**
  
  ![image-20240330170308072](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243546.png)

### 海明校验码

- 海明码：本质也是**利用奇偶性来检错和纠错**的检验方法，**构成方法实在数据位之间的确定位置上插入k个校验位，通过扩大码距实现检错和纠错**。

  > **设数据位是s位，校验位是j位，则s和j必须满足以下关系：2＾j-1＞＝s＋j**
  
  > 比如一个有10位数海明码，那么它的校验位最大的位数为8
  >
  > 又比如一个有10位的数据，则至少需要添加4位的校验位才能成为海明校验码

例：求信息1011的海明码

- 1．校验位的位数和具体的数据位的位数之间的关系

  所有位都编号，**从最低位编号（最右边开始），从1开始递增，校验位处于2的n（n＝012．．．．．）次方中**，**即处于第1，2，4，8，16，32，．．．．．位上**，其余位才能填充真正的数据位，若信息数据为1011，则可知，第1，2，4位为校验位，第3，5，6，7位为数据位，用来从高位开始存放1011，得出信息位和校验位分布如下：

  ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243547.png)

  > **因此可以得知所有的校验码都比信息位中位数最大的位数要小**

- 2．计算校验码

  **将所有信息位的编号都拆分成二的n次表示后，校验位的值=校验的信息位的异或运算**，如下图所示：

  ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243548.png)

  上图中，7＝4＋2＋1，表示7由第4位校验位（r2）和第2位校验位（r1）和第1位校验位（ro） 共同校验，同理，第6位数据位6＝4＋2，第5位数据位5＝4＋1，第3位数据位3＝2＋1，

  **前面知道，这些2的n次方都是校验位，可知，第4位校验位校验第765三位数据 位，因此，第4位校验位r2等于这三位数据位的值异或，第2位和第1位校验位计 算原理同上.**

  计算出三个校验位后，可知最终要发送的海明校验码为1010101（校验位穿插在中间，和信息位组成校验码。不像crc校验位在末尾）

- 3．检错和纠错原理

  接收方收到海明码之后，会将每一位校验位与其校验的位数分别异或，即做如下三组运算：

  ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243549.png)

  如果是**偶校验，那么运算得到的结果应该全为0，如果是奇校验，应该全为1**，才是正确，假设是偶校验，且接收到的数据为1011101（第四位出错），此时，运算的结果为：

  ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243550.png)

  这里不全为0，表明传输过程有误（用了偶检验），并且按照r2r1r0排列为二进制100，这里指出的就是错误的位数，表示第100，即第4位出错，找到了出错位，纠错方法就是将该位逆转。

![image-20240330165955622](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243551.png)

## 计算机体系结构

### 指令流数据流

- 按**处理机的数量**进行分类：单处理系统（一个处理单元和其他设备集成）、并行处理系统（两个以上的处理机互联）分布式处理系统（物理上远距离且松合的多计算机系统）。

- **Flynn分类法**：分类有两个因素，即**指令流和数据流，指令流由控制部分处理**，每一个控制部分处理一条指令流，多指令流就有多个控制部分；**数据流由处理器来处理**，每一个处理器处理一条数据流，多数据流就有多个处理器；至于**主存模块，是用来存储的，存储指令流或者数据流**，因此，无论是多指令流还是多数据流，都需要多个主存模块来存储，对于主存模块，指令和数据都一样

     > **指令流is（instruction stream）指机器执行的指令序列**
     >
     > **数据流ds指指令流调用的数据序列**

- 依据计算机特性，是由**指令来控制数据的传输**，因此，一条指令可以控制一条或多条数据流，但**一条数据流不能被多条指令控制，否则会出错**，就如同上级命令太多还互相冲突不知道该执行哪个，因此**多指令单数据MISD不可能**，如下图所示

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243552.png)

> Single Instruction Single Data stream
>
> M就是Multiple
>
> **单指令流都是一个控制器，多指令流都是多个控制器，表示的是执行单条指令还是不同指令**
>
> **单数据流都是一个处理器，多数据流都是多个数据器，数据流表示的是同步进行还是异步进行**
>
> **主存模块只有两个“单”才是单，否则都是多**
>
> ![image-20240330165139332](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243553.png)

![image-20240330165111669](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243554.png)

### 指令系统

> 计算机指令的组成：**一条指令由操作码和操作数两部分组成**

- **操作码决定要完成的操作，操作数指参加运算的数据及其所在的单元地址。**在计算机中，操作要求和操作数地址**都由二进制数码表示，分别称作操作码和地址码**，整条指令以二进制编码的形式存放在存储器中。

  > **该二进制数码的前面的是操作码，后面是地址码**

- **计算机指令执行过程：取指令——分析指令——执行指令**三个步骤，首先将程序计数器PC中的指令地址取出，送入地址总线， CPU依据指令地址去内存中取出指今内容存入指今寄存器IR：而后由指今译码哭进行分析，分析指会损作码·最后执行指令，取出指令执行所需的源操作数。

### 指令与操作数的寻址方式

**指令寻址方式**

- **顺序寻址方式**：当执行一段程序时，是一条**指令接着**一条**指令**地顺序执行。

- **跳跃寻址方式**：指吓一跳指令的地址码**不是由程序计数器给出而是由本条指令直接给出**。程序跳跃后，按新的指令地址开始顺序执行。因此，程序计数器的内容也必须相应改变，以便及时跟踪新的指令地址。

> 指令一般存在主存里

指令**操作数的寻址方式**

- **立即寻址方式**：**指令的地址码**字段指出的不是地址，而是**操作数本身**。

  >  **如一个数字：45**

- **直接寻址方式**：在**指令的地址**字段中**直接指出操作数在主存中的地址**。

- **相对寻址**：指令地址码给出的是一个偏移量（可正可负），**操作数地址等于本条指令的地址加上偏移量**

- **间接寻址方式**：指令地址码字段所指向的存储单元中存储的是**操作数的地址**。

> 经过中点站

- **基址寻址方式**：将**基址寄存器的内容加上指令中的形式地址而形成操作数的有效地址**，其**优点是可以扩大寻址能力。**

- **变址寻址方式**：变址寻址方式计算有效地址的方法与基址寻址方式很相似，它是**将变址寄存器的内容加上指令中的形式地址而形成操作数的有效地址。**

> 操作数可能在寄存器可能在其他地方

- **寄存器寻址：操作数存放在某一寄存器中，指令中给出存放操作数的寄存器名**

  > **如：MOV RI，其中RI表示RIGISTER寄存器**

- **寄存器间接寻址**：操作数存放在内存单元中，操作数所在存储单元的**地址在某个寄存器中**

### CISC/RISC

CISC（Complex Instruction Set Computer）是**复杂指令系统计算机**，兼容性强，指令繁多、长度可变，由微程序实现；

RISC（Reduced Instruction Set Computer）是**精简指令系统计算机**，指令少，使用频率接近，主要依靠硬件实现（通用寄存器、硬布线逻辑控制）。

**具体区别如下：**

| 指令系统类型     | 指令                                                         | 寻址方式       | 实现方式                                                     | 其它                    |
| ---------------- | ------------------------------------------------------------ | -------------- | ------------------------------------------------------------ | ----------------------- |
| CISC（**复杂**） | 数量**多**，使用频率流到士**可变长**格式                     | 支持**多**种   | **微程序控制技术（微码）**                                   | 研制周期**长**          |
| RISC（**精简**） | 数量**少**，使用频率**接近，定长**格式，大部分为单周期指令，操作寄存器，只有Load/Store操作内存 | 支持方式**少** | **增加了通用寄存器**；硬布线逻辑控制为主：效支持高级语适合采用流水线 | 优化编译,效支持高级语言 |

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243555.png)

> 扩展：
>
> ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243556.png)
>
> 1. X86架构由Intel公司设计并长期使用，原属于CISC（复杂指令集）型架构。
> 2. ARM架构由ARM公司设计，广泛用于移动设备等低功耗场景，是RISC（精简指令集）型架构。arduino，stm32，[树莓派](https://www.zhihu.com/search?q=树莓派&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1526472339})都是arm。
> 3. RISC-V，如其名，是一种开源的RISC（精简指令集）型架构。
> 4. MIPS架构一般用于嵌入式系统或微控制器，也是RISC（精简指令集）型架构。
> 5. 树莓派：cisc：不是芯片，而是一个集成的电路板，是基于linux的一个微型计算机。
> 6. 单片机是把非常微小的CPU，内存，定时器，和各种外部接口集成在一个芯片上，形成了芯片级别的微型计算机。
> 7. Arduino一般认为是使用avr系列8位单片机的开发板和[atmel公司](https://www.zhihu.com/search?q=atmel公司&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1527707007})的arm开发板，当然现在也有其他开发板，比如[esp8266](https://www.zhihu.com/search?q=esp8266&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1527707007})，esp32，stm32系列，[飞思卡尔](https://www.zhihu.com/search?q=飞思卡尔&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1527707007})的k系列，这里我们说Arduino就单只8位单片机。

### 流水线

**指令流水线原理：将指令分成不同段，每段由不同的部分去处理**，因此可以产生叠加的效果，所有的部件去处理指令的不同段

> 如果不采用流水线就是**串行**的方式
>
> 复杂指令系统计算机没有流水线
>
> **流水线采用异步控制反而会增加控制电路的复杂性，并且不会带来性能改善**



> **RISC中的流水线技术：**

（1）**超流水线（Super Pipe Line）技术**。它通过细化流水、增加级数和提高主频，使得在每个机器周期内能完成一个甚至两个浮点操作。其实质是以**时间换取空间**。

> 原本指令分3步，现在分更多的步骤

（2）**超标量（Super Scalar）技术**。它通过内装多条流水线来同时执行多个处理，其时钟频率虽然与一般流水接近，却有更小的CPI。其实质是以**空间换取时间**。

> 加硬件

（3）**超长指令字（Very Long Instruction Word，VLIW）技术**。 VLIW和超标量都是20世纪80年代出现的概念，其共同点是要同时执行多条指令，其不同在于超标量依靠硬件来实现并行处理的调度，VLIW则充分发挥**软件的作用**，而使硬件简化，性能提高。



> **流水线的时间计算**

- **流水线周期**：指令分成不同执行段，其中**执行时间最长（最慢）的段为流水线周期。**
- **流水线执行时间：1条（段）指令总执行时间＋（总指令条数-1）＊流水线周期。**
- **实际流水线吞吐率计算：吞吐率即单位时间内执行的指令条数。公式：总指令条数／流水线执行时间。**

- **流水线的最大吞吐率计算：流水线的最长周期的倒数，即1/最长周期**。

- **流水线的加速比计算：**加速比即使用流水线后的效率提升度，即比不使用流水线快了多少倍，越高表明流水线效率越高，**公式：不使用流水线执行时间／使用流水线执行时间。**

> 流水线的加速比值结果>1
>
> 1s=10^3nm=10^6us（微秒）=10^9ns
>
> **当缓冲区的数量少于执行任务中出现的缓冲区的数量时，需要把任务里有缓冲区的合并起来，直至满足目前所有的缓冲区数量**



![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243557.png)

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243558.png)

![image-20240324170242006](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243559.png)

> **流水线采用异步控制不会明显增高其性能**。

## 存储系统

### 概念

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243560.png)

> 上面的梯形表示：上面是速度快，容量小，价格高；下面是慢大低
>
> cpu的**寄存器**一般是**位**为单位，如32位
>
> **cache：m为单位**，如3m
>
> 主存储器（内存）：G
>
> 联机硬盘存储器：g或t，外盘
>
> 脱机光盘、磁盘存储器，外盘

- 计算机采用分级存储体系的主要目的是为了解决存储容量、成本和速度之间的矛盾问题

- 两级存储：**Cache-主存（cache缓冲和内存）、主存-辅存（虚拟存储体系）**

- **局部性原理**：总的来说，在CPU运行时，所访问的数据会超向于一个较小的局部空间地址内，包括下面两个方面：

  **时间局部性原理**：如果一个数据项正在被访问，那么在近期它很可能会被再次访问，即在**相邻的时间里会访问同一个数据项**。

  **空间局部性原理**：在最近的将来会用到的数据的地址和现在正在访问的数地址很可能是相近的，即**相邻的空间地址会被连续访问。**

### cache

- 高速缓存Cache用来存储当前**最活跃的程序和数据，直接与CPU交互**，**位于CPU和主存之间，容量小，速度为内存的5-10倍**，由半导体材料构成。其内容是主存内存的副本贝，对于程序员来说是透明的。

- **Cache由控制部分和存储器组成**，**存储器存储数据，控制部分判断CPU要访问的数据是否在Cache中，在则命中**，不在则依据一定的算法从主存中替换。

- **地址映射**：在CPU工作时，**送出的是主存单元的地址，而应从Cache存储器中读/写信息。这就需要将主存地址转换为Cache存储器地址**，这种地址的转换称为地址映像，**由硬件自动完成映射**，分为下列三种方法：

  > **考点：由硬件自动完成映射，不需要程序员自己去设定**


#### 直接映像

**将cache存储器等分成块，主存也等分成块并编号**。主存中的块与Cache中的块的对应关系是固定的，也即**二者块号相同才能命中**。地址变换简单但不灵活，容易造成资源浪费。   （如图所示）

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243561.png)

> **考点：**
>
> 1. 优点：**地址变化简单、访问速度快**
>
> 2. **缺点：块冲突率最高**、cache空间得不到充分利用
>
> 3. 主存地址构成：
>
>    | 主存区号 | 区内块号 | 块内地址 |
>    | -------- | -------- | -------- |
>
>    > **注：这里每个区号都占一个编址地址，也就是说，主存总块数就是主存占的多少位的位数**
>
> 4. **Cache的块数（区内块号位数）=高速缓存容量 / 每一块的大小**
>
> 5. **主存区号个数（主存占多少位）：主存容量 / 高速缓存容量**
>
> 6. **块内地址占位数：块的大小转换成2的n次方**
>
> 7. **主存地址位数=主存区号+主存块号+块内地址（即上述三项相加）**
>
>    如![image-20240412141243357](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243562.png)

#### 全相联映像

**同样都等分成块并编号。主存中任意一块都与cache中任意一块对应。因此可以随意调入Cache任意位置（不用担心类似哈希冲突那样，他会自动跑去空的位置）**，但地址变换复杂，速度较慢。因为主存可以随意调入Cache任意块，只有当Cache满了才会发生块冲突，是**最不容易发生块冲突的映像方式。**

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243563.png)

> **考点：**
>
> 1. 优点：**灵活，块冲突率最低，只有在cache中的快全部装满后才会出现冲突，cache利用率高**
>
> 2. **缺点：无法从主存块号中直接获得所对应的cache的块号，变换比较复杂，地址变换速度慢，成本高**
>
> 3. 主存地址构成：
>
>    | 主存区号 | 块内地址 |
>    | -------- | -------- |

#### 组组相连映像

**前面两种方式的结合**，**将Cache存储器先分块再分组，主存也同样先分块再分组，组间采用直接映像，即主存中组号与Cache中组号相同的组才能命中，但是组内全相联映像，也即组号相同的两个组内的所有块可以任意调换。**

> **考点：**
>
> 1. 组组相连映像冲突概率位于直接映像和全相联映像中
> 2. **主存地址位数=区号+组号+主存块号+块内地址**
> 3. **cache地址位数（块内地址位数）=组号+组内块号+块内地址**

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243564.png)

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243565.png)

> 一组多少块是没用的信息。
>
> **主存地址的位数=块的大小*主存的块数量  （结果取2的n次方）**
>
> **主存区号的位数=主存块数量/cache块数量**

#### cache的性能分析

设**H<sub>c</sub>为cache的命中率，t<sub>c</sub>为cache的存取时间，t<sub>m</sub>为主存的访问时间**，则**cache存储器的等效加权平均访问时间t<sub>a</sub>为：**

**t<sub>a</sub>=H<sub>c</sub>t<sub>c</sub>+（1-H<sub>c</sub>）t<sub>m</sub>**

> 也就是：**等效加权平均访问时间=cache命中率\*cache存取时间+cache未命中率\*访问主存时间**

### 存储单位

数据的最小存储单位是bit（比特/位），**一个b为一个二进制位（做存储空间的题时一定要转换成二进制先）**，一个字节（B）为8个二进制位

> **k、m、g是数量单位，每个单位相差1024倍**
>
> **b，B是存储单位**
>
> **即1B=8bit，1kB=8kb**
>
> **运算方式：不要硬算，化简为2 的幂指数来计算**

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243566.png)

### 存储器分类

1. 按存储器所处位置分类

   - 内存：...
   - 外存：...

2. 按存储器构成材料分类

   - 磁存储器
   - 半导体存储器
   - 光存储器

3. **按存储器工作方式分类**

   - **读写存储器（Random Access Memory，RAM，就是随机存储器）。其是既能读取数据也能存入数据的 存储器。**
   - 只读存储器。根据数据的写入方式，这种存储器又可分为ROM、PROM、EPROM和EEPROM等类型。
     - ①**固定只读存储器（read Only Memory，ROM）。这种存储器的内容是在厂家生产时就写好的，其内容只能读出，不能改变。一般用于存放系统程序BIOS以及用于微程序控制。**
     - ②**可编程的只读存储器（Programmable** read Only Memory，**PROM**）。其中的内容可以由 用户一次性地写入，写入后不能再修改。
     - ③可擦除可编程的只读存储器（Erasable Programmable read Only Memory，EPROM）。其 中的内容既可以读出，也可以由用户写入，写入后还可以修改。改写的方法是写入之前先用紫外线照射15～20分钟以擦去所有信息，然后再用特殊的电子设备写入信息。
     - ④电擦除可编程的只读存储器（Electrically Erasable Programmable read Only Memory， EEPROM）。与EPROM相似，EEPROM中的内容既可以读出，也可以进行改写。只不过这种存储器是用电擦除的方法进行数据的改写。
     - ⑤闪速存储器（Flash Memory）。其简称闪存，闪存的特性介于EPROM和EEPROM之 间，类似于EEPROM，也可使用电信号进行信息的擦除操作。整块闪存可以在数秒内删除，速度远快于EPROM。

4. 按访问方式分类

   存储器按访问方式可分为按地址访问的存储器和按内容访问的存储器。

5. **按寻址方式分类**

   存储器按寻址方式可分为随机存储器、顺序存储器和直接存储器。

   （1）**随机存储器（Random Access Memory，RAM**）。这种存储器可对任何存储单元存入 或读取数据，**访问任何一个存储单元所需的时间是相同的。**

   （2）**顺序存储器（Sequentially Addressed Memory，SAM）。访问数据所需要的时间与数据 所在的存储位置相关，磁带是典型的顺序存储器。**

   （3）**直接存储器（Direct Addressed Memory，DAM）。介于随机存取和顺序存取之间的一 种寻址方式。磁盘是一种直接存取存储器，它对磁道的寻址是随机的，而在一个磁道内则是顺序寻址。**

   > 不是dma数据交互方式，而是dam存储器

### 随机访问存储器

随机访问存储器（ram）分为静态ram和动态ram两类。静态比动态更快也更贵

- sram：常用来做高速缓存存储器
- dram：用来作为主存及图形系统的帧缓冲存储区

### 外存储器

> 详细参考：
>
> [数字存储完全指南 02：机械硬盘的原理与参数详解 - 少数派 (sspai.com)](https://sspai.com/post/68712#!)
>
> [存储技术详解，有这一篇就够了 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/166633984)

1. **磁盘存储器（硬盘）**

   - **磁盘结构和参数**

     磁盘有**正反两个盘面，每个盘面有多个同心圆，每个同心圆是一个磁道（从外到里编号，最外一圈是0道，每个同心圆又被划分为多个扇区，数据就被存放在一个个扇区中**。

     ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243567.png)

     **磁头首先要寻找到对应的磁道，然后等待磁盘进行周期旋转，旋转到指定的扇区，才能读取到对应的数据**，因此，会产生**寻道时间（寻磁道）和等待时间（转到数据）**。

     **公式为：存取时间＝寻道时间＋等待时间（平均定位时间＋转动延迟）。**

     > 注意：**寻道时间是指磁头移动到磁道所需的时间；等待时间为等待读写的扇区转到磁头下方所用的时间。**

2. 光盘存储器

   - co-rom
   - worm

> **不考，但是是硬盘的相关知识**
>
> 1. 文件系统
>
>    用来管理目录和文件的系统叫做文件系统，它规定了文件和目录数据如何储存到储存设备上，Windows 用的文件系统是 NTFS。
>
>    因为我们很少有只占用一个扇区以下的文件，所以文件系统会将**磁盘面上相邻的若干个扇区合并为一个簇（又叫分配单元，Unix 类系统叫块，反正都是一个意思）**。**文件系统进行读写操作的基本单位就是簇。**
>
>    可以看到大小和占用空间两个属性，后面跟着的容量是不同的。「大小」就是文件的实际大小，「占用空间」就是这个文件在磁盘上占用的簇大小 ，因为 10.2 KB > 8KB，而 NTFS 文件系统的簇大小是 4KB，所以他必须要占三个簇，也就是 12KB。比较大的文件看着大小和占用空间可能一样，但仔细观察后面的字节数，也会发现相差了簇以内的字节。

### 虚拟存储器

> **实际上是一种逻辑存储器**

​	在概念上，可以**将主存存储器看作一个由若干个字节构成的存储空间，每个字节（称为一个存储单元）有一个地址编号，主存单元的该地址称为物理地址（physicaladdress）**。当需要访问主存中的数据时，由CPU给出要访问数据所在的存储单元地址，然后由主存的读写控制部件定位对应的存储单元，对其进行读（或写）操作来完成访问操作。
​    现代系统提供了一种对主存的抽象，称为**虚拟存储（virtualmemory），使用虚拟地址（viraladdress，由CPU生成）的概念来访问主存，使用专门的MMU（Memory Management unit）将虚拟地址转换为物理地址后访问主存**。设主存容量为4GB，则其简化后的访问操作和内存模型如图1-13所示。

> **转换检测缓冲区：将虚拟地址映射到物理地址的硬件机制**

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243568.png)

​      **虚拟存储器实际上是一种逻辑存储器，实质是对物理存储设备进行逻辑化的处理，并将统的逻辑视图呈现给用户。**因此，**用户在使用时，操作的是虚拟设备，无需关心底层的物理环境**，从而可以充分利用基于异构平台的存储空间，达到最优化的使用效率。

> **真题**
>
> **虚拟存储管理系统的基础是程序的局部性理论，这个理论的基本含义是指程序执行时往往会不均匀地访问主存储器单元**。根据这个理论，Denning提出了工作集理论。工作集是进程运行时被频繁地访问的页面集合。在进程运行时，如果**它的工作集页面都在主存储器**内，能够使该进程有效地运行，否则会出现频繁的页面调入/调出现象
>
> ![image-20240324200354998](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243569.png)

### 相联存储器

> **相联存储器是一种按内容访问的存储器**

## 输入输出技术（外设）

> 主存与外设之间的相互联系

### I/O设备

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243571.png)

IO设备可分为**块设备和字符设备**两类。块设备把信息存放在固定大小的块中，每个块都有自己的地址，独立于其他**块，可寻址**。**例如磁盘、USB闪存、CD-ROM等。字符设备以字符为单位接收或发送一个字符流**，**字符设备不可以寻址**。**例如打印机、网卡、鼠标键盘等**。

**IO设备一般都包含设备控制器，一般以芯片的形式出现，如南桥芯片**。不同的控制器可以控制不同的设备。南桥芯片中包含了多种设备的控制器，如硬盘控制器、USB控制器、网卡、声卡控制器等。IO设备通过总线以及卡槽与计算机其他部件进行连接，如PCI、PCI-E、SATA、

- **计算机系统中存在多种内存与接口地址的编址方法**，常见的是下面两种： 

  - 1）**内存与接口地址独立编址方法**

    内存地址和接口地址是**完全独立的两个地址空间**。**访问数据时所使用的指令也 完全不同**，用于接口的指令只用于接口的读／写，其余的指令全都是用于内存的。 因此，在编程序或读程序时很易使用和辨认。这种编址方法的**缺点是用于接口 的指令太少、功能太弱。**

  - 2）内存与接口地址**统一编址方法**

    ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243572.png)

    内存地址和接口地址**统一在一个公共的地址空间里**，即内存单元和接口**共用地 址空间。优点是原则上用于内存的指令全都可以用于接口**，这就大大地增强了 **缺点就在于整个地址空间被分成两部分**，其中一部分分配给接口使用，剩余的 为内存所用，这经常会导致内存地址不连续。

- **计算机和外设间的数据交互方式：（常考）**

  - **程序控制（查询/直接）方式**：CPU**主动查询外设是否完成数据传输，效率极低**。

    > **等到外设传输完成后，cpu才能做别的，相当于串行**

  - **程序中断方式：**外设完成数据传输后，**向cpu发送中断**，等待cpu处理数据效率相对较高。**中断响应时间指的是从发出中断请求到开始进入中断处理程序； 中断处理时间指的是从中断处理开始到中断处理结束。中断向量提供中断服务 程序的入口地址。**多级中断嵌套，使用堆栈来保护断点和现场。

    > 可以同时进行

  - **DMA方式（direct memory access，直接主存存取）：cpu秩序完成必要的初始化等操作，数据传输的整个过程都由DMA控制器来完成，在主存和外设之间建立直接的数据通路， 效率很高。**

    > **cpu不参与，dma自己完成**

  > **在一个总线周期结束后，CPU会响应DMA请求开始读取数据；CPU响应程序中 断方式请求是在一条指令执行结束时。**
  
  ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243573.png)
  
  

### 总线结构

总线（Bus），是指**计算机设备和设备之间传输信息的公共数据通道**。总线是 连接计算机硬件系统内多种设备的通信线路，它的一个重要特征是**由总线上的 所有设备共享**，因此可以将计算机系统内的多种设备连接到总线上。

> 一条总线同一时刻仅允许一个设备发送，但允许多个设备接收。
>
> 总线：连接多个部件的信息传输线，是各部件共享的传输介质

- 从广义上讲，**任何连接两个以上电子元器件的导线都可以称为总线**，通常分 为以下三类：

  - 内部总线（电路板上）：内部芯片级别的总线，芯片与处理器之间通信的总线。

    > 书上没这种，不考

    > **系统总线（内部线）：是板级总线 用于计算机内各部分之间的连接，具体分为**

    - **数据总线Data Bus DB（并行数据传输位数，如32位）**

    - **地址总线AB（系统可管理的内存空间的大小（32位系统最大只能支持2^32=4gb内存））**
  
    - **控制总线 CB（传送控制命令）。代表的有ISA总线、EISA总线、PCI总线。**
  
    ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243574.png)
  
    > **系统总线目的在于增减外设（更换内存条等），同时减少信息传输线（注意是线）的数量；但缺点在于降低了信息传输的并行性、信息的传输速度**
    >
    > - **优点：**
    >   - **简化了系统结构**，便于系统设计制造
    >   - 大大减少了连线数目，便于布线，减小体积，**提高系统的可靠性**
    >   - 便于接口设计，所有与总线连接的设备**均采用类似的接口**
    >   - 便于**系统的扩充、更新**与灵活配置，易于实现**系统的模块化**
    >   - 便于设备的软件设计，所有接口的软件就是**对不同的接口地址进行操作**
    >   - 便于故障诊断和维修，同时也**降低了成本**
    >
    > 特点：在某一时刻，只允许有一个不见向总线发生信息，但多个部件可同时从总线接受相同信息。总线的信息传输可以串行和并行
    >
  
  - 外部总线：设备一级的总线，微机和外部设备的总线。代表的有RS232（串行总 线）、**SCSI（并行总线**）、**USB**（通用串行总线，即插即用，支持热插拔）。 
  
    > 书上没这种，不考
  
    > 总线的性能指标：
    >
    > 带宽、位宽、工作频率
  
  ![image-20240330171300916](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243575.png)
  
  > **总线宽度指的是总线的位数，即数据信号的并行传输能力，也体现总线占用的物理空间和成本；总线的带宽指总线最大数据传输率，即每秒传输的数据总量，总线宽度和始终频率共同决定了总线的带宽：总线带宽=时钟频率/时钟周期*总线宽度**

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243576.png)

> **单总线：只有一条线，很多设备挂载在这一条线上，上面的设备都能同时接受数据，但同一时刻，只能由一台设备接受数据，不同时刻才能多台**

### 输入输出控制

#### 程序控制方式

 （1）**无条件传送**：外设总是准备好的，无条件，随时接收和提供数据。
 （2）**程序查询方式**：CPU利用程序来查询外设的状态，准备好了再传数据。

#### 中断方式

CPU不等待，也不执行程序去查询外设的状态，而是由外设在准备好以后，向CPU发出中断请求信号通知CPU，**CPU收到中断请求信号以后，保存正在执行程序的现场**，转入I/0中断服务程序的执行，然后再**返回到被打断的程序继续执行**。
    在有多个中断源的情况下，常用的处理方法有中断信号线法、中断软件查询法、菊花链法，总线仲裁法，**中断向量表法**。可以**按中断源的优先级来安排服务的先后顺序**。

（1）**多中断信号线法**。每个中断源都有属于自己的一根中断请求信号线向CPU提出中断
请求。
（2）**中断软件查询法**。当CPU检测到一个中断请求信号以后，即转入到中断服务程序去轮询每个中断源以确定是谁发出了中断请求信号。对各个设备的响应优先级由软件设定。  
（3）**菊花链法**。软件查询的缺陷在于花费的时间太多。菊花链法实际上是一种硬件查询法所有的IO模块共享一根共同的中断请求线，而中断确认信号则以链式在各模块间相连。当CPU检测到中断请求信号时，则发出中断确认信号。中断确认信号依次在IO模块间传递，直到发出请求的模块，该模块则把它的I送往数据线由CPU读取
（4）**总线仲裁法**。一个IO设备在发出中断请求之前，必须先获得总线控制权，所以可由总线仲裁机制来裁定谁可以发出中断请求信号。当CPU发出中断响应信号后，该设备即把自己的ID发往数据线
（5）**中断向量表法。中断向量表用来保存各个中断源的中断服务程序的入口地址。当外设发出中断请求信号（INTR）以后，由中断控制器（INTC）确定其中断号，并根据中断号查找中断向量表来取得其中断服务程序的入口地址，同时INTC把中断请求信号提交给CPU**

![image-20240408193536831](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243577.png)

> **中断嵌套：在一个中断中调用了另一个中断（优先级更高**）
>
> **优先级情况：**
>
> 1. **多个中断源则选择优先级高的**
> 2. **中断嵌套问题**

#### 直接内存存取（DMAC）方式

数据的传输是在 **主存和外设之间直接进行的**，不需要cpu的干预，只需要cpu在过程开始和结束时发出一些命令，实际操作是由DMA硬件之间执行完成的，期间cpu可以处理别的任务

#### IO通道方式和外围处理机（IOP）方式

更进一步减轻了CPU对IO操作的控制，更进一步提高了CPU的工作效率，但是是以增加更多硬件为代价的

### 数据传输方式

| 控制     | 方式     | 特点                                             | 内容                                                         | 子分类             | 备注                                                         |
| -------- | -------- | ------------------------------------------------ | ------------------------------------------------------------ | ------------------ | ------------------------------------------------------------ |
| cpu      | 程序查询 | CPU主动，轮询外设，原理简单，CPU效率低外设主动， |                                                              | 无条件传送         | 不考虑外设状态，假定它们随时可收发数据                       |
|          | 程序中断 | 外设主动，耗时<br/>                              | CPU需先新停当前工作，执行中断，然后返回<br/>                 | 查询（有条件传送） | 执行/操作前先查询设备状态，空闲时操作                        |
| **DMAC** | **DMA**  | **速度快<br/>CPU不参与DMAC临时接管**             | **1、DMA需CPU控制传输块大小和内存地址，IO通道不需要<br/>2、DMA控制1台设备与内存传输，/0通道则控制多台** |                    | 适合少量数据<br/>                                            |
| IO通道   | 类似DMA  | CPU干预更少                                      |                                                              |                    | DMAC只负责传输，管理和控制/设备仍由CPU负<br/>是对DMA控制方式的发展 |

### 生物特征认证技术

> **指通过计算机利用人体固有生物特征（先天）或行为特征（后天）鉴别个人身份**
>
> 人体特征转换为数字形式存储到计算机中，通过匹配算法完成验证和识别个人身份

- 生物特征（先天）
  - 人脸识别
  - 指纹识别
  - 虹膜识别
  - 掌静脉识别
  - 声纹识别
- 行为特征（后天）
  - 笔记识别
  - 步态识别

## 安全性、可靠性、性能评价

### 计算机可靠性

#### 可靠性指标

平均无故障时间**MTTF（mean time to failure）**=1/失效率。

平均故障修复时间**MTTR（Mean Time To Repair）**=1/修复率。

平均故障间隔时间**MTBF（Mean Time Between Failure）=MTTF+MTTR**。

> F：failure；
>
> R：repair；
>
> B：between；

系统可用性=MTTF/（MTTF+MTTR）*100%。

#### 串并联系统可靠性

无论什么系统，都是由多个设备组成的，协同工作，而这多个设备的组合方式可以是串联、并联，也可以是混合模式， 假设每个设备的可靠性为R1，R2.....Rn则不同的系统的可靠性公式如下：

- **串联系统   个设备不可靠，整个系统崩溃，整个系统可靠性R=R1*R2*..*Rn。**

  ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243578.png)

#### 并联系统可靠性

**所有设备都不可靠，整个系统才崩溃，整个系统可靠性R=1-（1-R1）*（1-R2)*.*(1-Rn）。**

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243579.png)

#### N模元余系统

- N模余系统由**N个（N=2n+1）相同的子系统和一个表决器组成**，表决器把N个子系统中占多数相同结果的输出作为输出系统的输出，如图所示。在N个子系统中，只要有**n+1个或n+1个以上子系统能正常工作，系统就能正常工作**，输出正确的结果

  > 少数服从多数：一般以上可靠能正常工作

![image-20240330170237220](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243580.png)


### 计算机系统性能评价

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243581.png)

- 性能评测的常用方法
   （1）**时钟频率**。一般来讲，主频越高，速度越快
   （2）**指令执行速度**。计量单位KIPS 每秒千万条指令、MIPS 每秒百万条指令(Million Instruction Per Second)。
   （3）**等效指令速度法**。统计各类指令在程序中所占比例，并进行折算，是一种固定比例法。
  （4）**数据处理速率（ProcessingDataRate，PDR）法**。采用计算PDR值的方法来衡量机器性能，PDR值越大，机器性能越好。PDR与每条指令和每个操作数的平均位数以及每条指令的平均运算速度有关。
   （5）**核心程序法（属于基准程序法）**。**把应用程序中用得最频繁的那部分核心程序作为评价计算机性能的标准程序，也简称为基准程序法**，在不同的机器上运行，测得其执行时间，作为各类机器性能评价的依据
-  **基准程序法（Benchmark）**是目前被用户一致承认的测试性能的较好方法，有多种多样的基准程序，包括：
   （1）**整数测试程序**。同一厂家的机器，采用相同的体系结构，用相同的基准程序测试，得到的MIPS值越大，一般说明机器速度越快
   （2）**浮点测试程序**。指标MFLOPS（理论峰值浮点速度）
   （3）**SPEC基准程序（SPECBenchmark）**。重点面向处理器性能的基准程序集将被测计算机的执行时间标准化，即将被测计算机的执行时间除以一个参考处理器的执行时间
   （4）**TPC基准程序**。用于评测计算机在事务处理、数据库处理、企业管理与决策支持系统等方面的性能。其中，TPC-C是在线事务处理（On-lineTransactionProcessing，OLTP）的基准程序，TPC-D是决策支持的基准程序。TPC-E作为大型企业信息服务的基准程序

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243582.png)

### 信息安全

- **信息安全含义及属性：保护信息的保密性、完整性、可用性**，另外也包括其他属性，如：真实性可核查性、不可抵赖性和可靠性

- **保密性：信息不被泄漏给未授权的个人、实体和过程或不被其使用的特性包括**：（1）最小授权原则（2）防暴露（3）信息加密（4）物理保密：①物理设备②电磁波（拦截）

- **完整性：信息未经授权不能改变的特性**。影响完整性的主要因素有设备故障误码、人为攻击和计算机病毒等。保证完整性的方法包括
  -  （1）协议：通过安全协议检测出被删除、失效、被修改的字段
  
  -  （2）纠错编码方法：利用校验码完成检错和纠错功能。
  
  -   （3）密码校验和方法。
  
  -  （4）**数字签名**：能识别出发送方来源。
  
  -  （5）公证：请求系统管理或中介机构证明信息的真实性
  
- **可用性：需要时，授权实体可以访问和使用的特性**。 一般用系统正常使用时间和整个工作时间之比来度量

其他属性：

- **真实性：指对信息的来源进行判断**，能对伪造来源的信息予以鉴别

- **可核查性**：系统实体的行为可以**被独一无二的追到该实体的特性**，这个特性就是要求该实体对其行为负责，为探测和调查安全违规事件提供了可能性。

- **不可抵赖性：是指建立有效的责任机制，防止用户否认其行为**，这一点在**电子商务**中是极其重要的

  > 相对重要
  >
  > ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243583.png)

- **可靠性**：系统在规定的时间和给定的条件下，**无故障地完成规定功能的概率**







> **安全需求**
>
> - 可划分为**物理线路安全、网络安全 系统安全和应用安全**；从各级安全需求字面上也可以理解：
>
> - 物理线路就是**物理设备 物理环境**
> - 网络安全指**网络上的攻击、入侵**
> - 系统安全指的是**操作系统漏洞、补丁**等
> - 应用安全就是**上层的应用软件，包括数据库软件**

### 加密技术

#### 对称（私钥）加密技术

> **数据的加密和解密的密钥（密码）是相同的，属于不公开密钥加密算法。其缺点是加密强度不高**（因为密钥位数少），且**密钥分发困难**（因为密钥还需要传输给接收方，也要考虚保密性等问题）。**优点是加密速度快，适合加密大数据**。
>
> - 常见的**对称密钥加密算法（私密）**如下：
>
>   **DES(data encryption standard)**：数据加密标准，是分组加密算法。替换+移位、**56（比特）位密钥**、64位数据块、速度快，密钥易产生
>
>   **3DES**：三重DES，两个56位密钥K1、K2。
>
> -    加密：K1加密->K2解密->K1加密
>
> -    解密：K1解密->K2加密->K1解密
>
>   **AES(advanced encryption standard)**：高级加密标准，是美国联邦政府采用的一种区块加密标准，这个标准用来替代原先的DES。对其的要求是“至少像3DES一样安全”
>
>   **RC-5**：RSA数据安全公司的很多产品都使用了RC-5。
>
>   **IDEA(international data encryption algorithm)**：国际数据加密算法，**128位密钥，64（明文和密文都是64比特）**位数据块，比DES的加密性好，对计算机功能要求相对低，主要用于PGP
>
> > 安全和效率是对立的，无法两全其美
>>
> > 密钥位数为128以内
> 
> **RC5：适合大量数据的加密**

#### 非对称加密技术（公钥）

> - **数据的加密和解密的密钥是不同的**，分为公钥和私钥。**公开密钥加密算法其缺点是加密速度慢。优点是安全性高，不容易破解**
>  **非对称技术的原理是：发送者发送数据时，使用接收者的公钥作加密密钥，私钥作解密密钥**，这样只有接收者才能解密密文得到明文。安全性更高，因为无需传输密钥。**但无法保证完整性**。如下：
>
> ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243584.png)
>
> > 用b的公钥发送，这样只有b的私钥能解开，保证了数据的安全 
>
> - **常见的非对称加密算法**如下：
>  **RSA**：三个科学家联名发出，非对称算法，**512位（或1024位）密钥**，计算机量极大，难破解。
> - **DSA：也可以用于数字签名**
> - Elgamal、EcC（圆曲线算法，用于比特币加密）、背包算法、Rabin、D-H等。
>
> > （对称加密和非对称加密的联合使用）

#### 对称和非对称加密算法的区别

> | 对称加密算法（带E：encrption） | 不对称加密算法                      |
> | ------------------------------ | ----------------------------------- |
> | **AES**                        | **RSA（三个人）、DSA**              |
> | **DES**                        | Elgamal                             |
> | **3DES**                       | EcC（圆曲线算法，用于比特币加密）、 |
> | **RC系列**                     | 背包算法、Rabin、D-H等              |
>
> 相比较可知，**对称加密算**法密钥一般只有56位，因此**加密过程简单**，**适合加密大数据，也因此加密强度不高**：而**非对称加密算法**密钥有1024位，**相应的解密计算量庞大，难以破解，却不适合加密大数据**，一般用来加密对称算法的密钥
>
> **因此对称算法的算法效率比较高**
>
> ![image-20240324153106371](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243585.png)
>
> **将两个技术组合使用了，这也是数字信封的原理**



#### 数字信封原理

> **（保证了数据的安全性）**

> **数字信封原理：信是对称加密的密钥**，数字信封就是对此密钥进行非对称加密，具体过程：发送方**将数据用对称密钥加密传输**，**而将对称密钥用接收方公钥加密发送给对方。接收方收到数字信封，用自己的私钥解密信封**，取出对称密钥解密得原文。
>
> > 相当于套了层娃；**数字信封运用了对称加密技术和非对称加密技术**，**本质是使用对称密钥加密数据，非对称密钥加密对称密钥，解决了对称密钥的传输问题**
>
> ![image-20240324162414882](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243586.png)



#### 数字签名

> **唯一标识一个发送方，用到了哈希函数，与非对称加密步骤相反**

> - 保证了**完整性和不可抵赖性**，却**失去了数据安全性**
>
>   通过公钥私钥发送者发送数据时，**使用发送者的私钥进行加密，接收者收到数据后，只能使用发送者的公钥进行解密，这样就能唯一确定发送方**，这也是数字签名的过程但**无法保证机密性**。如下：
>
> ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243587.png)
>
> > 用途可能就是需要确保是某一方发送的，但同时数据内容不重要，可以公之于众那种
>
> ![image-20240324162528513](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243588.png)



#### 信息摘要

> **（哈希函数，摘要算法，杂凑算法，密码散列），可以检测数据是否进行了修改，保证了数据的完整性**

> - 所谓信息摘要，**就是一段数据的特征信息，当数据发生了改变，信息摘要也会发生改变，发送方会将数据和信息摘要一起传给接收方，接收方会根据接收到的数据重新生成一个信息摘要**，若此摘要和接收到的摘要相同，则说明数据正确。**信息摘要是由哈希函数生成的**
> - 信息摘要的特点：**不算数据多长，都会产生固定长度的信息摘要；任何不同的输入数据，都会产生不同的信息摘要**；单向性，即**只能由数据生成信息摘要不能由信息摘要还原数据。**
> - 信息摘要算法：
>   - **MD2**
>   - **MD4**
>   - **MD5：信息摘要算法**，**message-digest algorithm**，产生128位的输出
>   - **SHA-1：安全散列算法1**，**secure Hash Algorithm-1**，产生160位的输出，安全性更高



#### 公钥基础设施PKI

>**公钥基础设施PKI：是以不对称密钥加密技术为基础**，以数据机密性、完整性身份认证和行为不可抵赖性为安全目的，来实施和提供安全服务的具有普适性的**安全基础设施**
>
>- （1）**数字证书**：一个数据机构，是一种由一个**可信任的权威机构签署的信息集合**。在不同的应用中有不同的证书。如×.509证书必须包含下列信息：（1）版本号（2）序列号（3）签名算法标识符（4）认证机构（5）有效期限（6）主题信息（7）认证机构的数字签名（8）**公钥信息**
>
>- **公钥证书主要用于确保公钥及其与用户绑定关系的安全。这个公钥就是证书所标识的那个主体的合法的公钥**。任何一个用户只要知道签证机构的公钥，就能检查对证书的签名的合法性。如果检查正确，那么用户就可以相信那个证书所携带的公钥是真实的，而且这个公钥就是证书所标识的那个主体的合法的公钥。**例如驾照**
>
>-  （2）**签证机构CA（Certificate Authority）：负责签发证书、管理和撤销证书**。是所有注册用户所信赖的权威机构，CA在给用户签发证书时**要加上自己的数字签名，以保证证书信息的真实性。任何机构可以用CA的公钥来验证该证书的合法性。**
>
> ![image-20240324161745482](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243589.png)

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243590.png)

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243591.png)

![image-20240324161904751](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243592.png)

## 多媒体知识

### 媒体分类

国际电话电报咨询委员会（CCITT将媒体分为感觉媒体、表示媒体、表现媒体、存储媒体和传输媒体5类

- **感觉媒体**指直接作用于人的感觉器官，使人产生直接感觉的媒体，如引起听觉反应的**声音**，引起视觉反应的**图像**等
- **传输媒体**指传输表示媒体的物理介质，如**电缆、光缆、电磁波**等；
- **表示媒体**指传输感觉媒体的中介媒体，即用于数据交换的编码如图像编码、文本编码和声音**编码**等
- **表现媒体**是指进行信息输入和输出的媒体，如**键盘、鼠标、话筒，以及显示器打印机、喇叭**等
- **存储媒体**指用于存储表示媒体的物理介质，如**硬盘、光盘**等

> **总结**
>
> **感觉媒体：感觉，那就是声音图像这些**
>
> **传输：顾名思义**
>
> **表示：编码**
>
> **表现：主机外设**
>
> **存储：顾名思义**

### 文件格式

- wav是声音文件格式
- bmp是图像格式
- mov是和视频文件格式

### 声音频率问题

音频数字化过程中采样**频率应为声音最高频率2倍。本题采样频率为8KHz，所以其语音的最高频率应不超过4KHz**



![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243593.png)

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243594.png)

### 像素问题

**图像分辨率是指组成一幅图像的像素密度；也是水平和垂直的像素表示；即用每英寸多少点（dpi）表示数字化图像的大小。**
用**300dpi来扫描一幅3*4英寸**的彩色照片，那么得到一幅**900\*1200=300*3 * 300*4**个像素点的图像



![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243595.png)

### 多媒体内容接口标准问题

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243596.png)

### 彩色打印机所用的颜色空间

CMY颜色空间

### mpeg视频编码

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243597.png)

# 程序语言基础

![image-20240322093604201](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243598.png)

## 程序设计语言的基本概念

- 程序设计语言是为了书写计算机程序而人为设计的符号语言，用于对计算过程进行描述、组织和推导。

- 低级语言（面向机器）：**机器语言（计算机硬件只能识别和1的指令序列），汇编语言。**

  > 何为低级（底级）？
  >
  > 接近计算机硬件的就是低级，用的是二进制
  >
  > 何为汇编？
  >
  > 用**符号**表示的如add,sub之流叫做**汇编指令，而汇编语言和高级语言编写的程序称为源程序**

- 高级语言：功能更强，抽象级别更高，**与人们使用的自然语言比较接近。**

- 各**程序设计语言**特点

**Fortran语言：科学计算，执行效率高**。
**Pascal语言：为教学开发，表达能力强。**
C语言：**指针操作能力强**，可以开发系统级软件，**高效**，**结构化语言**
**C++语言：面向对象**，高效。
**Java语言：面向对象**，中间代码，**跨平台**。
**C#语言：面向对象**，中间代码，Net框架，微软开发

Python是一种**面向对象、解释型、脚本**计算机程序设计语言
**Prolog是逻辑型程序设计语言。**



- **汇编：将汇编语言翻译成目标程序执行,针对汇编语言**

- **解释和编译：将高级语言来进行执行（不生成可执行文件）**。不同之处在于**编译程序生成独立的可执行文件，直接运行，运行时无法控制源程序，效率高。而解释程序不生成可执行文件，可以逐条解释执行，用于调试模式，可以控制源程序**，因为还需要控制程序，因此**执行速度慢，效率低。**  

  > 如c语言进行编译有产生exe执行文件
  >
  > python是解释，所有没有exe文件



- **程序设计语言定义四要素：语法、语义、语用和语境。**

- **语法**是指由程序设计语言的基本符号组成程序中的**各个语法成分（包括程序）的组规则，其中由基本字符构成的符号（单词）书写规则称为词法规则，由符号构成语法成分的规则称为语法规则。**

  > 单词（符号）叫词法，符号就做语法

- **语义**是程序设计语言中**按语法规则构成的各个语法成分的含义**，可分为静态语义和动态语义。**静态语义指编译时可以确定的语法成分的含义，而运行时刻才能确定的含义是动态语义**。一个程序的执行效果说明了该程序的语义，它取决于构成程序的各个组成部分的语义。

  ![image-20240430180040435](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243599.png)

- **语用表示了构成语言的各个记号和使用者的关系**，涉及符号的来源使用和影响

- **语言的实现则有个语境问题**。语境是指理解和实现程序设计语言的环境，包括编译环境和运行环境。

> **程序设计语言定义总结**
>
> 1. **词法分析**：编译的**第一阶段**，从中识别出一个个“**单词”符号**
> 2. **语法分析**：确定整个**输入串是否构成一个语法上正确的程序**。一般通过编译的程序，不存在语法上的错误
> 3. **语义分析**：主要是检查源程序进行**类型分析和检查**，并**收集类型信息供后面的代码**生成阶段使 用
> 4. **中间代码生成**：**根据语义分析的输出生成中间代码**
> 5. **目标代码生成**：编译的**最后一个阶段**。是**把中间代码转换成机器上的绝对指令代码、可重定位的指令代码或汇编指令代码**





- **程序设计语言的分类**
   （1）**命令式和结构化程序设计语言**，包括Fortran、PASCAL和C语言。

  > 结构化：自顶向下

   （2）**面向对象程序设计语言**，包括C++、JAVA和Smalltalk语言。
   （3）**函数式程序设计语言**，包括LISP、Haskell、Scala、Scheme、APL等。
   （4）**逻辑型程序设计语言**，包括PROLOG。

  
  
  ![image-20240324200439858](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243600.png)
  
  

## 程序设计语言的基本成分

**1.数据成分：指一种程序设计语言的数据和数据类型**。**数据分为常量（程序运行时不可改变）、变量（程序运行时可以改变）、全局量（存储空间在静态数据区分配）、局部量（存储空间在堆栈区分配）**。数据类型有整型、字符型、双精度、单精度浮点型、布尔型、结构体等。

2.**运算成分：指明允许使用的运算符号及运算规则**。包括算术运算、逻辑运算关系运算、位运算等。

3.**控制成分：指明语言允许表述的控制结构包括顺序结构、、选择结构、循环结构**。如下图所示。

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243601.png)

​		4.**传输成分**：指明**语言允许的数据传输方式**。 如赋值处理  数据的输入输出等

​		5.函数：C程序由一个或多个函数组成，每个函数都有一个名字，其中**有且仅有个名字为main的函数作为程序运行时的起点。函数的使用涉及3个概念：函数定义、函数声明和函数调用**。

- 函数的定义包括两部分：**函数首部和函数体**。函数的定义描述了函数做什么和怎么做。函数定义的一般形式为：

  返回值的类型函数名（形式参数表）//函数首部

  {

  函数体；

  }

  函数首部说明了函数返回值的数据类型、函数的名字和函数运行时所需的参数及类型。函数所实现的功能在函数体部分进行描述。

- **函数应该先声明后引用**。**如果程序中对一个函数的调用在该函数的定义之前进行，则应该在调用前对被调用函数进行声明。函数原型用于声明函数**。函数声明的一般形式为：

  返回值类型函数名（参数类型表）

- **函数调用的一般形式为**
  函数名（实参表）；
  函数调用时**实参与形参间交换信息的方法**有值调用和引用调用两种。
  （1）**值调用（callbyValue）**。若实现函数调用时将**实参的值传递给相应的形参**，则称为是传值调用。在这种方式下形参不能向实参传递信息。
  在C语言中，**要实现被调用函数对实参的修改，必须用指针作为参数。即调用时需要先对实参进行取地址运算**，然后将实参的地址传递给指针形参。

  > **其本质上仍属于值调用。这种方式实现了间接内存访问。**

   （2）**引用调用（CallbyReference）**。**引用是C++中引入的概念**，当形式参数为引用类型时，形参名实际上是实参的别名，函数中对形参的访问和修改实际上就是针对相应实参所做的访问和改变。

![31](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243602.png)

## 编译程序基本原理

- 编译程序对高级语言源程序进行编译的过程中，要不断收集、记录和使用源程序中一些相关符号的类型和特征等信息，并将其存入符号表中，编译过程如下：

- **词法分析**：是编译过程的第一个阶段。这个阶段的任务是**从左到右一个字符一个字符地读入源程序**，即对构成源程序的**字符流进行扫描然后根据构词规则识别单词（也称单词符号或符号）**。

  > 输入是字符流

- **语法分析**：是编译过程的一个逻辑阶段。**语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语**，如“程序”，“语句”，“表达式”等等.语法分析程序判断源程序在结构上是否正确

  > 输入是**记号流**
  >
  > 有括号匹配

- **语义分析**：是编译过程的一个逻辑阶段.语义分析的任务是**对结构上正确的源程序进行上下文有关性质的审查，进行类型审查**。**如类型匹配、除法除数不为0等。又分为静态语义错误（在编译阶段能够查找出来）和动态语义错误（只能在运行时发现）。**

  ![32](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243603.png)

- **中间代码和目标代码：中间代码是根据语义分析产生的，需要经过优化链接最终生成可执行的目标代码**。引入中间代码的目的是进行与机器无关的代码优化处理。常用的中间代码有**后缀式（逆波兰式）、三元式（三地址码）、四元式和树等形式**。需要考虑三个问题（一是**如何生成较短的目标代码；二是如何充分利用计算机中的寄存器，减少目标代码访问存储单元的次数；三是如何充分利用计算机指令系统的特点，以提高目标代码的质量）**。

  > 出错分为动态错误和静态错误，动态错误是指程序运行时发生的错误，如input输入一个0后作为除数；静态错误则是运行之前，如标点符号错误等

![33](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243604.png)

![34](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243605.png)

# 数据结构与算法

![image-20240322093552812](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243606.png)

## 线性表

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243607.png)

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243608.png)

> 无论是线性表的顺序存储还是链式存储，其元素可以是任意数据类型，包括简单的整数、字符，也可以是复杂的如结构体、类的实例**等**

### 基本概念

**线性表是一个具有相同特性的数据元素的有限序列。**

> 一致性（相同特性）：所有元素属于同一数据类型。
>
> 有穷性：数据元素个数是有限的。
>
> 序列：数据元素由逻辑序号唯一确定。一个线性表中可以有相同值的元素。**一个线性表中所有元素之间的相对位置是线性的**
>
> 线性表的入和出的操作都要考虑元素是否满|空

### 顺序表

> 随机存取

按逻辑顺序依次存储到存储器中一片连续的存储空间中。

- 定义

  ```c
  typedef struct 
  {  ElemType data[MaxSize];
     int length;
  } SqList;    	//顺序表类型  
  ```

  > 说明：注意逻辑位序和物理位序相差1。

- 各算法实现：

  > 插⼊数据要判满，删除数据要判空
  >
  > 插⼊删除有可能移动数据
  >
  > **顺序表中插入一个元素平均移动n/2次，删除一个元素平均移动(n-1)/2，两者的时间复杂度都是O（n）**

### 链表

> 每个物理结点增加一个指向后继结点的指针域为单链表。
>
> 每个物理结点增加一个指向后继结点的指针域和一个指向前驱结点的指针域为双链表。
>
> 链表的存储是无序的，但是链表的查找还是得用顺序查找，叫做**顺序存取**

#### 单链表

- 单链表的考察（存储密度）

  **存储密度=数据占用的空间/结点总占用空间**

- 定义

  ```c
  typedef int ElemType;
  typedef struct LNode{
  	ElemType data;
  	struct LNode * next;
  }LinkNode; //LNode强调的是结点，LinkNode强调的是链表
  ```

- 创建

  > 创建有头插法和尾插法
  >
  > 头插法可以同于链表的逆置。逆序
  >
  > 尾插法正序

#### 双链表

> 与单链表大同小异，下面只写有区别的

- 定义

  ```c
  typedef int ElemType;
  typedef struct LNode{
  	ElemType data;
  	struct LNode * next,*prior;
  }LinkNode; 
  ```

#### 静态链表

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243609.PNG)

### 有序表

> **注意区分顺序表和有序表的概念：有序表要求数据是有序存放的，顺序表没有这个要求**
>
> 很显然，有序表是线性表的一个子集。
>
> 有序表也可以用顺序存储实现或链式存储实现



## 栈与队列

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243610.png)

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243611.png)

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243612.png)

> 栈和队列是操作受限制的线性表

### 栈

> LIFO
>
> 栈的顺序存储结构入栈都是指针先，出栈都是指针后

#### 顺序栈

> 演示：[Array Stack Visualization (usfca.edu)](https://www.cs.usfca.edu/~galles/visualization/StackArray.html)

- 定义：

  ```c
  typedef struct{ 
      Elemtype data[Maxsize]; 
      int top; 
  }SqStack;
  ```

  - **栈空（初始化）：s->top==-1**

  - **栈满：s->top==Maxsize-1**

  - 进栈：指针**先加**1

  - 出栈：**先取**出来，指针**再减**1


  > 注意看题目需求条件，也可以**栈空从top==0开始**，然后入栈就是后指针，出栈就是先指针
  >
  > n个元素的合法出栈序列个数**（卡特兰数）：**
  >
  > **Cn 2n/(n+1)      ==         An 2n/(n! * (n+1))**
  >
  > 例如n=4时，=8*7*6*5/(4! * 5)=14



> 因为入栈与出栈不需要移动表中元素，因此入栈出栈**时间复杂度都是O（1）**

#### 顺序共享栈

> 是为了节省普通顺序栈中浪费的空间

- 定义：

  ```c
  typedef struct{ 
      Elemtype data[Maxsize]; 
      int top,top2; //top是左边下标从0开始的栈，top2是右边下标从Maxsize开始的栈 
  }SqStack;
  ```

  - 栈空（初始化）：栈1空为top1==-1；栈2空为top2==Maxsize

  - 栈满：**top1==top2-1**

  - 进栈：先动指针

  - 出栈：先取出来，再动指针

- 算法的实现：多了一个变量用来判断是对哪个栈进行操作，了解即可

#### 链栈

> [Linked List Stack Visualization (usfca.edu)](https://www.cs.usfca.edu/~galles/visualization/StackLL.html)

- 定义：

  ```c
  typedef struct linknode{ 
      Elemtype data; 
      struct linknode *next; 
  }LinkStNode;
  ```

  - **栈空（初始化）：s->next==NULL**

  - 栈满：不会栈满

  - 进栈：新建结点**头插法**

  - 出栈：**取出第一个值**后删除结点

    > p=head->next;e=p->data;head->next=p->next;free(p);

  > 栈底存在时，栈底->next==NULL

### 栈的应用

> - 括号匹配
> - 表达式求值
> - 递归
> - 求解迷宫
> - （二）进制转换
> - c语言中临时变量

- 表达式求值

  - 前缀表达式==先序遍历

  - **中缀表达式（加括号）==中序遍历**

  - 后缀表达式==后序遍历

    > 前缀表达式也叫波兰表达式，后缀表达式也叫逆波兰表达式
    >
    > **转换规则：转换后的运算数的相对位置不能变，但是运算符号可以改变位置，意味着一个中缀表达式可能有多个后缀表达式或前缀表达式。但如果按相同运算符等级从左到右则转换的结果唯一**
    >
    > 转化成后缀表达式后的运算符的从左到右的顺序就是原本中缀表达式中运算符的执行顺序
    >
    > 前缀：运算符在中缀表达式的操作数的前面；后缀：运算符在中缀表达式的操作数的后面；也就是遵循就近原则
    >
    > **如中缀：1+2*3**
    >
    > - **前缀：+1*2 3**
    > - **后缀：1 2 3 * +**

    > 后缀表达式是从左到右入栈
    >
    > 前缀表达式是从右到左入栈

### 队列

> FIFO
>
> 尾进头出
>
> **入动rear**
>
> **出动front**

#### 顺序队

> [Array Queue Visualization (usfca.edu)](https://www.cs.usfca.edu/~galles/visualization/QueueArray.html)

- 定义：

  ```c
  typedef struct{ 
      elemtype data[Maxsize]; 
      int rear,front;  //头指针和尾指针的下标 
  }SqQueue;
  ```

  - 初始化：q->rear=q->front**=-1**

  - **队空：q->front==q->rear**

    > **不一定==-1**

  - 队满：q->rear==Maxsize-1

  - **入队：++rear**

  - **出队：++front**


  > 如果题目要求初始化从0开始，那么入队出队都是后指针
  >
  > 注：**front始终是首节点的前一个位置**
  >
  > 队的所有入队出队都是先动下标（指针）后放（拿）数据
  >
  > 有n个空间的队列最多只能执行n次入队，有n个空间的循环队列，最多只能执行n-1次入队



> 因为入与出操作都不需要移动表中元素，因此入和出的**时间复杂度都是O（1）**

#### 顺序循环（环形）队

> 避免空间浪费
>
> **循环队，那一定就是顺序存储的队，且该队的操作要取余（除了rear）**

- 定义：

  - **初始化：q->front=q->rear=0**


    - **队空：q->rear==q->front**
    
      > 那么初始化状态也算做队空
      >
      > **但是队空不一定是0位置**


    - **队满：(q->rear+1)%Maxsize==q->front**
    
      > **队尾指针正好在队头指针的后一位，则队满**
      >
      > **浪费掉一个空间，用来区分队空与队满**


    - **入队：q->rear=(q->rear+1)%Maxsize**


    - **出队：front=(front+1)%Maxsize**


- 在尾指针头指针和元素个数中仅有两个的情况

  - **元素个数：count=(rear-front+Maxsize)%Maxsize**

  - **队头位置：front=(rear-count+Maxsize)%Maxsize**

    > **只要有减号-，那就是需要加上Maxsize再取整的**

  - **队尾位置：rear=(front+count)**

    > 注：front始终是首节点的前一个位置
    >
    > **只有加号+，没有减号-，则与Maxsize无关，不用Maxsize**

#### 链队

- 定义：

  ```c
  //定义单链表的结构 
  typedef struct qnode{ 
      elemtype data; 
      struct qnode *next; 
  }Datanode;  //表示单链表结点 
  //定义链队的结构 
  typedef struct{ 
      Datanode *front; Datanode *rear; 
  }Linkqunode;  //表示链队结点
  ```

  - 初始化：q->front=q->rear=NULL

  - 队空：q->rear==NULL **或** q->front==NULL

  - 队满：不存在

  - 入队：分配结点，尾插入链表中（链表为空要特殊处理），动尾指针

  - 出队：动头指针（只有一个元素要特殊处理），拿出数据，释放节点空间

  - 判断**链队只有一个结点：q->front==q->rear!=NULL**


  > 注：若用无头结点的单链表实现，且此时front指向首节点，默认是头节点

### 队列的应用

> - 求解报数问题
> - 求解迷宫问题
> - 层次遍历
> - 计算机系统的应用
> - 缓冲区
> - 页面替换算法

### 栈与队列的区别

|              | 栈                        | 队列              |
| ------------ | ------------------------- | ----------------- |
| 主要区别     | 仅关心top，完全不用管栈底 | 即有rear也有front |
| **入操作先** | **指针**                  | **rear动**        |
| **出操作先** | **先数据**                | **front动**       |

## 串

### 串的基本概念

字符串是一种**特殊的线性表，其数据元素都为字符**

- **空串：长度为0**的字符串，**没有任何字符**。
- **空格串：由一个或多个空格组成的串，空格是空白字符，占一个字符长度**。**子串（模式串）：串中任意长度的连续字符构成的序列称为子串**。含有子串的串称为主串，空串是任意串的子串
- **串的模式匹配：子串的定位操作，用于查找子串在主串中第一次出现的位置的算法。**
- **串相等**：指两个串长度相等且对应位置上的字符也相同
- **串比较**：两个串比较大小时以字符的ASCI码值作为依据。比较操作从两个串的第

     串的基本操作如下：
    ①赋值操作StrAssignst）：将串t的值赋给串S
    ②连接操作Concatst：将串t接续在串s的尾部，形成一个新串。
    ③求串长StrLength（s）：返回串s的长度。
    ④串比较SuCompare(s,t）：比较两个串的大小。返回值-1、0和1分别表示s<t、st和s>t三种情况。
    求子串SubString（s.start.len）：返回串s中从start开始的、长度为len的字符序列

### 串的存储结构

- 字符串可以采用顺序存储和链式存储方式    

  （1）**顺序存储。该方式是用一组地址连续的存储单元来存储串值的字符序列**。由于串中的元素为字符，所以可通过程序语言提供的字符数组定义串的存储空间（即存储空间的容量固定），也可以根据串长的需要动态申请字符串的空间（即存储空间的容量可扩充或缩减）

  （2）**链式存储**。字符串也可以采用链表作为存储结构，当用链表存储串中的字符时，**每个结点中可以存储一个字符，也可以存储多个字符，需要考虑存储密度问题**。结点大小为4的块链如图3-9所示。

  ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243613.png)

### 模式匹配算法

**朴素的模式匹配算法：也称为布鲁特一福斯算法，其基本思想是从主串的第1个字符起与模式串的第1个字符比较，若相等，则继续逐个字符进行后续的比较；否则从主串中的第2个字符起与模式串的第1个字符重新比较**，直至模式串中每个字符依次和主串中的一个连续的字符序列相等时为止，此时称为匹配成功否则称为匹配失败

- 基本模式匹配算法

  ```c
  int Index(char Slchar Tint pos）{
  /*查找并返回模式串T在主串S中从pOs开始的位置（下标），若不是S的子串，则返回-1*i=pos；j=0；/*  i，j分别用于指示出主串字符和模式串字符的位置（下标），若T不是s的子串，则返回—1*/
      i=pos;j=0;   /*i，j分别用于指示出主串字符和模式串字符的位置（下标）*/
  	slen=strlen(s);tlen=strlen(r)；/*计算主串和模式串的长度*/
      while（i<slen&&j<tlen）{
          if(s[i]==T[j]){
             i++;
             j++;
          }
         else{
             i=i-j+1;       /*主串字符的位置指针回退*/          	 j=-;       /*模式串重新从起始字符开始*/
       }
      if(j>=tlen)
       	return i-tlen；
      return -1;
  }

> 最好O（n+m）
>
> 最坏O（n*m）

- **改进的模式匹配算法**
       **改进的模式匹配算法又称为KMP算法**（由D.E.Knuth、VR.Pratt和J.H.Morris提出），其改进之处在于：**每当匹配过程中出现相比较的字符不相等时，不需要回主串字符的位置指针而是利用已经得到的“部分匹配”的结果，将模式串向后“滑动”尽可能远的距离，再继续进行比较。此算法可在O（n+m）的时间内完成**

## 数组矩阵

### 数组

- 数组是**定长线性表在维度上的扩展，即线性表中的元素又是一个线性表**。N维数组是一种“同构”的数据结构，其**每个数据元素类型相同、结构一致。**
- 其可以表示为行向量形式或者列向量形式线性表，单个关系最多只有一个前驱和一个后继，本质还是线性的
- **数组结构的特点：数据元素数目固定；数据元素类型相同；数据元素的下标关系具有上下界的约束且下标有序**
- 数组数据元素固定，一般不做插入和删除运算，适合于采用**顺序结构**





- 数组存储地址的计算，特别是二维数组，要注意理解，假设每个**数组元素占用存储长度为len**，起始地址为a，存储地址计算如下**（默认从0开始编号）**：

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243614.png)

### 矩阵

稀疏矩阵：在一个矩阵中，若非零元素的个数远远少于零元素个数，且非零元素的分布没有规律。

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243615.png)

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243616.png)

## 树与二叉树

### 树和森林

#### 树的性质（重点）

1. **树总结点树=度之和+1=分支节点总和+1**

   > **度之和=分支结点度数=0\*n0+1\*n1+2\*n2...**

2. **第i层最多有m^(i-1)个结点**

3. **高度为h的m次树的总结点最多为(m^h-1)/(m-1)**

   > **一定要记得高度h的总结点个数还有除数的**

4. **具有n个结点的m次树的最小高度为logm(n*(m-1)+1)  （上取整）**

#### 树的遍历

1. 先根遍历

   > =森林的先根遍历=二叉树的先序遍历
   >
   > 这里的意思是先转换成对应的树|二叉树在进行遍历的序列相同

2. 后根遍历

   > =森林的后根遍历=**二叉树的中序遍历**

3. 层次遍历

   > =图的广度优先遍历

#### 树的存储结构

1. 双亲存储

   ```c
   typedef struct{
   	elemtype data;  //结点的值
   	int parent;  //双亲的位置
   }ptree[Maxsize];  //为双亲存储结构类型
   ```

2. 孩子链存储

   ```c
   typedef struct node{
   	elemtype data;
   	struct node *sons[Maxsons];  //指向孩子结点，表示每个结点最多的度数
   }TSonNode;
   ```

   > **空域：指针个数-分支个数=n*m-(n-1)**

   - 设计一个求树t高度的递归算法：

     ```c
     int treeheight(TSonNode * t){
     	TSonNode *p;
     	int i,h,maxh=0;
     	if(t==NULL)
     		return 0;
     	for(i=0;i<Maxsons;i++){    //p指向t的第i+1个孩子结点
     		p=t->sons[i];
     		if(p!=NULL){
     			h=treeheight(p);  //求对应子树的高度
     			if(maxh<h)
     				maxh=h;
     		}
     	}
     	return (maxh+1);  //返回树的高度
     }
     ```

3. 兄弟链存储

   ```c
   typedef struct tnode{
   	elemtype data;
   	struct tnode *hp;  //指向兄弟
   	struct tnode *vp;  //指向孩子结点
   }TsbNode;
   ```

   > 最重要，用于实现树与二叉树的互相转换
   >
   > **左孩子右兄弟**
   >
   > **空域：指针个数-分支个数=2n-(n-1)=n+1**
   >
   > 👆因为一个节点就两个指针，相当于孩子链中m次树为2的情况

   - 设计一个求树t高度的递归算法：

     ```c
     int treeheight2(TsbNode *t){
     	TsbNode *p;
     	int h,maxh=0;
     	if(t==NULL)
     		return 0;
     	p=t->vp;   //p指向第1个孩子结点
     	while(p!=NULL){
     		h=treeheight2(p);
     		if(maxh<h)
     			maxh=h;
     		p=p->hp;  //继续处理其他兄弟，即其他子树
     	}
     	return(maxh+1);
     }
     ```

### 二叉树

#### （完全）二叉树的性质

> 叶子结点仅有可能在最后两层出现

1. **n0=n2+1**
2. **n2=n0-1**
3. **n=2n2+1=2n0-1**
4. **.i层最多有2^(i-1)个结点**
5. **深度为k的⼆叉树⾄多有2^k - 1个结点**
6. **具有n个结点的完全⼆叉树的深度为log2(n)向下取整+1**
7. **n为奇数时，n1=0；n为偶数时，n1=1（因为n0+n2为奇数）**
8. 如果对⼀棵有n个结点的完全⼆叉树，可以通过⽗节点求⼦⼥结点，也可以通过⼦⼥结点 求⽗节点，不过**要注意，根节点的编号是从0开始还是从1开始**。下面计层序编号为i
   - **若i<=n/2，则i为分支结点，否则是叶子结点**
   - **若i有左孩子，则左孩子编号是2i，右孩子为2i+1**

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243617.png)

#### 二叉树遍历

1. **先序（前缀表达式）**

   > 第一个是根节点。若有左右子树，则第二个是左子树根节点，第三个是右子树根节点

   - 递归算法：

     ```c
     void preOrder(btNode *b){
     	if(b!=NULL){
     		printf("%c",b->data);  //访问结点
     		preOrder(b->lchild);  //递归左子树
     		preOrder(b->rchild);  //递归右子树
     	}
     }
     ```

2. **中序（中缀表达式（要加括号））**

   > 若有左右子树，则根节点在中间，左右子树在两边

   递归算法：

   ```c
   void inOrder(btNode *b){
   	if(b!=NULL){
   		inOrder(b->lchild);  //递归左子树
   		printf("%c",b->data);  //访问结点
   		inOrder(b->rchild);  //递归右子树
   	}
   }
   ```

3. **后序（后缀表达式）**

   > 最后一个是根结点

   递归算法：

   ```c
   void postOrder(btNode *b){
   	if(b!=NULL){	
   		postOrder(b->lchild);  //递归左子树
   		postOrder(b->rchild);  //递归右子树
   		printf("%c",b->data);  //访问结点
   	}
   }
   ```

4. 层次遍历

   > 非递归
   >
   > 借助环形队列



> 先序中序后序非递归遍历需要用到临时栈

#### 二叉树和树和森林的转换

> 只用知道以下四种情况，树和森林间的转换就是增加一个根或删去一个根

1. **二叉树转树**

   > 孩子左兄弟右：孩子在左边，兄弟在右边

   ![](%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/20250412114815619.png)

   > 规则：
   >
   > 1. 二叉树的左孩子是树中该结点（该左孩子的双亲）的最左孩子（第一个孩子）
   > 2. 二叉树的右孩子是树中该结点（该右孩子的双亲）的一个兄弟
   >
   > 要求：**根节点必须无右孩子，否则就是转成森林了**
   >
   > 方法：
   >
   > 1. 将所有有右孩子的线左转45°
   > 2. 去掉兄弟之间的线，并连上各自的双亲

2. **二叉树转森林**

   > 孩子左兄弟右，并且**根兄弟要切断**

   ![](%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/20250412114844283.png)

   > 规则：
   >
   > 1. 二叉树的左孩子是树中该结点（该左孩子的双亲）的最左孩子（第一个孩子）
   > 2. 二叉树的右孩子是树中该结点（该右孩子的双亲）的一个兄弟
   >
   > 要求：**根节点一定要有右子树，否则就是树了**
   >
   > 方法：
   >
   > 1. 将所有有右孩子的线左转45°
   > 2. 去掉兄弟之间的线，并连上各自的双亲

3. **树转二叉树**

   > 第一棵子树（如果有的话）作为左孩子，下一个兄弟（如果有的话）作为右孩子
   >
   > **第一棵子树作为左孩子，下一个兄弟作为右孩子**

   ![](%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/20250412114900798.png)

   > 方法：
   >
   > 1. 兄弟结点之间连接条虚线，并把所有的非最左结点（右结点）的线删去
   > 2. 将兄弟的线右转45°

4. **森林转二叉树**

   ![](%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/20250412114908337.png)

   >方法：
   >
   >1. 兄弟结点**（根节点）之间连接条虚线**，并把所有的非最左结点（右结点）的线删去
   >2. 将兄弟的线右转45°

#### 二叉树的存储结构

1. 顺序存储

   ```c
   typedef char elemtype;
   //课本上二叉树的顺序存储定义如下
   typedef elemtype sqBinTree[Maxsize];
   ---------------------------------------------
   //王道上二叉树的顺序存储定义如下
   struct TreeNode{
   	elemtype value;
   	bool isempty;  //结点是否为空
   };
   TreeNode t[Maxsize];  //定义一个长度为Maxsize的数组t，按照从上至下、从左至右的顺序依次存储完全二叉树中的各个结点
   ```

   ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243619.png)

2. 二叉链表

   ```c
   typedef char elemtype;
   //二叉链表存储定义及各操作的实现
   typedef struct node{
   	elemtype data;
   	struct node *lchild;
   	struct node *rchild;
   }btNode;
   ```

   > **n+1个空域**

3. 三叉链表

   ```c
   typedef char elemtype;
   //二叉链表存储定义及各操作的实现
   typedef struct node{
   	elemtype data;
   	struct node *lchild;
   	struct node *rchild;
       struct node *parent;
   }btNode;
   ```

   > **3n-2(n-1)=n+2个空域**

#### 二叉树的构造

1. **先序遍历序列+中序遍历序列画出二叉树**

   用先序第一个确认根的位置，在中序中找到根，左边是左子树，右边是右子树，继续递归确认

2. **后序遍历序列+中序遍历序列画出二叉树**

   用后序最后一个确认根的位置，在中序中找到根，左边是左子树，右边是右子树，继续递归确认

3. **层次遍历序列+中序遍历序列画出二叉树**

   用层次第一个确认根的位置，在中序中找到根，左边是左子树，右边是右子树，继续递归确认

### 线索二叉树

> 充分利用二叉链表的空域：
>
> - 左空则指向其前驱
> - 右空则指向其后继

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243620.png)

### 二叉排序树

- 考点：会给一串数列，你需要依次按顺序插入进去，组成二叉排序树

> 详细见树表查找篇章
>
> 方便搜索的一种树
>
> 左子树放小的，右子树放大的



![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243621.png)

### 平衡二叉树

> 要求左右子树的高度差最多是1

### 堆

大根堆或小根堆

![](%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/20250412115142590.png)

> 堆是一颗完全二叉树，采用数组顺序存储，有大小堆之分
>
> 堆又叫优先级队列
>
> 优先级队列是完全⼆叉树 + 堆的规则（⼤⼩根堆）

### 哈夫曼树

- 构造（重点）：

  1. **每次拿最小的两个结点合并成一个新结点（最多合并n-1次）**

  2. **再循环拿两个最小的结点（选过的不能再选），第一步构造的新结点也可以选中**

     > 因此需要结合n-1次

- **带权路径计算（重点）：**

  1. **找出所有叶子结点**
  2. **计算各个叶子结点的路径长度\*叶子结点的权值**
  3. **将2式相加，有几个叶子结点就有几项**

> **哈夫曼树共有2n0-1=2n2+1个结点，且没有度为1的结点**
>
> 分支结点n-1=2n0-2
>
> huffman树是带权路径**WPL（Weighed Path Length**）最⼩的树，也称最优树。当哈夫曼树的度大于2时，就运用到了外存中的排序，叫最佳归并树

- 哈夫曼编码（前缀编码）

  > huffman树的**左树编码为0，右树编码为1（左小右大）**，则每⼀个叶⼦结点将得到唯⼀的编码，即为 huffman编码，也叫做前缀编码
  >
  > 所谓前缀编码就是指，任何一个编码都不是另一个编码的前缀
  >
  > **哈夫曼树的字符个数=叶子结点个数**
  >
  > **哈夫曼树的字符长度+1=哈夫曼树的最大高度**
  >
  > **注意区分字符长度和字符个数！注意区分字符长度和字符个数！注意区分字符长度和字符个数！**

- 哈夫曼树的应用就是压缩存储空间

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243622.png)

### 并查集

> 对两个集合的合并、查找操作
>
> 并查集采用双亲存储实现

## 图

### 图的基本概念



![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243623.png)

图（Graph）G由顶点集合V(G)和边集合E(G)构成。   

> **图不可以为空，至少要有一个顶点**，顶点集非空，**只有边是可以空的**

- 图的表示

  - 无向图：

    e={(1,2),(1,3),(1,0),(2,3),(3,0),(2,4)}

  - 有向图：

    e={<1,2>,<1,3>,<0,1>,<2,3>,<0,3>}

  > 无向图用()表示，可以颠倒顺序。无向图边成为边
  >
  > 有向图用<>表示，从左指向右，表示左边的出边是右边，不可颠倒。有向图边成为弧
  >
  > 有向图中所有顶点的入度之和等于所有顶点的出度之和。

- **边与度的关系**

  **边数e=n个顶点的度之和 / 2**

  > 即：n个顶点的度之和为边数的两倍

- **完全图（顶点n与边e的关系）**

  > 完全图指的是所有的顶点均和其他顶点有边（不仅仅是连通而已，是直接边）。有向图则要同时存在方向相反的两条弧

  - **无向完全图**中，每两个顶点之间都存在着一条边，**此时边数最多**，称为完全无向图， 最多有***e=n*(*n*-1)/2条边**。

  - **有向完全图**中，每两个顶点之间都存在着方向相反的两条边，**此时边数最多**，称为完全有向图，最多有***e=n*(*n*-1)条边。**

- 稠密图与稀疏图

  - 稠密图：接近完全图，边多
  - 稀疏图：边少

- 子图

  子图要求选取的顶点子集与边子集在父图中能连得通

- 连通

  - 无向图：顶点i到顶点j有路径，叫做**连通图**

    > 对于无向图，边的**取值范围为0到n(n-1)/2**, 如果图有n(n-1)/2条边，则⽆向称为图称⽆向完全 图，

  - 有向图：顶点i到顶点j有去和来两条路径，叫**强连通图**

    > 对于有向图，边的**取值范围为0到n(n-1)**, 如果图有n(n-1)条边，则称向图称为有向完全图，在 有向完全图中任意两个顶点之间都存在⽅向相反的两条弧
    >
    > ⼀个顶点的⼊度为0、其余顶点的⼊度均为1的有向图，称为有向树

  - 不连通：在（极大）连通分量上多＋一个顶点

- **连通图、连通分量（无向）**

  > 若无向图中任意两个顶点都连通（不一定有直接边），则称为连通图，否则称为非连通图
  >
  > > 因此连通图与无向完全图的关系是：连通图真包含于无向完全图
  >
  > 无向图G中的**极大连通子图**称为G的**连通分量**。显然，任何连通图的连通分量只有一个，即本身，而非连通图有多个连通分量。
  >
  > 如果只有一个顶点（没有边），那么此时该顶点也叫做连通分量
  >
  > **一个有n个顶点的图，最少有1个连通分量,最多又n个连通分量**

  - 实现**n个顶点的无向连通图至少n-1条边**

    > 无向连通图的最少边数，就是**生成树**
    >
    > 若再＋一条边，形成n个顶点n条边，则一定有环
    >
    > 那么显然：
    >
    > - 生成树，n-1条边
    > - 非连通图：<n-1条边

  - 只有非连通图才有可能有多个连通分量

  - **e条边的非连通图的顶点最少=连通图的顶点+1 即：边数e*=n*(n-1) /2    **

    > **求出e条边所构成的完全图n后＋1**

    > 非连通图的边数最少是n-1，并且有n+1个顶点（自推）

- **强连通图、强连通分量（有向图）**

  > 若有向图中任意两个顶点都连通（不一定有直接弧），则称为**强连通图**，否则称为非强连通图。
  >
  > > 因此强连通图与有向完全图的关系是：强连通图真包含于有向完全图
  >
  > 有向图G中的**极大强连通子图**称为G的**强连通分量**。
  >
  > 强连通图只有一个强连通分量，即本身。非强连通图有多个强连通分量。

  - 实现有**向连通图至少n条边**

  - **n个顶点的强连通图（有向图）至少有n条边**

    > 上述两都是形成了环，这样就连通了

### 图的存储结构及基本算法

#### 邻接矩阵

> **顺序存储**

- 概念

> **对角线都是0**
>
> **关于对角线对称，因此顶点为n阶矩阵的n，边为主对角线以上的1的个数**
>
> 需要会根据图画出邻接矩阵
>
> 连通的话是权值（若是不带权的图，则**默认是1**）
>
> 无穷表示不连通

<img src="https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/%E8%BD%AF%E8%80%83-assets/20250412115528838.png" alt="01" style="zoom:67%;" />



> 一个图的邻接矩阵表示是唯一的。
>
> 特别适合于稠密图的存储。
>
> **邻接矩阵的存储空间为O(*n\*2)**
>
> **邻接矩阵遍历的时间复杂度也是O(*n\*2)**

- **矩阵的地址求法**

  > 源自邻接矩阵是顺序存储形式，所以是以a[n]\[m]的方式表示的

  ​	矩阵中是**按行（列）优先的顺序存储的**。也就是说，二维数组的第一行的所有元素会先于第二行的所有元素被存储，第二行的所有元素会先于第三行的所有元素被存储，以此类推。

  ​	**给定一个 m x n 的二维数组 a，其首元素（即 a[0]\[0]）的基地址是 BASE，那么元素 a[i][j] 的地址可以通过以下公式计算：**

  ```c
  Address of a[i][j] = BASE + ((i * n) + j) * size
  ```

  > - i * n : 这是前 i 行元素的总数量。
  > - j : 是第 i 行中，a[i][j] 前面的元素数量。
  > - (i * n) + j : 这是 a[i][j] 元素在二维数组中的位置（从 0 开始计数）。
  > - ((i * n) + j) * size ：由于每个元素可能会占用多于一个字节的空间（如 int 类型通常会占用4个字节），我们需要将元素在数组中的位置乘以它所占用的空间大小，来得到相对于 BASE 的偏移量。

#### 邻接表

- 概念

  ![](%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/20250411111243624.png)

> 采用的是**顺序存储＋链式存**储的方式实现
>
> 用一个数组作为头结点表示每个顶点，然后每个数组内部都有个指针，指向连接的结点
>
> 边界点算的是出度
>
> **需要会根据图画出邻接表，不关于主对角线对称，顶点为n阶矩阵的n，边数为邻接表中1的个数**

> 邻接表表示不唯一。
>
> 特别适合于稀疏图存储。   
>
> **邻接表的存储空间为O(*n*+*e*)**
>
> **邻接表的时间复杂度也是O(*n*+*e*)** 

### 图的遍历

> 注意区分树的层次遍历、先根遍历、后根遍历
>
> 二叉树的先中后序遍历

#### 深度优先遍历DFS

> **优先遍历从某个结点出发的有最深层次的结点，层次必须递增，若到底则回到第二层的其他结点继续深度遍历**
>
> 深度优先遍历相当于⼆叉树中的**前序遍历**
>
> **邻接表求遍历序列：看到一条可以走（没有走过)路径就直接走下去，没有道路时回退 **

##### 算法

```c
void DFS(AdjGraph *G，int v)  //邻接表实现，实现主要都是用邻接表
{  ArcNode *p; int w;
   visited[v]=1; 		//置已访问标记
   printf("%d  "，v); 		//输出被访问顶点的编号
   p=G->adjlist[v].firstarc; 	//p指向顶点v的第一条边的边头结点
   while (p!=NULL) 
   {  w=p->adjvex;
      if (visited[w]==0) 
         DFS(G，w);   		//若w顶点未访问，递归访问它
      p=p->nextarc; 　		//p指向顶点v的下一条边的边头结点
   }
}
```

> 深度优先遍历的过程体现出后进先出的特点：用**栈或递归**方式实现。
>
> 如何确定一个顶点是否访问过? 设置一个visited[] 全局数组， visited[*i*]=0表示顶点*i*没有访问； visited[*i*]=1表示顶点*i*已经访问过。
>
> 该算法的**对领接表，该时间复杂度为O(*n*+*e*)。**
>
> **对领接矩阵，该时间复杂度为O(*n*\**e*)。**

##### 遍历次序（重要）

要点：

- **若有多条路，先选权值小的那条路**

- **掌握由一个图写出深度优先遍历序列**

  如下图，若从2出发，下一步可以选1或者6，但要先去小的，所以先去1；然后以1为出发点可以去2（去过）或者5，访问5，5没有可以访问的了；然后回到2，这次从6开始，去3，然后3又可以去4，再去7，8，遍历完成。

- **掌握由一个邻接表写出深度优先遍历序列（重点）**

  **邻接表**写出深度优先遍历序列的要点克鲁斯卡尔（Kruskal)在于**要看邻接表里的**，因为邻接表里多条路，**并不一定是选权值最小的**

  如下图，若从2出发，下一步选1，然后跳到1的那一行，2被访问了，那就去5；跳5那一行，没东西了，返回2那一行；访问下一个6，6的行可以选3（没被选中过）...以此类推，**被选过的就要跳过去**

  > 秘诀：**访问一个，就到它的行去接着访问别的，若没有，则一步步向上返回**

![38](%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/20250412115647025.png)

#### 广度优先遍历BFS

##### 算法

> 类似于层次遍历，距离起始结点近的先访问完，再访问离更远的
>
> **要会从邻接表的图来写出遍历序列**
>
> **邻接表求遍历序列：考虑每一条可以走（没有走过)的路径，尝试走每条道路**

```c
void BFS(AdjGraph *G，int v)
{  int w， i;
   ArcNode *p;
   SqQueue *qu;			//定义环形队列指针
   InitQueue(qu);			//初始化队列
   int visited[MAXV];        		//定义顶点访问标记数组
   for (i=0;i<G->n;i++) 
     visited[i]=0;	  		//访问标记数组初始化
   printf("%2d"，v); 			//输出被访问顶点的编号
   visited[v]=1;             		//置已访问标记
   enQueue(qu，v);
   while (!QueueEmpty(qu))       		//队不空循环
   {  deQueue(qu，w);				//出队一个顶点w
      p=G->adjlist[w].firstarc; 		//指向w的第一个邻接点
      while (p!=NULL)				//查找w的所有邻接点
      {  if (visited[p->adjvex]==0)		//若当前邻接点未被访问    
         {  printf("%2d"，p->adjvex);		//访问该邻接点
            visited[p->adjvex]=1;		//置已访问标记
            enQueue(qu，p->adjvex);		//该顶点进队
         }
         p=p->nextarc;              		//找下一个邻接点
      }
    }
    printf("\n");
}
```

> 广度优先搜索遍历体现先进先出的特点，用**队列**实现。
>
> 对于连通图，调用一次DFS或BFS，能够访问到图中的所有顶点
>
> 无向非连通图：调用一次DFS或BFS，只能访问到初始点所在连通分量中的所有顶点，不可能访问到其他连通分量中的顶点。
>
> **所以非连通图，需要调用连通分量个数次的DFS或BFS才能遍历所有结点**
>
> **对领接表，该时间复杂度为O(*n*+*e*)。**
>
> **对领接矩阵，该时间复杂度为O(*n*\**e*)。**

##### 遍历次序（重要）

要点：

- **若有多条路，先选权值小的那条路**

- **掌握由一个图写出广度优先遍历序列**

  如下图，若从2出发，下一步可以选1或者6，但要先去小的，所以先去1，再去6；然后以1或6为出发点可以去3、5或者7，访问5（因为上一级1比较小），然后3、7；然后以5、3、7为起点访问其他的，遍历完成。

- **掌握由一个邻接表写出广度优先遍历序列（重点）**

  **邻接表**写出深度优先遍历序列的要点在于**要看邻接表里的**，因为邻接表里多条路，**并不一定是选权值最小的**

  如下图，若从2出发，下一步将该层全访问完1、6，然后跳到1的那一行，访问改行，2被访问了，那就去5，第二行的1访问完毕；之后回到2行，访问6，还是一样，跳过去，访问一行先，然后再往里深入...以此类推，**被选过的就要跳过去**

![39](%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/20250412115739005.png)

> 秘诀：先把一层的都访问遍，再挨个往里钻

### 最小生成树

> 从4-8都属于图的应用
>
> 可以先数一下有多少个顶点，因此边数为定点数-1

#### 生成树概念

一个连通图的生成树是一个**极小连通子图**，它含有图中全部n个顶点和构成一棵树的**(n-1)**条边。　

**生成树是图用某种遍历方式所形成的，所以每个结点只会被访问一次，不能重复走，但必须每个结点都走完**

> 可以看出生产树的概念是针对无向图而言的，而无向图中连通的最低要求就是要有n-1条边，所以说生成树是极小连通子图
>
> 注意：连通分量是极大联通子图，一个极大一个极小，注意区分　
>
> 由广度优先遍历得到的生成树称为广度优先生成树。
>
> 由深度优先遍历得到的生成树称为深度优先生成树。
>
> **生成树是可以没有权值的，极小生成树必须要有权值**
>
> 边数=顶点数-1
>
> 树形不唯一，边和权值之和唯一

- 最小生成树（MST）：边上的权值之和最小的生成树

#### 普里姆（Prim）算法

> **选择最近的点，后连接边**
>
> **要求：不能形成回路**（本质：不能重复访问结点）
>
> 找挨着最近的点连起来，并将连起来的点加入集合中，之后按照集合里周围单位1 的范围进行查找

- 步骤：

  （1）初始化U={v}。v到其他顶点的所有边为候选边；

  （2）重复以下步骤n-1次，使得其他n-1个顶点被加入到U中：

   ①从候选边中挑选权值最小的边输出，设该边在V-U中的顶点是k，将k加入U中；

   ②考察当前V-U中的所有顶点j，修改候选边：若(j，k)的权值小于原来和顶点k关联的候选边，则用(k，j)取代后者作为候选边。

![](%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/20250412115759645.png)

> Prim()算法中有两重for循环，所以时间复杂度为O(n2)。 

#### 克鲁斯卡尔（Kruskal)

> **选择最小的边，后画点**
>
> **要求：不能回路**
>
> 找边最小的一条，然后将两个点连起来，如果这两点已经连通了，则不要这条边，去找另外小的一条

- 步骤：

  （1）置U的初值等于V（即包含有G中的全部顶点），TE的初值为空集（即图T中每一个顶点都构成一个连通分量）。

  （2）将图G中的边按权值从小到大的顺序依次选取：

     若选取的边未使生成树T形成回路，则加入TE；

     否则舍弃，直到TE中包含(n-1)条边为止。

  ![](%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/20250412115817496.png)

  > Kruskal算法的时间复杂度为O(elog2e)
  >
  > **改进：堆排序、并查集**

  

### 最短路径

##### 迪杰斯特拉（Dijkstra）求单源最短路径

> 类似线代里的矩阵求最短路径

![34](%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/20250412115842364.png)

#### 弗洛伊德（Floyd）求各顶点之间最短路径问题

![35](%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/20250412115913811.png)

### 有向无环图描述表达式（节省空间）

![36](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243607.png)

### 拓扑排序

- 1.有向无环图（DAG图）
- 2.顶点表示活动的网络（AOV）网
- 3.拓扑排序（DAG图中）

![img](%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/20250412120007807.png)

### 关键路径

#### 概念

- 1.开始顶点（源点）：仅有一个入度为0的顶点
- 2.结束顶点（汇点）：仅有一个出度为0的顶点
- 3.关键路径：具有最大路径长度的路径
- 4.关键活动：关键路径上的活动
- 5.最短时间：关键路径的长度

#### 几个变量

- **1.事件vn的最早发生时间Ve（n）**

  **通过从源点开始，找出每条到达汇点的每条路径，最后取最大值max**

- **2.事件Vn的最迟发生事件Vl（n）**

  **通过汇点逆向回去源点，最后取出最小值min**

- **3.活动Ai的最早发生时间e（i）**

  **=Ve（n）**

- 4.活动Ai的最迟发生时间l（i）

  l=Vl-权值c

- 5.c路径长

  Ai的权长

- 6.活动的差额d（i）

  d=l-Ve

#### 关键路径计算

> - **d=0  ==  Vl-c-Ve=0  ==  逆序-权长-正序=0**

## 查找

![](%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/20250412124605656.png)

#### 概念

##### 平均查找长度ASL（重点）

\- Age Search Length，这是衡量查找 算法效率的重要指标

![](%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/20250412124616632.png)

> n是表的⻓度，pi是查找第i个数据元素的概率，如果概率相等，则pi=1/n, ci是找到第i个数据 元素所需⽐较的次数。
>
> asl越小，效率越高

#### 线性表查找

##### 顺序查找

> 从头到尾或从尾到头

![](%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/20250412124643197.png)

##### 折半（二分）查找

- 顺序表描述

> 要求是有序表，最好是顺序表，但也可以是链式

```c
//二分查找（升序）
int binSearch(rectype r[],int n ,keytype k){
	int low=0,high=n-1,mid;
	while(low<=high){
		mid=(low+high)/2;  //相当于向下取整
		if(k==r[mid].key)
			return mid+1;  //逻辑序号序号加1
		if (k<r[mid].key)
			high=mid-1;
		else
			low=mid+1;
	}
	return 0;  //如果while没有ruturn则没找到，返回0
}
```

- 二叉树描述折半查找

  此时叫**判定树或比较树**，显然，判定树是一颗平衡二叉排序树（AVL）

  > 平衡二叉树证明：当元素个数为偶数时，mid可以选择上取整和下取整。选上取整则右子树始终比左子树多1或0个；选下取整则左子树始终比右子树多1或0个，因此构成了平衡二叉树
  >
  > **失败结点个数为元素个数+1，因为n个结点相当于分成了n+1个区间，用数学的直线划分区间来理解**
  >
  > **需要会手动画出判定树、比较树**
  >
  > 如下图：
  >
  > ![41](%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/20250412124730934.png)

- 判定树，比较树

![](%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/20250412124739854.png)

> 新增的叶子结点叫做外部结点，用于计算**失败的平均查找长度**，计算方式：**（（到达外部结点经过的边数）*该层个数）累计求和/外部结点个数**
>
> 判定树里存在的结点叫做内部结点，用于计算**成功的平均查找长度，计算方式**：**（第i层*第i层的内部结点个数）累计求和/内部结点个数**
>
> **折半查找的最大查找次数=判定树的最大高度=log2n（下取整）+1 | log2（n+1）（上取整）**
>
> 折半查找的时间复杂度 为：**O(log2n)**

![](%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/20250412124805669.png)

##### 分块（索引）查找

- 概念

  1. **分块查找又称索引顺序查找**，它吸取了顺序查找和折半查找各自的优点，既有动态结构，又 适于快速查找。 

  2. 分块查找的基本思想：将查找表分为若干子块。**块内的元素可以无序，但块间的元素是有序** 的，即第一个块中的最大关键字小于第二个块中的所有记录的关键字，第二个块中的最大关键字 小于第三个块中的所有记录的关键字，以此类推。再建立一个索引表，索引表中的每个元素含有 各块的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排列。 **即将n个数据的表分成b块，每一块再分成s列**

  3. 分块查找的过程分为两步：**第一步**是在索引表中确定待查记录所在的块，可以顺序查找或折半查找索引表；**第二步**是在块内顺序查找（只能）。

     ![](%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/20250412124830229.png)

     > **因此索引查找最好的情况都需要查找两次**

- 平均查找长度

  **顺序查找**

  ![](%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/20250412124842181.png)

  > **但s=根号n时，ASL取极小值根号n+1**
  >
  > 例题：对于10000个元素的文件，用分块查找，最佳的元素个数s是100个，总的块数b=100，ASL=101

  > **分块查找的缺点就是增加一个索引表的存储空间和增加建立的时间**
  >
  > 如果分块查找采用链式存储，则可以实现动态搜索表

#### 树表查找

##### 二叉排序树BST

- 据二叉排序树的定义，**左子树结点值 < 根结点值 < 右子树结**

> **对⼆叉树进⾏中序遍历，将得到从小到大的排序顺序**
>
> ⼆叉搜索树最⼤的功劳在于：规定了节点的位置，因此针对BST可以有效实现查找、插 ⼊、删除，**让树形结构可以进⾏动态调整**
>
> **具有n个内部结点的二叉排序树，其外部结点个数为n+1**
>
> 平均执行时间或者ASL=**O（log2（n））**
>
> 二叉排序树中的查找路径是原来二叉排序树的一部分，也一定构成一棵二叉排序树。

- n个关键字构成的不同二叉排序树有多少棵？

  答：需要用到卡特兰数，就是出栈序列个数那个：C(n，2n)/(n+1)

  如4个关键字，则有14棵树

- 算法

  1. 类型定义

     ```c
     typedef int keytype;
     typedef char infotype;
     typedef struct node{
     	keytype key;
     	infotype data;
     	struct node *lchild,*rchild;
     }bstNode;
     ```

  2. 插入

     ​	需保证插入后，仍然满足排序树需求。用到了递归，当子树为空时就会插入，如果在左边就递归左边插入，在右边就递归右边插入

     ```c
     bool insertBst(bstNode *&bt,keytype k){
     	if(!bt){
     		bt=(bstNode *)malloc(sizeof(bstNode));
     		bt->key=k;
     		bt->lchild=bt->rchild=NULL;
     	}
     	else if(k==bt->key)  //不能存在关键字相同的结点
     		return false;
     	else if(k<bt->key)
     		return insertBst(bt->lchild,k);
     	else
     		return insertBst(bt->rchild,k);
     }
     ```

  3. 创建

     ```c
     bstNode * createBst(keytype a[],int n){
     	//返回树的根节点
     	bstNode *bt=NULL;
     	int i=0;
     	while(i<n){
     		insertBst(bt,a[i]);
     		i++;
     	}
     	return bt;
     }
     ```

  4. 删除

     算法思想

     1. 考虑p是叶子：**直接删**
     2. 考虑p只有左子树：**左子树代替**
     3. 考虑p只有右子树：**右子树代替**
     4. 考虑p同时有左右子树：**拿左子树最大或者右子树最小的**

  5. 输出

     ```c
     //递归输出排序树（中序）
     void dispBst(bstNode *bt){
     	if(bt){
     		dispBst(bt->lchild);
     		printf("%d,",bt->key);
     		dispBst(bt->rchild);
     	}
     }
     ```

##### 平衡二叉树AVL

定义结点**左子树与右子树的高度差为该结点的平衡因子**，则平衡 二叉树结点的**平衡因子**的值只可能是**-1、1或0**

- **AVL插入结点**

> 插入结点可能导致平衡二叉树不平衡，因此每次调整的对象都是最小不平衡子树，即以插入路径上离插入结点最近的平衡因 子的绝对值大于1的结点作为根的子树

1. LL插入（**右旋**+移右叶到左）

   1. **将最小不平衡子树的左孩子移到根**
   2. **将原本的根移到新根的右孩子**
   3. **将新根原本的右孩子移到原根的左孩子**

   > 在最小不平衡子树的左子树的左分支插入结点，使平衡二叉树不平衡

2. RR插入（**左旋**+移左叶到右）

   1. **将最小不平衡子树的右孩子移到根**
   2. **将原本的根移到新根的左孩子**
   3. **将新根原本的的左孩子移到原根的右孩子替换**

   > 在最小不平衡子树的右子树的右分支插入结点，使平衡二叉树不平衡
   >
   > LL和RR是对称的

   ![22](%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/20250412124924411.png)

3. LR插入(**左旋**+移左叶到右+**右旋**+移右叶到左)

   1. **将最小不平衡子树的左孩子的右孩子移到根**
   2. **将原根的左孩子移到新根的左孩子**
   3. **将原根移到新根的右孩子**
   4. **将新根原本的左孩子移到新根的左孩子的右分支**
   5. **将新根原本的右孩子移到原根的左分支**

   ![23](%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/20250412124942655.png)

   > 在最小不平衡子树的左子树的右分支插入结点，使平衡二叉树不平衡

4. RL插入(**右旋**+移右叶到左+**左旋**+移左叶到右)

   1. **将最小不平衡子树的右孩子的左孩子移到根**
   2. **将原根的右孩子移到新根的右孩子**
   3. **将原根移到新根的左孩子**
   4. **将新根原本的左孩子移到新根的左孩子的右分支**
   5. **将新根原本的右孩子移到新根的右孩子的左分支**

   ![24](%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/20250412125001925.png)

   > 在最小不平衡子树的右子树的左分支插入结点，使平衡二叉树不平衡

   > **以上四种方式记忆：看第二的字母，左就右旋，右就左旋；然后看第一个字母，如果相同则结束，不相同则相反的操作**

#### 散列（哈希）查找 - HashTable

##### 概念

1. 哈希表

   通过哈希函数，直接对关键字进⾏**映射**访问的表就称为哈希表

   散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为**冲突**，这些 发生碰撞的不同关键字称为**同义词**。一方面，设计得好的散列函数应尽量减少这样的冲突；另一 方面，由于这样的冲突总是不可避免的，所以还要设计好处理冲突的方法。

2. hashTable需要解决的两个问题

   1. 映射函数 --- **hash函数** (除留余数法)
   2. **冲突解决** --- （开放地址法、链地址法）

3. 影响哈希表查找的因素：

   1. 装填因子：已存入的元素数n与哈希地址空间大小m的比值，即**a=n/m**；越小，冲突可能性越小
   2. 所采用的哈希函数
   3. 出现哈希冲突时采取的解决办法
   4. 存入的元素特性（如连续的一串、奇数、偶数...）

##### 哈希函数的构造方法

- **1=直接定址法**

以关键字k本身加上某个常量c作为哈希地址：**h(k)=k+c**

如：*h*(学号) = 学号-201001001

> **适用于关键字分布的连续**，否则将造成大量浪费

- **2=除留余数法**

用关键字k除以某个**不大于哈希表长度m的素数p**所得的余数作为哈希地址

**h(k)=k % p  (p<=m)**

> 关键在于选p
>
> p一般用的是最靠近m的素数

##### 哈希冲突的解决办法

- **1=开放定址法（主流）**

1. 线性探测法

   **di=(d0+i) mod m   （i=1,2,3...）**

   **只能往后去找，一次往后一位**，如果到末尾就从头开始

2. 平方探测法

   **di=(d0 +|- i^2) mod m    （1<=i<=m-1）**

   **往前或往后去找，迈的步子越来越大**

> **两种方法总结：就是当前位置有人了，需要每次往后一步（往前往后，步子更大）的去找空位**

- **2=拉链法**

拉链法就是把所有的冲突同义词用单链表连起来，哈希表的地址对应的是单链表的首结点

![33](%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/20250412125312961.png)

##### 除留余数画出哈希表

​	假设哈希表长度*m*=13，采用除留余数法哈希函数建立如下关键字集合的哈希表： 

   (16，74，60，43，54，90，46，31，29，88，77)。 

并采用线性探查法解决冲突。

|     **下标**     | **0**  | **1** | **2**  | **3**  | **4**  | **5**  | **6**  | **7**  | **8**  | **9**  | **10** | **11** | **12** |
| :--------------: | :----: | :---: | ------ | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: |
|      **k**       | **77** |       | **54** | **16** | **43** | **31** | **29** | **46** | **60** | **74** | **88** |        | **90** |
| **成功探查次数** | **2**  |       | **1**  | **1**  | **1**  | **1**  | **4**  | **1**  | **1**  | **1**  | **1**  |        | **1**  |
|   失败探查次数   | **2**  | **1** | **10** | **9**  | **8**  | **7**  | **6**  | **5**  | **4**  | **3**  | **2**  | **1**  | **3**  |

##### 拉链法画出哈希表

- 查找成功asl计算

  ![46](%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/20250412125333040.png)

- 查找失败asl计算

  ![47](%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/20250412125342007.png)

  

## 排序（重点）

> 排序可视化网站：
>
> [Comparison Sorting Visualization (usfca.edu)](https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html)

- 排序的稳定性

  - 相同关键字的元素，排序后，这些相同的关键字的元素位置没有发生改变，就称这种**排序方法是稳定**的。
  - 相同关键字的元素，排序后，这些相同的关键字的元素位置发生了改变，就称这种**排序方法是不稳定**的。

- 内排序和外排序

  外排序会相对较慢

#### 插入排序

> 每次将一个待排序的元素按其关键字大小插入到前面已经排好序的有序区中的适当位置，直至全部插入完成

##### 直接插入排序（增量法）

**思想：左边分为有序区，右边分为无序区，初始化i=1，每次将一个新的元素插入到有序区的合适位置**

```c
//直接插入排序,我的
void insertSort(rectype R[],int n){
	int i=1,temp,k;
	for(;i<n;i++){   //若是0或1个则不执行
		if(R[i-1].key>R[i].key){
			temp=R[i].key;  
			//将前面大于的往后移
			k=i-1;    //升序的前一项
            for(;k>=0;k--){
                if (temp<R[k]);
                	R[k+1]=R[k];
                else
                    break;   //不需要排序
            }
			R[k+1].key=temp;
		}
	}
}
//课本 
void insertSort2(rectype R[],int n){
	int i=1,temp,k;
	for(;i<n;i++){   //若是0或1个则不执行
		if(R[i-1].key>R[i].key){
			temp=R[i].key;  
			//将前面大于的往后移
			k=i-1;    //升序的前一项
			do{
				R[k+1]=R[k];  
				k--;
			}
			while(R[k].key>temp && k>=0);
			R[k+1].key=temp;
		}
	}
}
```

> **时间：O（n^2）**
>
> **空间：O（1）**

##### 折半插入排序

直接插入排序是用顺序比较去找插入的位置，这边是采用折半查找去找插入的位置，再移动元素插入

```c
//折半插入，减少比较次数，但是移动次数还是一样的
void binInsertSort(rectype R[],int n){
	int i,temp,k,low,high,mid;
	for(i=1;i<n;i++){   //若是0或1个则不执行
		if(R[i-1].key>R[i].key){
			temp=R[i].key;  
			//将前面大于的往后移
			low=0;high=i-1;
			while(low<=high){
				mid=(low+high)/2;
				if(temp<R[mid].key)
					high=mid-1;
				else
					low=mid+1;
			}
			for(k=i-1;k>=high+1;k--)  								// high+1==low
				R[k+1]=R[k];
			R[high+1].key=temp;
		}
	}
}
```



> 仅减少了查找位置（比较）次数
>
> 时间：O（n^2）
>
> 空间：O（1）

##### 希尔排序（Shell Sort）

​	实际上是一种**分组插入方法**。

​	思想：**取一个小于n的整合d1作为第一个增量**，把表的全部元素分成d1个组，将所有距离为d1的倍数的元素放在同一个组中，对这一个组进行插入排序；然后取第二个增量d2，继续；直到d=1之后，最所有的元素再进行一次插入排序，算法完毕。

> **思路就是：从局部的一点点有序（看起来）到最后的完全有序**

![40](%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/20250412125411115.png)

```c
//希尔排序（牺牲了0的下标）
void shellSort(rectype R[],int n){
	int d,j,i;
	for(d=n/2;d>=1;d/=2){  //d表示的是两个数据之间的距离
		for(i=d+1;i<=n;i++){  //下标0不放数据，从1开始放，这里i=d+1就类似插入排序中i=1一样，放到第二个数上
			R[0].key=R[i].key;  //不是用的哨兵，0是暂存数据区	
			j=i-d;  //j就是第一个数
			for(;j>0 && R[j].key>R[i].key;j-=d)
				R[j+d].key=R[j].key;
			R[j+d].key=R[0].key;
		}
	}
}
//希尔排序（课本）
void shellSort2(rectype R[],int n){
	int d,j,i,temp;  //用了临时变量，而不用0下标的位置暂存，但这里第一个数据还是放的1位置
	for(d=n/2;d>=1;d/=2){
		for(i=d;i<n;i++){
			temp=R[i].key;  
			j=i-d;
			for(;j>=0 && R[j].key>R[i].key;j-=d)
				R[j+d].key=R[j].key;
			R[j+d].key=temp;
		}
	}
}
```

> d1一般取n/2...然后n/4...以此类推
>
> **d表示的是两个数据之间的距离，也表示分成几组，比如说d=1就是整个表分成一组就是表示整个表**
>
> 也称为减少增量的排序方法
>
> 时间：O（n^1.3）
>
> 空间O（1）
>
> **仅用于顺序表，不能用链表**
>
> **不稳定的**
>
> > 哈希（散列）存储结构、哈希查找、希尔排序、哈希函数容易搞混，注意区分：哈希是查找的，希尔是插入排序的

#### 交换排序

> 两两比较，交换次序

##### 冒泡排序

```c
void swap(int &x,int &y){
	int temp=x;x=y;y=temp;
}
//冒泡排序（从后往前.每次最小放前面）
void bubbleSort(rectype R[],int n){
	int i,j,flag=1;
	for(i=0;i<n;i++){  
		for(j=n-1;j>i;j--){
			if(R[j].key<R[j-1].key){
				swap(R[j].key,R[j-1].key);
				flag=0;
			}
		}
		if(flag)
			break;
	}
}
//冒泡排序（从前往后.每次最大放后面）
void bubbleSort2(rectype R[],int n){
	int i,j,flag=1;
	for(i=n-1;i>=0;i--){  //每次将最小的放前面
		for(j=0;j<i;++j){
			if(R[j].key>R[j+1].key){
				swap(R[j].key,R[j+1].key);
				flag=0;
			}
		}
		if(flag)
			break;
	}
}
```

> 可以采用链表实现
>
> **稳定的**

##### 快速排序

- 基本思想：

  在待排序内的**n个元素中任取一个元素（一般就是第一个元素）作为基准，把该元素放入适当位置后，数据序列被此元素划分成两部分，所有小的放前面，大的放后面**，并把该元素排在这两部分的中间（称为该元素的归位），这个过程称为一趟快速排序（不完全＝一趟划分）。之后再对左右划分出来的进行快速排序，实际上就是一个递归

  > **注意快排代码：这里是low<high为的是找到low=high的点进行插入；而二分查找是low<=high是为了找到low=high+1的low点进行插入，注意区分**

  ```c
  //快速排序（王）
  int partition(rectype r[],int low,int high){
  	int pivot=r[low].key;   //pivot是基准、枢轴的意思，这里每次让第一个元素作为基准
  	while(low<high){   //找出low=high的枢轴位置
          //从high先还是low先都是一样的，这边是以high先走
  		while(low<high && r[high].key>=pivot)//找出比基准小的high
  			high--;
  		r[low].key=r[high].key;  //比枢轴小的值移到枢轴左边
  		while(low<high && r[low].key<=pivot)//比low基准大时不成立
  			low++;  
  		r[high].key=r[low].key;  //比枢轴大的值移到枢轴右边
  	}
  	r[low].key=pivot; //结束循环表示，low=high，此处就是枢轴的位置，这里也可以用high
  	return low;  //返回枢轴的下标
  }
  void quickSort(rectype r[],int low,int high){
  	if(low<high){    //递归退出的条件
  		int pivot=partition(r,low,high);  //这是枢轴的下标，进行划分
  		quickSort(r,low,pivot-1);  //对枢轴左侧快速排序
  		quickSort(r,pivot+1,high);  //对枢轴右侧快速排序
  	}
  }
  ```

  > 代码（递归）：重要
  >
  > **不稳定的** 
  >
  > 空间：O（nlog2n）。其中**n为递归层数**
  >
  > **时间：O（log2n)**
  >
  > > 与希尔排序O（n*log2（n））的比较：当n>2.5时，快排优势，小于时，希尔优势
  >
  > 优化：每次选的枢轴尽量可以划分均匀的两部分
  >
  > 1. 选头、中、尾三个数据元素，选中间值作为枢轴元素
  > 2. 随机选一个元素作为枢轴元素
  >
  > ```c
  > //快速排序（优化）--选择mid作为基准
  > void quickSort2(rectype r[],int low,int high){
  > 	int mid,pivot;
  > 	mid=(low+high)/2;
  > 	if(low<high){
  > 		if(mid!=low)//若基准不是区间中的第一个元素，将其与第一个元素交换
  > 			swap(r[mid].key,r[low].key); //可能是懒得搞了，把基准放去low的位置，统一操作 
  > 		pivot=partition(r,low,high);
  > 		quickSort2(r,low,pivot-1);
  > 		quickSort2(r,pivot+1,high);
  > 	}
  > }
  > ```

#### 选择排序

> 每一趟从待排序元素中选出关键字最小（最大）的元素，放在子表最后，直至完成

##### 简单选择（直接选择）排序

> 分为有序区与无序区，有点类似冒泡

```c
//简单排序（王）
void swap(int &a,int &b){
	int temp=a;
	a=b;
	b=temp;
}
void eazySort(rectype r[],int n){
	int k,min;
	for(int i=0;i<n-1;i++){
		min=i;
		for(k=i+1;k<n;k++)
			if(r[k].key<r[min].key)
				min=k;
		if(min!=i)  //表示不是原地交换
			swap(r[min].key,r[i].key);
	}
}
```

> 链表也可以
>
> 不稳定

##### 堆排序

堆排序是一种树形选择排序方法

> **堆是一颗完全二叉树**，采用数组顺序存储，有大小根堆之分
>
> 堆又叫优先级队列
>
> 优先级队列是完全⼆叉树 + 堆的规则（⼤⼩根堆）
>
> 左孩子2i，右孩子2i+1
>
> 父节点i/2(下取整)

- 实现大根堆的算法（下标从1开始）

  ```c
  //大根堆排序
  //筛选函数，选出最大的上浮，小元素下坠
  void sift(rectype r[],int i,int len){ 
  	//left是左孩子,i是根，len是多少个数据
  	r[0]=r[i];   //将0腾出，暂存数据
  	for(int left=2*i;left<=len;left*=2){
  		if(left<len && r[left].key<r[left+1].key)  //选出左右孩子最大的一个
  			left++;  //右孩子更大，将left指向右孩子
  		if(r[0].key<r[left].key){  //左孩子比根大
  			r[i]=r[left];  //将左孩子挪到根上
  			i=left;
  		}
  		else  //根比左右孩子都大
  			break;
  	}
  	r[i]=r[0];
  }
  //建立大根堆的方式：从最后一个分支节点开始，大的上浮，小的筛下去
  void createHeap(rectype r[],int n){
  	for(int i=n/2;i>=1;i--)
  		sift(r,i,n);
  }
  ```

- 实现对大根堆排序的算法

  ```c
  //堆排序的建立，每次根（最大的）和最后一个元素交换，这样每次选出最大的放末尾，就形成了升序
  void heapSort(rectype r[],int n){
  	createHeap(r,n);
  	for(int i=n;i>=2;i--){  //进行n-1躺堆排序，每一趟堆中元素个数减1
  		swap(r[1].key,r[i].key);  //将最后一个元素和根交换
  		sift(r,1,i-1);
  	}
  }
  ```

> **大根堆进行堆排序后产生的是降序序列，小根堆进行堆排序后产生的是升序序列**
>
> 时间复杂度：**O（nlog2n）**
>
> 空间复杂度：O（1）
>
> - 小根堆只需改动sift即可
>
>   ```c
>   void sift2(rectype r[],int i,int len){ 
>   	r[0]=r[i];   
>   	for(int j=2*i;j<=len;j*=2){
>   		if(j<len && r[j].key>r[j+1].key)  //如果右孩子更小
>   			j++;   //也就只需改动两个if的大于小于号即可
>   		if(r[0].key>r[j].key){  
>   			r[i]=r[j];  
>   			i=j;
>   		}
>   		else 
>   			break;
>   	}
>   	r[i]=r[0];
>   }
>   ```

- 下标从0开始的大根堆排序

  ```c
   void sift3(int* nums,int i,int len){
  	 int temp=nums[i];  //nums[0]=nums[i]
  	 for(int child=i*2+1;child<len;child=i*2+1){  //child=i*2;child<=len;chile*=2)
  	     if(child<len-1 && nums[child]<nums[child+1])  //child<len
  	        child++;
  	    if(temp>nums[child])  //nums[0]>=nums[left]
  	        break;
  	    else{
              nums[i]=nums[child];
              i=child;
          }
  	 }
  	 nums[i]=temp;  //=nums[0]
  }
  void heapsort(int* nums,int n){
       for(int i=n/2-1;i>=0;i--)  //i=n/2,i>=1
          sift3(nums,i,n);
      for(int i=n-1;i>=1;i--){  //i=n;i>=2
          int temp=nums[0];   //0都是1
          nums[0]=nums[i];
          nums[i]=temp;
          sift3(nums,0,i);  //sift3(nums,1,i-1)
      }
   }
  ```

- 堆中插入新元素：对于小根堆，新元素放到表尾，与其父节点比较，小则一路上升，直至无法上升为止

- 堆中删除元素：被删除的元素用堆底元素替代，让该元素不断下坠

  > 只有一个孩子下坠：只用对比一次关键字
  >
  > 两个孩子下坠：对比两次关键字

#### 归并排序

​	**归并排序是多次将两个或两个以上的有序表合成一个新的有序表**。一般内排序都是用的二路归并排序，即二路归并；而外排序才是k路归并排序

- 算法思想

  将两个有序表放在同一个数组相邻的位置，并将他们放在一个暂时数组中，待合并后移回原数组去

- 递归实现（自顶向下）

  ```c
  //二路归并排序（递归式）
  void merge(rectype r[],int low,int mid,int high){
  	rectype* r1;  //辅助变量进行排序
  	int i=low,j=mid+1,k;  //i是第一段，j是第二段，k表示r的位置
  	r1=(rectype*)malloc((high-low+1)*sizeof(rectype)); //分配和r一样的空间
  	for(k=low;k<=high;k++)  //先将第一段和第二段都移去r1
  		r1[k].key=r[k].key;  
  	for(k=i;i<=mid&&j<=high;k++){
  		if(r1[i].key<=r1[j].key)
  			r[k].key=r1[i++].key;
  		else
  			r[k].key=r1[j++].key;
  	}
  	//当其中一段完了另一段没完时
  	while(i<=mid)
  		r[k++].key=r1[i++].key;
  	while(j<=high)
  		r[k++].key=r1[j++].key;
  	free(r1);
  }
  void mergeSort(rectype r[],int low,int high){
  	if(low<high){  //low=high表示就剩一个元素了？
  		int mid=(low+high)/2;  //中间划分，分别对两边递归的归并排序
  		mergeSort(r,low,mid);
  		mergeSort(r,mid+1,high);
  		merge(r,low,mid,high);  //再对上面两个归并
  	}
  }
  ```

- 非递归式，自底向上（不重要）

  ```c
  //非递归式
  void MergePass(rectype R[],int length,int n)	//对整个数序进行一趟归并
  {
  	int i;
  	for (i=0;i+2*length-1<n;i=i+2*length) 	//归并length长的两相邻子表
  		merge(R,i,i+length-1,i+2*length-1);
  	if (i+length-1<n-1)                		//余下两个子表,后者长度小于length
  		merge(R,i,i+length-1,n-1);  		//归并这两个子表
  }
  void MergeSort(rectype R[],int n)			//自底向上的二路归并算法
  {
  	int length;
  	for (length=1;length<n;length=2*length)//进行log2n趟归并
  		MergePass(R,length,n);
  }
  ```

> 稳定
>
> 时间：O（log2n）
>
> 空间：O（n）

#### 基数排序

基数排序是一种不需要进行关键字比较的，借助于多关键字排序的思想对单关键字排序的方法

​	一般元素R【i】的关键字有**d位数字（或字符）组成**，其中每一位的值都在0-r的范围内，r要取最大的值，**其中r成为基数（index）**

​	基数排序有两种，即最低位优先（least significant digit first，**LSD**）和最高位优先（most significant digit first，MSD）

- 分配：开始时，把Q，Q·····Q各个队列置成空队列，然后依次考查线性表中的每一个元素aj（j＝0，1，···，n—1），如果元素aj的关键字k｝＝k，就把元素a，插入到Q，队列中。
- 收集：将Q，Q1，···，Q—1各个队列中的元素依次首尾相接，得到新的元素序列，从而组成新的线性表。

> 例如对整数序列递增排序，由于个位数的重要性低于十位数，十位数的重要性低于百位数，一般越重要的位越放在后面排序，个位数属于最低位，所以对整数序列递增排序时应该采用最低位优先排序方法。
>
> 算法不考
>
> **时间：O（d（n+r））**
>
> **空间：O（r）**
>
> **稳定**
>
> 擅长处理：
>
> - 关键字可以方便地拆分位d组，且d较小
> - r较小
> - 元素个数n较大

![43](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243615.png)

> 按个位收集之后，形成了个位的升序序列
>
> 按十位手机之后形成了十位的升序序列，如果十位相同，则按个位的升序序列，得到最终的排序结果

#### 各排序的比较

| 排序方法     | 平均时间复杂度  | 空间       | 稳定性     |
| ------------ | --------------- | ---------- | ---------- |
| **直接插入** | O（n^2）        | O（1）     | **稳定**   |
| 折半插入     | O（n^2）        | O（1）     | 稳定       |
| **希尔**     | **O（n^1.3)**   | O（1）     | 不稳定     |
| 冒泡         | O（n^2）        | O（1）     | 稳定       |
| **快速**     | **O（nlog2n）** | O（log2n） | 不稳定     |
| 简单选择     | O（n^2）        | O（1）     | **不稳定** |
| **堆**       | **O（nlog2n）** | O（1）     | 不稳定     |
| **二路归并** | **O（nlog2n）** | O（n）     | 稳定       |
| 基数         | O（d（n+r））   | O（r）     | 稳定       |

> **稳定的优先选：直插、冒泡、归并**
>
> **不稳定的优先选：快速、希尔、堆**
>
> 只用记不稳定的排序4个：**简单**地**快速堆希尔**排序

# 操作系统基础

![image-20240322093318450](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243634.png)

- 操作系统定义：能有效地组织和管理系统中的各种软/硬件资源，合理地组织计算机系统工作流程，控制程序的执行，并且向用户提供一个良好的工作环境和友好的接口。

- 操作系统有两个重要的**作用：第一通过资源管理提高计算机系统的效率；第二，改善人机界面向用户提供友好的工作环境。**

- 操作系统的**4个特征是并发性、共享性、虚拟性和不确定性**

  > 并发不是并行



- 操作系统的功能：
  （1）**进程管理**。实质上是对处理机的执行“时间”进行管理，采用多道程序等术将CPU的时间合理地分配给每个任务，主要包括进程控制 进程同步、进程通信和进程调度
  （2）**文件管理**。 主要包括文件存储空间管理、目录管理、文件的读/写管理和存取控制。
  （3）**存储管理**。存储管理是对主存储器“空间”进行管理主要包括存储分配与回收、存储保护、地址映射（变换）和主存扩充。
  （4）**设备管理**。实质是对硬件设备的管理，包括对输入/输出设备的分配、启动、完成和回收
  （5）作业管理。包括任务、界面管理、人机交互、图形界面、语音控制和虚拟现实等。



**操作系统的分类：**

- **批处理操作系统：**单道批处理和多道批处理（主机与外设可并行）。
- **分时操作系统**：一个计算机系统与多个终端设备连接。将CPU的工作时间划分为许多很短的时间片，轮流为各个终端的用户服务。
- **实时操作系统**：实时是指计算机对于外来信息能够以足够快的速度进行处理并在被控对象允许的时间范围内做出快速反应。实时系统对交互能力要求不高但要求可靠性有保障。
- **网络操作系统**：是使联网计算机能方便而有效地共享网络资源，为网络用户提供各种服务的软件和有关协议的集合。三种模式：集中模式、客户端/服务器模式（cs|bs）、对等模式。
- **分布式操作系统**：分布式计算机系统是由多个分散的计算机经连接而成的计算机系统，系统中的计算机无主、次之分，任意两台计算机可以通过通信交换信息。
- **微型计算机操作系统**：简称微机操作系统，常用的有Windows、MacsLinux。



**嵌入式操作系统主要特点：**

- （1）**微型化**。从性能和成本角度考虑，希望占用的资源和系统代码量少，如内存少、字长短、运行速度有限、能源少（用微小型电池）。
- （2）**可定制**。从减少成本和缩短研发周期考虑，要求嵌入式操作系统能运行在不同的微处理器平台上，能针对硬件变化进行结构与功能上的配置，以满足不司应用需要。
- （3）**实时性**。嵌入式操作系统主要应用于过程控制、数据采集、传输通信、媒体信息及关键要害领域需要迅速响应的场合，所以对实时性要求较高。
-  （4）**可靠性**。系统构件、模块和体系结构必须达到应有的可靠性，对关键要害应用还要提供容错和防故障措施
- （5）**易移植性**。为了提高系统的易移植性，通常采用硬件抽象层和板级支撑包的底层设计技术。
- 嵌入式系统**初始化过程**按照自底向上、**从硬件到软件的次序依次为：片级初始化→板级初始化→系统初始化**

## 进程管理

### 进程三态图

- **进程的组成：进程控制块PCB（process control block）（唯一标志）、程序（描述进程要做什么）、数据（存放进程执行时所需数据）**

  > 任务控制块TCB(Task Control Block)
  >
  > FCB：文件控制块

- 进程基础的状态是下左图中的三态图。需要熟练掌握左下图中的进程三态之间的转换。

  ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243636.png)

  > **阻塞也叫等待**
  >
  > **阻塞不能直接进入运行状态，就绪状态也不能直接进入阻塞**

  ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243637.png)

### 前驱图

> **反映了进程之间的关系，每一条代表一个信号量S。每一个进程执行完就会释放掉信号量**

- 用来表示哪些任务可以并行执行，哪些任务之间有顺序关系，具体如下图可知，ABC可以并行执行，但是必须ABC都执行完后，才能执行D，这就确定了**两点：任务间的并行、任务间的先后顺序**

  ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243638.png)

### 进程资源图

用来表示进程和资源之间的分配和请求关系，如下图所示：

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243639.png)

- **P（process）代表进程，R（resource）代表资源**，R方框中有几个圆球就表示有几个这种资源，在上图中，**R1指向P1，表示R1有一个资源已经分配给了P1，P1指向R2，表示P1还需要请求一个R2资源才能执行。**

  > **看进程p（⚪），入度是有的资源（R资源已分配给P），出度是需要请求的资源**
  
- **阻塞节点：某进程所请求的资源已经全部分配完毕**，无法获取所需资源，该进程被阻塞了无法继续。如上图中P2。

- **非阻塞节点：某进程所请求的资源还有剩余**，可以分配给该进程继续运行。如上图中P1、P3。

  > **进程出度的请求用完会回收，进行释放**

- 当一个进程资源图中**所有进程都是阻塞节点时，即陷入死锁状态**

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243640.png)

> **是否能化简什么意思？**
>
> 一**定要先执行不阻塞节点；p3先执行完后，释放会R1和R2，此时p1和p2就不阻塞了**

### 进程同步与互斥

- **临界资源：各进程间需要以互斥方式对其进行访问的资源**。

- **临界区：指进程中对临界资源实施操作的那段程序**。本质是一段程序代码。

- **互斥：某资源（即临界资源）在同一时间内只能由一个任务单独使用，使用时需要加锁**，使用完后解锁才能被其他任务使用：**如打印机。**

- **同步：多个任务可以并发执行，只不过有速度上的差异**，在一定情况下停下等待，不存在资源是否单独或共享的问题；如自行车和汽车。

- **互斥信号量S：对临界资源采用互访问，使用互信号量后其他进程无法访问，初值为1**。

- **同步信号量S：对共享资源的访问控制，初值一般是共享资源的数量**

  > 共享资源有上限
  
  ![image-20240324200549965](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243641.png)

### 进程的信号量的pv操作

- **P操作：申请资源，S=S-1**，若S>=0，则执行P操作的进程继续执行；若**S<0，则置该进程为阻塞状态（因为无可用资源），并将其插入阻塞队列。**

  > **s>=0：表示资源的可用个数**
  >
  > **s<0：则绝对值s表示阻塞队列中等待该资源的进程数，也表示当前为阻塞状态，要尽量避免这种情况**

- **V操作：释放资源，S=S+1**，若S>0，则执行V操作的进程继续执行；若**S<=0，则从阻塞状态唤醒一个进程，并将其插入就绪队列**（此时因为缺少资源被P操作阻塞的进程可以继续执行），然后执行V操作的进程继续

  > S：信号量
  >
  > **s>=0：表示资源的可用个数**
  >
  > **s<0：则绝对值s表示阻塞队列中等待该资源的进程数，也表示当前为阻塞状态，要尽量避免这种情况**
  
  ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243642.png)

- 经典问题（上述的应用）：**生产者和消费者的问题**
  三个信号量：互压信号量So（仓库独立使用权），同步信号量S1（仓库空闲个数），同步信号量S2（仓库商品个数）。
        生产者流程：                      消费者流程：
       生产一个商品S                     PSO）
        PISO                                P(S2）
        P（S1）                         取出一个商品
       将商品放入仓库中                  V(S1）
        V（S2）                                VSO）
        VSO）

  > **如何判断vp哪个先哪个后？**
  >
  > **若信号量初值为>0，则先p后v**
  >
  > **若信号量初值为<=0，则先v后p**
  
  <img src="https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243643.png" style="zoom:200%;" />
  
  > **看前驱图，区分哪条线对应的是S几；**
  >
  > **前驱图的出度就是释放空间，即V，入读就是占用空间，即P**
  >
  > **上图因为初值都是0，所以为了使不进入阻塞状态，就先执行v的操作来进行+1**
  >
  > **一个进程的信号量不管是同步还是互斥，他都有一个v一个p**
  
  ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243644.png)
  
  > **根据一个信号量一个v和p与先v后p的两个条件前后推论**
  >
  > **做题方法：大胆假设，小心求证**
  >

### 死锁

- 当一个进程在等待永远不可能发生的事件时，就会产生死锁若系统中有多个进程处于死锁状态，就会造成系统死锁

- **死锁产生的四个必要条件：**
  - **资源互斥**
  
  - **每个进程占有资源并等待其他资源**
  
  - **系统不能夺进程资源**
  
    > 但是强制剥夺资源可以破坏
  
  - **进程资源图是一个环路。**

**死锁产生后，解决措施是打破四大条件，有下列方法：**

- **死锁预防**：采用某种策略限制并发进程对于资源的请求，破坏死锁产生的四个条件之一，使系统任何时刻都不满足死锁的条件

- **死锁避免**：一般采用**银行家算法**来避免，银行家算法，就是提前计算出一条不会死锁的资源分配方法，才分配资源，否则不分配资源，相当于借贷，考虑对方还得起才借钱，提前考虑好以后，就可以避免死锁

  > **重点：银行家算法**
  >
  > 银行家算法步骤：
  >
  > 1. 求剩余可用的资源数：**拿可用资源数-已分配的资源数**
  > 2. **求每个进程的还需资源数：每个进程的最大需求量-已分配的资源数**
  > 3. **拿1求出的资源数去2里找是否能够执行该进程，若能执行则执行完后将已分配资源数加到1的剩余资源数里去**，如果不能执行就是死锁了，以此类推
  >
  > ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243645.png)
  >
  > ![image-20240324201134437](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243646.png)
  >
  > 例如上面该题
  >
  > **①剩余资源=210**
  >
  > ②：
  >
  > | 进程 | 已分配资源 | ②的资源 |
  > | ---- | ---------- | ------- |
  > | p1   | 121        | 531     |
  > | p2   | 211        | 010     |
  > | p3   | 210        | 6 -1 1  |
  > | p4   | 120        | 001     |
  > | p5   | 113        | 231     |
  >
  > ③：**剩余资源数210根据②的资源数只能执行p2，执行完后，210+p2对应的已分配资源211，最后是421**
  >
  > ④：421不能执行p1，只能执行p4，所以根据选项就是c了

- **死锁检测**：允许死锁产生，但系统定时运行一个检测死锁的程序，若检测到系统中发生死锁，则设法加以解除。

- **死锁解除**：即死锁发生后的解除方法，如强制夺资源，撤销进程等

- **死锁资源计算：系统内有n个进程，每个进程都需要R个资源，那么其发生死锁的最大资源数为n*（R-1）。其不发生死锁的最小资源数为n\*（R-1）+1。**

  > **公式重要          👆**
  
  ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243647.png)

  > s**>0是有的资源数量，s<0是当前系统有多少进程正在等待资源**
  >
  > 由此得出最大值是初值：打印机的数量，最小值就是等待的资源：3个资源-n个进程，
  
  ![image-20240429164933116](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243648.png)
  
  > **注：上图中分配资源必须是每个进程都1个才能有一个是2，也就是说进程最大资源数和最小资源数最多差1**

### 线程

> **一个实体，基本不含资源，而是共享进程的资源，线程有pcb（线程控制块），比进程有的更小的单位**
>
> 在一个进程里可以创建多个线程

- **传统的进程有两个属性：可拥有资源的独立单位；可独立调度和分配的基本单位。**
- 引入线程的原因是进程在创建、撤销和切换中，系统必须为之付出较大的时空开销，故在系统中设置的**进程数目不宜过多**，进程切换的频率不宜太高，这就限制了并发程度的提高。引入线程后，将传统进程的两个基本属性分开，**线程作为调度和分配的基本单位，进程作为独立分配资源的单位**。用户可以通过创建线程来完成任务，以减少程序并发执行时付出的时空开销。
- **线程分为用户级线程和内核支持线程**
  1. **用户级线程不依赖于内核**。创建、撤销和切换**都不利用系统调用来实现**
  2. **内核支持线程依赖于内核**。**都利用系统调用来实现**

- 线程是进程中的一个实体，是被系统独立分配和调度的基本单位。**线程基本上不拥有资源，只拥有一点运行中必不可少的资源（如程序计数器、一组寄存器和栈），它可与同属一个进程的其他线程共享进程所拥有的全部资源**，例如进程的公共数据、全局变量、代码、文件等资源，**但不能共享线程独有的资源**，如线程的栈指针等标识数据

**多个线程之间的共享内容问题**

| 线程共享资源       | 线程独享资源   |
| ------------------ | -------------- |
| **地址空间**       | **程序计数器** |
| **全局变量**       | **寄存器**     |
| **打开的文件**     | **栈**         |
| **子进程**         | **状态字**     |
| 闹铃               |                |
| 信号及信号服务程序 |                |
| **记账信息**       |                |



### 进程调度

| 算法                                           |                  | 说明                                                         | 备注                                                         |
| ---------------------------------------------- | ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **先来先服务**<br/> （First Come First Serve） | 先来先得**先后** | 最简单，先来的任务先服务<br/>                                | 优点：对长任务和繁忙CPU有利缺点：对短任务和繁忙VO任务不利    |
| **短作业优先<**br/> （Shortest Job First）     | 谁小谁先**爱幼** | 对长任务不利；不能保障紧急任务被及时处理；任务长短只是主观估算<br/> | **优点：最短的平均等待时间和平均周转时间<br/>缺点：对长任务不利，未考虑紧追性会导致机（长任务得不到资源）** |
| **优先权调度**<br/> Priority Scheduling）      | 看优先级权重     | 根据优先级把资源分配给优先级最高的静态优先权+动态优先权<br/> | **优点：可灵活调整任务偏好程度<br/>缺点：高优先级太多，导致（低优先级无法得到资源<br/>** |
| **时间片轮转**<br/> Round Robin）              | 一视同仁**公平** | 将作业排成队列，每份作业分段，轮流获取运行时间<br/>进程阻塞，未用完也要让出；不考虑任务长短受系统处理能力和负载影响 | **优点：公平，响应快，适用于分时操作系统<br/> 缺点：高频率切换带来开销，不区分任务紧急程度** |
| 多级反馈调度                                   |                  | 是时间片轮转和优先级的综合                                   | 优点：照顾了短进程以提高系统吞吐量，缩短了平均周转时间       |

![image-20240429161544096](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243649.png)

> **时间片流转（轮转）是用于交互式系统的**

- **进程调度方式是指当有更高优先级的进程到来时如何分配CPU。分为可夺和不可夺两种，可剥夺指当有更高优先级进程到来时，强行将正在运行进程的CPU分配给高优先级进程**；不可夺是指高优先级进程必须等待当前进程自动释放CPU。

- **在某些操作系统中，一个作业（一组进程）从提交到完成需要经历高、中、低三级调度。**

  （1）**高级调度。高级调度又称“长调度”“作业调度”或“接纳调度” 它决定处于输入池中的哪个后备作业可以调入主系统做好运行的准备**，成为一个或组就绪进程。在系统中一个作业只需经过一次高级调度。
   （2）**中级调度。中级调度又称“中程调度”或“对换调度  它决定处于交换区中的哪个就绪进程可以调入内存**，以便直接参与对CPU的竞争。
   （3）**低级调度。低级调度又称“短程调度”或“进程调度”，它决定处于内存中的哪个就绪进程可以占用CPU**。低级调度是操作系统中最活跃、最重要的调度程序，对系统的影响很大

**调度算法：**

- **先来先服务FCFS**：先到达的进程优先分配CPU。用于宏观调度
- **时间片轮转（分时）**：分配给每个进程CPU时间片，轮流使用CPU，每个进程时间片大小相同，很公平，用于微观调度
- **优先级调度**：每个进程都拥有一个优先级，优先级大的先分配CPU。
- **多级反馈调度**：时间片轮转和优先级调度结合而成，设置多个就绪队列，每个队列分别赋予不同的优先级，分配不同的时间片长度；新进程先进入队列1的未尾，按FCFS原则，执行队列1的时间片；若未能执行完进程，则转入队列2的未尾，如此重复 

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243650.png)

## 存储管理

### 分区存储管理

- **所谓分区存储管理，就是整存，将某进程运行所需的内存整体一起分配给它**，然后再执行。有三种分区方式：

- **固定分区**：静态分区方法，将主存分为若干个固定的分区，将要运行的作业装配进去，由于分区固定，大小和作业需要的大小不同，**会产生内部碎片**。

  > 类似数组

- **可变分区**：动态分区方法，主存空间的分区是在作业转入时划分，正好划分为作业需要的大小，这样就不存在内部碎片，但容易将整片主存空间切割成许多块，会**产生外部碎片**。可变分区的算法如下

- **系统分配内存的算法有很多**，如下图所示，根据分配前的内存情况，还需要分配9kb空间，对不同算法的结果介绍如下：

  > - **首次适应法**：按内存地址顺序从头查找，找到第一个>=9k空间的空闲块，即切割9k空间分配给进程
  >
  > - **最佳适应法**：将内存中所有空闲内存块按从小到大排序，找到第一个>=9K空间的空闲块，切割分配，这个将会找到与9K空间大小最相近的空闲块
  >
  > - **最差适应法**：和最佳适应法相反，将内存中空闲块空间最大的，切割9k空间分配给进程，这是为了预防系统中产生过多的细小空闲块
  >
  > - **循环首次适应法**：按内存地址顺序查找，找到第一个>=9K空间的空闲块，而后若还需分配，则找下一个，不用每次都从头查找，这是与首次适应法不同的地方
  >
  >   ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243651.png)

- **可重定位分区**：可以解决碎片问题，移动所有已经分配好的区域，使其成为个连续的区域，这样其他外部细小的分区碎片可以合并为大的分区，满足作业要求。只在外部作业请求空间得不到满足时进行

### 分页存储管理

#### 分页

> **要掌握逻辑地址看页表转化为物理地址**
>
> 分区存储是整存
>
> 分页存储不用一次性存进去，一步一步的，现在计算机常用的
>
> 有内部碎片

**逻辑页分为页号和页内地址**，**页内地址就是物理偏移地址（页号的后xx位），而页号（位于高位）与物理块号并非按序对应的，需要查询页表**，才能得知页号对应的物理块号，再用物理块号加上偏移地址才得出了真正运行时的物理地址

- **分页系统（逻辑地址（页））的地址结构：**

| 高位     | 低位                     |
| -------- | ------------------------ |
| **页号** | **页内地址（偏移地址）** |

**优点：利用率高，碎片小，分配及管理简单**
**缺点：增加了系统开销，可能产生抖动现象**

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243652.png)



> 页的个数增加，但算法没有提升，导致原本不会下降的速度，速度下降
>
> 
>
> **页的逻辑地址组成：页号，内存（偏移）地址组成**
>
> **物理地址：页框（页帧），外存地址组成**
>
> 
>
> **页号：假设有4GB的内存，每一页的大小为4KB，那么总共有2^20页，即有20位的页号，由页号查页表（存逻辑地址和物理地址之间的对应关系）才能将页号转换成物理块号，即从逻辑地址转换成物理地址**
>
> 
>
> **页内地址（页面大小）：和页的大小相关，一页大小为4KB，那么页内地址为2^12，页内地址和物理地址都是不变的**
>
> ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243653.png)





#### 页面置换算法

​    **请求分页是在纯分页系统的基础上增加了请求调页功能**、**页面置换功能所形成的页式虚拟存储系统，它是日前常用的一种虚拟存储器的方式。在进程运行过程中，如果发生缺页，此时主存中又无空闲块时，为了保证进程能正常运行，必须从主存中调出一页程序或数据送磁盘的对换区。**但究竞将哪个页面调出，需要根据一定的页面置换算法来确定。置换算法的好坏将直接影响系统的性能，不适当的算法可能会导致系统发生“抖动”（thrashing）。即刚被换出的页很快又被访问，需重新调入，导致系统频繁地更换页面，以至于一个进程在运行中把大部分时间花费在完成页面置换的工作上，这种现象称为系统发生了“抖动”（也称）。**请求分页系统的核心问题是选择合适的页面置换算法**，常用的页面置换算法如下所述。

- 最优算法：OPT，理论上的算法，无法实现，是在进程执行完后进行的最佳效率计算，用来让其他算法比较差距。原理是选择未来最长时间内不被访问的页面置换，这样可以保证未来执行的都是马上要访问的
- **先进先出算法：FIFO，先调入内存的页先被置换淘汰，会产生抖动现象**，即分配的页数越多，缺页率可能越多（即效率越低）
- **最近最少使用：LRU（Least Recently Used），在最近的过去，进程执行过程中，过去最少使用的页面被置换淘汰，根据局部性原理，这种方式效率高**，且不会产生动现象，使用大量计数器，，但是没有LFU多
- **淘汰原则：优先淘汰最近未访问的，而后淘最近未被修改的页面**

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243654.png)

> **用了最近最少使用LRU算法，第一看访问位，看有没有访问，第二看修改位，看有没有修改**



#### 快表（快速的页表）

- **是一块小容量的相联存储器，由快速存储器组成，按内容访问，速度快**，并且可以从硬件上保证按内容并行查找，**一般用来存放当前访问最频繁的少数活动页面的页号**

  > **相联存储器是一种按内容访问的存储器**

- **快表是将页表存于cache中**；**慢表是将页表存于内存上**。慢表需要访问两次内存才能取出页，而快表是访问一次cache和一次内存，因此更快

### 分段存储管理

> 分页是每页固定分（固定大小），分段每段不是固定的大小，是根据逻辑整体分段的

将进程空间分为一个个段，**每段也有段号（从0开始）和段内地址，与页式存储不同的是，每段物理大小不同，分段是根据逻辑整体分段的**。

> 分页是页号和页内地址

因此，段表也与页表的内容不同，页表中直接是逻辑页号对应物理块号，而下图所示，**段表有段长和基址两个属性**，才能确定一个逻辑段在物理段中的位置。

> **段表寄存器由段表地址地址（基址）和段长组成**
>
> **段的逻辑地址的两个位：段号，段内地址。因此逻辑地址必须在段长内（不能超出段长）**

- **分段系统的地址结果，段表（逻辑地址）：**

| 段号 | 段内地址（偏移地址） |
| ---- | -------------------- |

- **段表寄存器的组成：**

  | 段表起始地址（基址、起始地址） | 段表长度（>=段内地址） |
  | ------------------------------ | ---------------------- |

  > **逻辑地址转换成物理地址：段表的起始地址+段内地址**

  优点：多道程序共享内存，各段程序修改互不影响。
 缺点：内存利用率低，内存碎片浪费大

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243655.png)

> 分页之间有逻辑地址与物理地址之间的转换，分段也有
>
> 分页是偏移地址不变，页号转换成物理号
>
> 分段是段内地址不变，段号转换成物理号

> ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243656.png)

### 段页式存储管理

- **对进程空间先分段，后分页**，具体原理图和优缺点如下

  ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243657.png)

- 优点：空间浪费小、存储共享容易、存储保护容易、能动态链接

- 缺点：由于管理软件的增加，复杂性和开销也随之增加，需要的硬件以及占用的内容也有所增加，使得执行速度大大下降

## 设备管理

### 设备管理概述

- **设备是计算机系统与外界交互的工具，具体负责计算机与外部的输入/输出工作所以常称为外部设备（简称外设）**。在计算机系统中，将负责管理设备和输入/输出的机构称为I/O系统。因此，I/O系统由设备、控制器、通道（具有通道的计算机系统）、总线和O软件组成

  **设备的分类**

- **按数据组织分类**：块设备、字符（字符流）设备。

- **按照设备功能分类**：输入设备、输出设备、存储设备、网络联网设备、供电设备。

- **资源分配角度分类**：独占设备（互斥）、共享设备（同步）和虚拟设备

- **数据传输速率分类**：低速设备、中速设备、高速设备。



- 设备管理的任务是保证在多道程序环境下，**当多个进程竞争使用设备时，按一定的策略分配和管理各种设备**，控制设备的各种操作，完成IO设备与主存之间的数据交换。
- **设备管理的主要功能是动态地掌握并记录设备的状态**、设备分配和释放、缓冲
- 区管理、实现物理IO设备的操作、提供设备使用的用户接口及设备的访问和控制

### I/O软件

- I/0设备管理软件的所有层次及每一层功能如下图：

- 实例：当用户程序试图读一个硬盘文件时，需要通过操作系统实现这一操作。**与设备无关软件检查高速缓存中有无要读的数据块（设备无关软件），若没有，则调用设备驱动程序，向IO硬件发出一个请求（设备驱动程序）**。然后，用户进程阻塞并等待磁盘操作的完成。**当磁盘操作完成时，硬件产生一个中断，转入中断处理程序（中断处理程序）**。中断处理程序检查**中断的原因，认识到这时磁盘读取操作已经完成，于是唤醒用户进程取回从盘读取的信息，从而结束此次IO请求**。用户进程在得到了所需的硬盘文件内容之，后继续运行。

  > **重点：**
  >
  > **设备无关软件**
  >
  > **设备驱动程序**
  >
  > **中断处理程序**

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243658.png)

![image-20240330185241396](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243659.png)

### 设备管理技术

- 一台独占设备，在同一时间只能由一个进程使用，其他进程只能等待，且不知道什么时候打印机空闲，此时，极大的浪费了外设的工作效率。

- （虚拟设备）引入**SPOOLING（外围设备联机操作）技术（将独占的设备转变成共享设备）**，就是在外设上建立两个数据缓冲区，分别称为输入井和输出井，这样，无论多少进程，都可以共用这一台打印机，只需要将打印命令发出，数据就会排队存储在缓冲区中，打印机会自动顺序打印，实现了物理外设的共享，**使得每个进程都感觉在使用一个打印机这就是物理设备的虚拟化**。如下图所示

  > 所谓独占就是原本打印机如果多个提交就会提示目前占用，无法使用；共享就是可以照常提交，但是你得排队

  ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243660.png)
  
  ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243661.png)

## 文件管理

### 文件管理概述

- **文件是具有符号名的、在逻辑上具有完整意义的一组相关信息项的集合**。
- **信息项是构成文件内容的基本单位**，可以是一个字符，也可以是一个记录，记录可以等长，也可以不等长。**一个文件包括文件体和文件说明。文件体是文件真实的内容。文件说明是操作系统为了管理文件所用到的信息**，包括文件名文件内部标识、文件的类型、文件存储地址、文件的长度、访问权限、建立时间和访问时间等
- **文件管理系统，就是操作系统中实现文件统一管理的一组软件和相关数据的集合，专门负责管理和存取文件信息的软件机构**，简称文件系统。文件系统的功能包括按名存取；统一的用户接口；并发访问和控制；安全性控制；优化性能；差错恢复。
-  文件的类型

  （1）按文件性质和用途可将文件分为**系统文件、库文件和用户文件**
  （2）按信息保存期限分类可将文件分为临时文件、档案文件和永久文件。（3）按文件的保护方式分类可将文件分为只读文件、读/写文件、可执行文件和不保护文件。
  （4）unI系统将文件分为普通文件、目录文件和设备文件（特珠文件）。



- **文件的逻辑结构**可分为两大类：**有结构的记录式文件：无结构的流式文件**

- **文件的物理结构是指文件在物理存储设备上的存放方法**，包括：
  （1）连续结构。连续结构也称顺序结构，它**将逻辑上连续的文件信息（如记录）依次存放在连续编号的物理块上**
   （2）链接结构。链接结构也称串联结构，它是**将逻辑上连续的文件信息（如记录）存放在不连续的物理块上，每个物理块设有一个指针指向下一个物理块。**

  **（3）索引结构。将逻辑上连续的文件信息（如记录）存放在不连续的物理块中**,系统为每个文件建立一张索引表。**索引表记录了文件信息所在的逻辑块号对应的物理块**号，并将索引表的起始地址放在与文件对应的文件目录项中。
   （4）多个物理块的索引表。**索引表是在文件创建时由系统自动建立的**，并与文件一起存放在同一文件卷上。根据一个文件大小的不同，其索引表占用物理块的个数不等，一般占一个或几个物理块

### 索引文件结构

- 如图所示，**系统中有13个索引节点，0-9为直接索引，即每个索引节点存放的是内容**，假设每个物理盘（磁盘数据块）大小为4KB，共可存4KB*10=40KB数据

  > **若没有告诉地址项是从什么数字开始的，则默认是从0开始的**

- **10号索引节点为一级间接索引节点，大小为4KB，存放的并非直接数据，而是链接到直接物理盘块的地址**，假设每个索引地址占4B，则共有1024个地址，对应1024个物理盘，可存1024*4KB=4096KB数据

  > **一个盘块可以存的索引数量=盘块的大小/每一个盘块的地址的大小**

- **二级索引节点类似，直接盘存放一级地址，一级地址再存放物理盘快地址，而后链接到存放数据的物理盘块**，容量又扩大了一个数量级，为1024\*1024\*4KB数据

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243662.png)

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243663.png)

> **磁盘索引块是用作算索引数量的除数**
>
> **磁盘数据块的用来计算长度的，长度就是数据块**

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243664.png)

### 文件目录

- **文件控制块（FCB，文件目录）中包含以下三类信息：基本信息类、 存取控制信息类和使用信息类**

  （1）**基本信息类**。例如文件名、文件的物理地址、文件长度和文件块数等。

  （2）**存取控制信息类**。文件的存取权限，像unIX用户分成文件主、同组用户和一般用户三类，这三类用户的读/写执行RWX权限。

  （3）**使用信息类**。文件建立日期、、最后一次修改日期、最后一次访问的日期、当前使用的信息（如打开文件的进程数、在文件上的等待队列）等。

- **文件控制块的有序集合称为文件目录。**

- **相对路径：是从当前路径开始的路径。**

- **绝对路径：是从根目录开始的路径。**

- **全文件名=绝对路径+文件名**。**要注意，绝对路径和相对路径是不加最后的文件名的，只是单纯的路径序列。**

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243665.png)

### 文件存储空间管理

- **文件的存取方法是指读/写文件存储器上的一个物理块的方法。通常有顺序存取和随机存取两种方法**。顺序存取方法是指对文件中的信息按顺序依次进行读写；随机存取方法是指对文件中的信息可以按任意的次序随机地读/写
- 文件存储空间的管理

**（1）空闲区表**。将外存空间上的一个连续的未分配区域称为“空闲区”。操作系统为磁盘外存上的所有空闲区建立一张空闲表，每个表项对应一个空闲区适用于连续文件结构。

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243666.png)

> 18-22都是空的
>
> 29-36...

 **（2）位示图。 这种方法是在外存上建立一张位示图（Bitmap），记录文件存储器的使用情况。 每一位bit对应文件存储器上的一个物理（磁盘）块，取值0和1分别表示空闲和占用。假如计算机系统中字长为32位那么在位示图中的第0个字（位）（逻辑编号）对应文件存储器上的0，1，2，，31号物理块：第1个字（位）对应文件存储器上的32，33，34，63号物理块，以此类推。**

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243667.png)

> **位示图的大小对应的就是多少个物理块，单位是b**
>
> 磁盘个数（b）=磁盘容量/一块磁盘（物理）块大小

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243668.png)

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243669.png)

 **（3）空闲块链**。每个空闲物理块中有指向下一个空闲物理块的指针，所有空闲物理块构成一个链表，链表的头指针放在文件存储器的特定位置上（如管理块中），不需要磁盘分配表，节省空间
 **（4）成组链接法**。例如，在实现时系统将空闲块分成若干组，每100个空闲块为一组，每组的第一个空闲块登记了下一组空闲块的物理盘块号和空闲块总数。假如某个组的第一个空闲块号等于0，意味着该组是最后一组，无下一组空闲块

### 作业调度算法

| 算法                                           |                  | 说明                                                         | 备注                                                         |
| ---------------------------------------------- | ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **先来先服务**<br/> （First Come First Serve） | 先来先得**先后** | 最简单，先来的任务先服务<br/>                                | 优点：对**长任务和繁忙CPU有利**缺点：对**短任务和繁忙VO任务不利** |
| **短作业优先<**br/> （Shortest Job First）     | 谁小谁先**爱幼** | 对长任务不利；不能保障紧急任务被及时处理；任务长短只是主观估算<br/> | **优点：最短的平均等待时间和平均周转时间<br/>缺点：对长任务不利，未考虑紧追性会导致机（长任务得不到资源）** |
| **响应比高优先**                               |                  | 响应比高的作业优先启动                                       | **响应比r=作业响应时间/作业执行时间<br />=（作业等待时间+作业执行时间）/作业执行时间** |
| **优先权调度**<br/> Priority Scheduling）      | 看优先级权重     | 根据优先级把资源分配给优先级最高的静态优先权+动态优先权<br/> | **优点：可灵活调整任务偏好程度<br/>缺点：高优先级太多，导致（低优先级无法得到资源<br/>** |
| **均衡调度算法**                               |                  | 根据系统的运行情况和作业本身的特性对作业分类，**力求均衡地使用系统的各种资源**，即注意发挥系统效率，使用户满意 |                                                              |
| **时间片轮转**<br/> Round Robin）              | 一视同仁**公平** | 将作业排成队列，每份作业分段，轮流获取运行时间<br/>进程阻塞，未用完也要让出；不考虑任务长短受系统处理能力和负载影响 | **优点：公平，响应快，适用于分时操作系统<br/> 缺点：高频率切换带来开销，不区分任务紧急程度** |

![image-20240430175349234](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243670.png)

![image-20240429161544096](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243649.png)

> **时间片流转（轮转）是用于交互式系统的**

- **进程调度方式是指当有更高优先级的进程到来时如何分配CPU。分为可夺和不可夺两种，可剥夺指当有更高优先级进程到来时，强行将正在运行进程的CPU分配给高优先级进程**；不可夺是指高优先级进程必须等待当前进程自动释放CPU。

- **在某些操作系统中，一个作业（一组进程）从提交到完成需要经历高、中、低三级调度。**

  （1）**高级调度。高级调度又称“长调度”“作业调度”或“接纳调度” 它决定处于输入池中的哪个后备作业可以调入主系统做好运行的准备**，成为一个或组就绪进程。在系统中一个作业只需经过一次高级调度。
   （2）**中级调度。中级调度又称“中程调度”或“对换调度  它决定处于交换区中的哪个就绪进程可以调入内存**，以便直接参与对CPU的竞争。
   （3）**低级调度。低级调度又称“短程调度”或“进程调度”，它决定处于内存中的哪个就绪进程可以占用CPU**。低级调度是操作系统中最活跃、最重要的调度程序，对系统的影响很大

**调度算法：**

- **先来先服务FCFS**：先到达的进程优先分配CPU。用于宏观调度
- **时间片轮转（分时）**：分配给每个进程CPU时间片，轮流使用CPU，每个进程时间片大小相同，很公平，用于微观调度
- **优先级调度**：每个进程都拥有一个优先级，优先级大的先分配CPU。
- **多级反馈调度**：时间片轮转和优先级调度结合而成，设置多个就绪队列，每个队列分别赋予不同的优先级，分配不同的时间片长度；新进程先进入队列1的未尾，按FCFS原则，执行队列1的时间片；若未能执行完进程，则转入队列2的未尾，如此重复 

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243650.png)

# 网络基础知识

![image-20240322093410114](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243671.png)

## 计算机网络概述

### 网络功能和分类

计算机网络是计算机技术与通信技术相结合的产物，它实现了远程通信、远程信息处理和资源共享。

**计算机网络的功能：数据通信、资源共享、负载均衡、高可靠性。**

**计算机网络按分布范围和拓扑结构划分**如下图所示：

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243672.png)

> **Local** Area Network
>
> **Metropolitan** Area Network
>
> **Wide** Area Network
>
> 互联网就是一个广域网
>
> **一个局域网的基本组成主要有网络服务器、网络工作站、网络适配器和传输介质；决定局域网特性的主要技术有三个方面：用以传输数据的传输介质；用以连接各种设备的拓扑结构：用以共享资源的介质访问控制方法**
>
> 例如电信的100兆M每秒，实际就是100Mbit/s，实际要除以8=12.5MB/s





总线型（**利用率低**、干扰大、价格低）、**星型（交换机**形成的局域网、中央单元负荷大）、环型（**流动方向固定（顺或逆）**、效率低扩充难）、树型（总线型的扩充、分级结构）、分布式（任意节点连接，管理难成本高）

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243673.png)

> **总线型特点：只能一个发送。可以多个接受**
>
> **星型常用：交换机**

### OSI七层模型

> （Open System Interconnect），即[开放式系统](https://baike.baidu.com/item/开放式系统/0?fromModule=lemma_inlink)互连参考模型
>
> **记忆口诀：物链网传输应用**

| 层次（低到高）   | 功能                                                         | 单位        | 协议                                                     | 设备                                             |
| ---------------- | ------------------------------------------------------------ | ----------- | -------------------------------------------------------- | ------------------------------------------------ |
| **1.物理层**     | **在链路上透明地传输位（bit）**。需要完成的工作包括线路配置、确定数据传输模式、确定信号形式、对信号进行编码、连接传输介质。为此定义了建立、维护和拆除物理链路所具备的机械特性、电气特性、功能特性以及规程特性。 | **比特bit** | EIA/TIA RS-232、RS-449、V.35、**RJ-45**、FDDI            | **中继器（集线器）**、**集成器（hub、usb多口）** |
| **2.数据链路层** | **把不可靠的信道变为可靠的信道**。为此将比特组成，在链路上提供点到点的传输，并进行差错控制、流量控制等。 | **帧**      | SDLC、HDLC、LAPB、**PPP**、STP、中继等、IEEE802、**ATM** | **交换机、网桥**                                 |
| **3.网络层**     | **在源节点目的节点之间进行路由选择、拥塞控制、顺序控制、传送包，保证报文的正确性。**网络层控制着通信子网的运行，因而它又称为通信子网层 | IP分组      | **IP**、 ICMP、IGMP、**ARP**、RARP、IPsec                | **路由器**                                       |
| **4.传输层**     | **提供端-端间可靠的、透明的数据传输**，保证报文顺序的正确性、数据的完整性。 | 报文段      | **TCP**、**UDP**                                         | **网关**                                         |
| 5.会话层         | **建立通信进程的逻辑名字与物理名字之间的联系，提供进程之间建立、管理和终止会话的方法，处理同步与恢复问题。** | PDU         | RPC、SQL、NFS                                            | **网关**                                         |
| 6.表示层         | 实现**数据转换（包括格式转换、压缩、加密等）**，提供标准的应用接口、公用的通信服务、公共数据表示方法 |             | JPEG、**ASCII**、GIF、MPEG、DES                          | **网关**                                         |
| **7.应用层**     | 对用户不透明的**提供各种服务**，如E-mail。                   | 数据        | **Telnet、 FTP、 HTTP**、SMTPPOP3、**DNS、DHCP**等       | **网关**                                         |

> - **第①层的设备每个代表一个冲突域**
> - **第②层的设备每个都能隔离冲突域，即几个主机就是几个冲突域**
> - **第③层的设备每个都能隔离广播域，即连接几个设别就是几个广播域**
>
> 局域网就是数据链路层，不能接入互联网（网络层），可以连在一起，但不能通网
>
> **以太网（以太网是一种计算机局域网技术。以太网有两类：第一类是经典以太网，第二类是交换式以太网，使用了一种称为交换机的设备连接不同的计算机。以太网是一种计算机局域网技术。以太网有两类：第一类是经典以太网，第二类是交换式以太网，使用了一种称为交换机的设备连接不同的计算机。）是局域网的一个具体应用**
>
> 以太网位于**传输层**
>
> ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243674.png)

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243675.png)

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243676.png)

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243677.png)

## 网络硬件基础

### 传输介质（网线）

- 双绞线：将多根铜线按规则缠绕在一起，能够减少干扰；**分为无屏双绞线UTP和屏双绞线STP**，都是由一对铜线组成。也即我们常说的**网线；双绞线的传输距离在100m以内。**

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243678.png)

- **无屏蔽双绞线UTP**：价格低安装简单，但可靠性相对较低，分为CAT3（3类UTP，速率为10Mbps）、CAT4（4类UTP，与3类差不多，无应用）、-CAI5（**5类UTP，速率为100Mbps**，用于快速以太网）CAI5E（超5类UTP，速率为1000Mbps）、CAT6（6类UTP，用来替代CAT5E，速率也是1000Mbps） 
- **屏蔽双绞线STP**：比之UTP增加了一层屏蔽层，可以有效的提高可靠性，但对应的价格高，安装麻烦，一般用于对传输可靠性要求很高的场合。
- **多模光纤的特点：成本低、宽芯线、聚光好、耗散大、低效，用于低速短**距离的通信。
- **单模光纤的特点：成本高、窄芯线、需要激光源、耗散小、高效，用于高速长距离的通信。**



网线标准：

- **A：绿白绿 橙白蓝 蓝白橙 棕白棕**

- **B：橙白橙 绿白蓝 蓝白绿 棕白棕**

  > **两者相同：蓝和蓝白，棕白棕**
  >
  > **交换次序：绿白绿与橙白橙**
  >
  > 绿了先A
  >
  > **交叉线接法：一端A一端B则可以用于，网卡连网卡；或交换机连交换机/hub，主机连路由器**
  >
  > **直通线接法**：两头都是b或a，**网卡与交换机\hub**

  ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243679.png)

- **光纤：由纤芯和包层组成，传输的光信号**在纤芯中传输，然而从PC端出来的信号都是电信号，经过光纤传输的话，就必须将电信号转换为光信号

- **多模光纤MMF：纤芯半径较大，因此可以同时传输多种不同的信号**，光信号在光纤中以全反射的形式传输，**采用发光二极管LED为光源，成本低，但是传输的效率和可靠性都较低，适合于短距离传输**，其传输距离与传输速率相关，速率为100Mbps时为2KM， 速率为1000Mbps时为550m

  ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243680.png)

- **单模光纤SMF：纤芯半径很小，一般只能传输一种信号，采用激光二极管LD作为光源，并且只支持激光信号的传播**，同样是以全反射形式传播，只不过反射角很大，看起来像一条直线，**成本高，但是传输距离远，可靠性高**。传输距离可达5KM。

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243681.png)



- 无线电波与红外光波：

  ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243682.png)

### 物理层互联设备

 物理层的互联设备有中继器（Repeater）和集线器（Hub）。
    **1**）中继器
    它是在物理层上实现局域网网段互联的，用于扩展局域网网段的长度**。由于中继器只在两个局域网网段间实现电气信号的恢复与整形，因此它仅用于连接相同的局域段。
    理论上说，可以用中继器把网络延长到任意长的传输距离，但是，局域网中接入的中继器的数量将受时延和衰耗的影响，因而必须加以限制。**中继器的主要优点是安装简便、**使用方便、价格便宜。**

​     **2**）集线器
​    可以看成是一种特殊的多路中继器，也具有**信号放大功能**。使用双绞线的以太网多用Hub扩大网络，同时也便于网络的维护。**以集线器为中心的网络优点是当网络系统中某条线路或某节点出现故障时，不会影响网上其他节点的正常工作。集线器可分为无源（passive）集线器、有源（active）集线器和智能（intelligent）集线器
​    无源集线器只负责把多段介质连接在一起，不对信号做任何处理，每一种介质段只允许展到最大有效距离的一半：有源集线器类似于无源集线器，但它具有对传输信号进行再生和放大从而扩展介质长度的功能；智能集线器除具有有源集线器的功能外，还可将网络的部分功能集成到集线器中，如网络管理、选择网络传输线路等

> **广播域与冲突域**
>
> **集线器**所有连接主机的端口组成一个**冲突域**，**集线器不可以起到自动寻址的作用**
>
> **交换机**所有连接主机的端口**各个形成一个冲突域**
>
> **路由器**所有连接主机的端口**各个形成一个冲突域**
>
> ![在这里插入图片描述](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243683.png)

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243684.png)

### 数据链路层的互联设备

数据链路层的互联设备有网桥（Bridge）和交换机（Switch）
    **1**）**网桥
    用于连接两个局域网网段，工作于数据链路层。**网桥要分析帧地址字段，以决定是否把收到的帧转发到另一个网络段上。确切地说，网桥工作于MAC子层，只要两个网络MAC子层以上的协议相同，都可以用网桥互联
    **2**）**交换机
    交换机是一个具有简化、低价、高性能和高端口密集特点的交换产品，它是按每一个包中的MAC地址相对简单地决策信息转发，而这种转发决策一般不考虑包中隐藏的更深的其他信息。**交换机转发数据的延退很小，操作接近单个局域网性能，远远超过了普通桥接的转发性能交换技术允许共享型和专用型的局域网段进行带宽调整，以减轻局域网之间信息流通出现的瓶颈问题。

**交换机的工作过程为：当交换机从某一节点收到一个以太网后，将立即在其内存中的地址表（端口号-MAC地址）进行查找，以确认该日的MAC的网卡连接在哪一个节点上，然后将该转发至该节点。如果在地址表中没有找到该MAC地址，也就是说，该日的MAC地址是首次出现，交换机就将数据包广播到所有节点。拥有该MAC地址的网卡在接收到该广播后，将立即做出应答，从而使交换机将其节点的“MAC地址”添加到MAC地址表中。**

> **交换机是一种多端口网桥，且各个端口形成一个广播域，但不是冲突域，集线器才组成冲突域**

​     交换机的三种交换技术：端口交换、交换和信元交换
​    （1）端口交换技术用于将以太模块的端口在背板的多个网段之间进行分配、平衡。
​    （2）交换技术对网络顿的处理方式分为直通交换和存储转发。其中，直通交换方式可提供线速处理能力，交换机只读出网络顿的前14个字节，便将网络顿传送到相应的端口上；存储转发方式通过对网络的读取进行验错和控制。
​    （3）信元交换技术采用长度（53个字节）固定的信元交换，由于长度固定，因而便于用硬件实现。

### 网络层互联设备

**路由器（Router）是网络层互联设备，用于连接多个逻辑上分开的网络。逻辑网络是指一个单独的网络或一个子网，当数据从一个子网传输到另一个子网时，可通过路由器来完成。**
       路由器具有很强的异种网互联能力，互联的网络最低两层协议可以互不相同，通过驱动软件接口到第三层上而得到统一。对于互联网络的第三层协议，如果相同，可使用单协议路由器进行互联：如果不同，则应使用多协议路由器。多协议路由器同时支持多种不同的网络层协议，并可以设置为允许或禁止某些特定的协议。所谓支持多种协议，是指支持多种协议的路由，而不是指不同类协议的相互转换。
      **通常把网络层地址信息叫作网络逻辑地址，把数据链路层地址信息叫作物理地址**。**路由器最主要的功能是选择路径。在路由器的存储器中维护着一个路径表，记录各个网络的逻辑地址用于识别其他网络。**在互联网络中，当路由器收到从一个网络向另一个网络发送的信息包时，将丢弃信息包的外层，解读信息包中的数据，获得目的网络的逻辑地址，使用复杂的程序来决定信息经由哪条路径发送最合适，然后重新打包并转发出去。路由器的功能还包括过滤、存储转发、流量管理和介质转换等。一些增强功能的路由器还可有加密、数据压缩、优先和容错管理等功能。由于路由器工作于网络层，它处理的信息量比网桥要多，因而处理速度比网桥慢。

### 应用层互联设备

​    **网关（Gateway）是应用层的互联设备。在一个计算机网络中，当连接不同类型而协议差别又较大的网络时，则要选用网关设备。**网关的功能体现在OSI模型的最高层，它将协议进行转换，将数据重新分组，以便在两个不同类型的网络系统之间进行通信。由于协议转换是一件复杂的事，一般来说，**网关只进行一对一转换**，或是少数几种特定应用协议的转换，网关很难实现通用的协议转换

## 网络的协议与标准

### 局域网和广域网协议

- **以太网规范IEEE802.3是重要的局域网协议（电气电子工程师学会IEEE的英文全称是**the Institute of Electrical and Electronics Engineers**）**，包括：

  IEEE802.3     标准以太网    10Mb/s     传输介质为细同轴电缆

  **IEEE802.3u    快速以太网     100Mb/s    双绞线**

  IEEE802.3z    千兆以太网    1000Mb/s   光纤或双绞线

  EEE802.3ae   万兆以太网    10Gb/s      光纤

- **无线局域网WLAN技术标准：IEEE802.11**

- **广域网协议**包括： PPP**(Point-to-Point Protocol，如拨号上网)**点对点协议、ISDN综合业务数字网、XDSL、DSL数字用户线路的统称：HDSL、SDSL、MVL、ADSL）、DDN（Digital Data Network）数字专线、X.25、FR中继、ATM异步传输模式

### TCP/IP协议（四层模型）

> **传输控制协议**（英语：**T**ransmission **C**ontrol **P**rotocol）
>
> **Internet Protocol**（ 网际互连协议 ）

**网络协议三要素：语法、语义、时序**。其中**语法部分规定传输数据的格式，语义部分规定所要完成的功能，时序部分规定执行各种操作的条件、顺序关系等**

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243685.png)

<img src="https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243686.png" style="zoom:70%;" />

TCP协议与OSI模型的对应关系：

| OSI              | TCP        |
| ---------------- | ---------- |
| **1.物理层**     | 网络接口层 |
| **2.数据链路层** |            |
| **3.网络层**     | 网际层     |
| **4.传输层**     | 运输层     |
| 5.会话层         | 应用层     |
| 6.表示层         |            |
| **7.应用层**     |            |

**TCP与UDP：**

> **用户数据报协议（UDP，User Datagram Protocol）**
>
> **动态主机配置协议(Dynamic Host Configuration Protocol)**

| TCP                      | UDP             |
| ------------------------ | --------------- |
| **ftp（20、21）**        | **tftp（69）**  |
| **pop3（110）**          | **dns（53）**   |
| **http（80）**           | **dhcp（67）**  |
| **smtp（25）、发送邮件** | **snmp（161）** |
| telnet（23）             | VOIP            |

> **iP电话（VoIP）**是一种基于传输层中用户数据报协议（**UDP**）所提供服务的应用层协议。

### 各层协议

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243687.png)

#### 网络层协议

- **IP：网络层最重要的核心协议，在源地址和目的地址之间传送数据报，无连接、不可靠。**

- **ICMP(Internet Control Message Protocol)：因特网控制报文协议，用于在IP主机、路由器之间传递控制消息**。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。

- **ARP(Address Resolution Protocol)**和**R**ARP(**Reverse** Address Resolution Protocol)：地址解析协议，**ARP是将IP地址转换为物理地址**

- **RARP是将物理地址转换为IP地址**。

- IGMP(Internet **Group** Management Protocol)：网络组管理协议，允许因特网中的计算机参加多播，是计算机用做向相邻多目路由器报告多目组成员的协议，支持组播

- **IPsec(Internet Protocal Security）：互联网安全协议，是保护IP协议的网络传输协议簇**

  > ipsec属于第三层vpn协议

#### 传输层协议

-  TCP：整个TCP/IP协议族中最重要的协议之一，在IP协议提供的不可靠数据数据基础上，采用了重发技术，**为应用程序提供了一个可靠的、面向连接的、全双工的数据传输服务。一般用于传输数据量比较少，且对可靠性要求高的场合。**

  > 建立连接：三次握手，源主机发送一个，目标主机愿意通信，源主机确认相应目标主机的TCP包
  >
  > 断开连接：四次挥手，

- **UDP：是一种不可靠、无连接的协议，有助于提高传输速率，一般用于传输数据量大**，对可靠性要求不高，但要求速度快的场合

-  **SSH（secure shell protocal）：安全外壳协议，为远程登录会话提供安全**

#### 应用层协议

基于TCP的FTP、HTTP等都是可靠传输。基于UDP的DHCP、DNS等都是不可靠传输。

> TCP

- **FTP（FileTransferProtocol，FTP）：文件传输协议，用于因特网上的控制文件的双向传输**

  ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243688.png)

  **匿名FTP用户名是anonymous，密码通常是guest或者使用者E-mail地址。出于安全目的，多数名FTP服务器不允许上传、修改和删除操作。**数据不加密

   FTP在客户端与服务器内部建立两条TCP连接：

  （1）**21**端口负责控制连接，主要用于**传输命令和参数**

    (2）**20**端口负责数据连接，主要用于**传送文件**

  > 注意：推荐使用被动模式，在同一局域网内可以使用主动模式
  >
  > 1安全性：客户端通常配置本地防火墙，服务器20端口很难连接到指定端口
  > 2.连通性：NAT网络时需配置局域网端口映射

- **SFTP**（SSH File Transfer Protocol， 也称SecretFileTransferProtocol）：**SFTP是基于网络协议SSH（安全外壳）的协议**。数据加密

- **FTPS**：FTPS是在FTP协议上**增加了SSL协议**。FTPS是为FTP添加传输层安全CTLS和安全套接层SSL加密协议支持的扩展协议

  > sftp>ftps

- **TFTP**（TrivialFileTransferProtocol）：简单文件传输协议， 是TCP/IP协议族中，**基于UDP协议**用来在客户端与服务端之间简单文件传输的协议，提供不复杂、开销不天的文件传输服务。端口号为69。

- **HTTP：超文本传输协议，用于从WWW服务器传输超文本到本地浏览器的传输协议。使用SSL加密后的安全网页协议为HTTPS。**

  > ssh：secure shell，终端设备与远程站点之间建立安全连接的协议

-  **SHTTP（Secure HyperText ) ：安全超文本转换协，shttp和https区别：shttp以http 加密数据；https全程加密；**

-  **PGP、MOSS、PEM、MIME：邮件的应用**

- **SMTP（发送邮件应用）和POP3：简单邮件传输协议，是一组用于由源地址到的地址传送邮件的规则，邮件报文采用ASCII格式表示。**

-  **Telnet：远程连接协议，是因特网远程登录服务的标准协议和主要方式**

-  Kerberos：网络安全授权协议，对个人通信以安全手段进行身份认证。UDP

- **SNMP：简单网络管理协议**，由一组网络管理的标准协议，包含一个应用层协议、数据库模型和一组资源对象。该协议能够支持网络管理系统，泳衣监测连接到网络上的设备是否有任何引起管理师行关注的情况。

  > **管理站和代理站必须具有相同的团体名才能互相通信**：
  >
  > ![image-20240324164654665](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243689.png)

- DHCP：动态主机配置协议，基于UDP，基于C/S模型，为主机动态分配IP地址，有三种方式

  固定分配、动态分配、自动分配

  > 动态ip地址协议

-  DNS：域名解析协议，通过域名解析出IP地址

#### 会话层

- Socks（protocal for sessions traversal across firewall securely）：防火墙安全会话转换协议，是应用程序透明的穿过网络防火墙
- Kerberos：网络安全授权协议，对个人通信以安全手段进行身份认证

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243690.PNG)

#### 协议端口号对照表

| 端口   | 服务                               | 端口    | 服务                             |
| ------ | ---------------------------------- | ------- | -------------------------------- |
| **20** | **文件传输协议（数据），ftp**      | **80**  | **超文本传输协议（http）**       |
| **21** | **文件传输协议（控制），ftp**      | **110** | **POP3服务器（邮箱接受服务器）** |
| **23** | **Telnet终端仿真协议（远程连接）** | 69      | 简单文件传输协议（Tftp）         |
| **67** | **DHCP（服务端）**                 | **68**  | **DHCP（客户端）**               |
| **25** | **SMTP简单邮件发送协议**           | **161** | **SNMP（轮询）**                 |
| **53** | **域名服务器（DNS）**              | **162** | **SNMP（陷阱)**                  |
| 22     | sftp                               |         |                                  |

> **简单邮件传输协议(Simple Mail Transfer Protocol)**
>
> **简单网络管理协议(Simple Network Management Protocol)**
>
> **动态主机配置协议(Dynamic Host Configuration Protocol)**
>
> **域名系统(Domain Name System)**
>
> **文件传输协议(File Transfer Protocol)**

## internet基础知识

### 通信方式和交换方式

设备与网关之间要处于用一个子网才能进行互通

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243691.png)

- **通信方向**
  
  - **单工总线：只能在一个方向上传输信息**
  - **半双工总线：可以在两个方向上传输信息，但同一时刻，只能一个方向**
  - **全双工总线：可以同时在不同方向传输信息**
  
- **同步方式**
  - **异步传输**：发送方每发送一个字符，需要**约定一个起始位和停止位**插入到字符的起始和结尾处这样当接收方接收到该字符时能够识别，但是这样会造成资源浪费，**传输效率降低**
  - **同步传输：以数据块为单位进行传输，当发送方要发送数据时，先发送一个同步顿**，接收方收到后做好接收准备，开始接收数据块，结束后又会有结束确认，这样一次传输一个数据块，**效率高**。
  - **串行传输：一次只能1位1位的发送，适合长距离，速度慢，价格低**
  - **并行传输：1此能n位n位的发送，适合短距离，速度快，价格高**
  
- 3g通信标准

  TD-SCDMA



### ip地址表示

机器中存放的**IP地址是32位的二进制代码，每隔8位**插入一个空格，可提高可读性，为了便于理解和设置，一般会采用**点分十进制**方法来表示：将32位二进制代码**每8位二进制转换成十进制，就变成了4个十进制数**，而后在每个十进制数间隔中插入，如下所示，最终为128.11.3.31

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243692.png)

因为每个十进制数都是由8个二进制数转换而来，因此**每个十进制数的取值范围为1-254**（掌握二进制转十进制的快速计算方法， 牢记2的幕指数值，实现快速转换）

> 255是广播地址，专门用于向网络中所有工作站进行发送的一个地址。例如网关的主机位部分就是255，同时子网掩码也可以达到255。只有ip不能取255

#### 分类ip

- **分类IP地址**：IP地址分四段，每段八位，共32位二进制数组成
  在逻辑上，这32位P地址分为**网络号和主机号**，依据网络号位数的不同，可以将P地址分为以下几类：
  
  > **如何判断ip地址是否是同一个网段的？**
  >
  > **同一个网段的ip的网络号必须相同，比如说无分类ip/20，那么只需看前20位的二进制网络号是否相同就可以**
  >
  > 
|  类别  | 点分十进制表示           | 最小地址           | 最大地址             |
|-------|------------------------|-------------------|---------------------|
| **A类** | **0.0.0.0 - 127.255.255.255** | <u>**0**0000000</u>.00000000.00000000.00000000 | <u>**0**1111111</u>.11111111.11111111.11111111 |
| **B类** | **128.0.0.0 - 191.255.255.255** | <u>**10**000000.00000000</u>.00000000.00000000 | <u>**10**111111.11111111</u>.11111111.11111111 |
| **C类** | **192.0.0.0 - 223.255.255.255** | <u>**110**00000.00000000.00000000</u>.00000000 | <u>**110**11111.11111111.11111111</u>.11111111 |
| D类组播 | 224.0.0.0 - 239.255.255.255 | **1110**0000.00000000.00000000.00000000 | 11101111.11111111.11111111.11111111 |
| E类保留 | 240.0.0.0 - 255.255.255.255 | **11110**000.00000000.00000000.00000000 | 11111111.11111111.11111111.11111111 |

> **A类前缀必须是0开头**，最多可以有2^24-2个主机
>
> **B类前缀必须是10开头**，最多可以有2^16-2个主机
>
> **C类前缀必须是110开头**，最多可以有2^8-2个主机
>
> ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243693.png)
>
> **注：主机地址数量都需要-2**
>
> **组播协议应用有VOD、Netmeeting、cscw**

#### 无分类ip

- **无分类编址**：即不按照ABC类规则，自动规定网络号，**无分类编址格式为：IP地址/网络号**，示例：128.168.0.11/20表示的IP地址为128.168.0.11，其**网络号占20位，因此主机号占32-20=12位，也可以划分子网**。

  > **/后面表示的是网络号**

#### 私有ip

- 特殊IP地址
  **公有地址：通过它直接访问因特网。是全网唯一的IP地址。**
  **私有地址：属于非注册地址，专门为组织机构内部使用**，不能直接访问因特网，下表所示为私有地址范

  > 如果私有地址要上网则要通过nat协议 

  | 类别  | ip地址范围                      | 网络号                | 网络数 |
  | ----- | ------------------------------- | --------------------- | ------ |
  | A     | **10.0.0.0~10.255.255.255**     | 10                    | 1      |
  | **B** | **172.16.0.0~172.31.255.255**   | 172.16~172.31         | 16     |
  | **C** | **192.168.0.0~192.168.255.255** | 192.168.0~192.168.255 | 256    |

  特殊地址如下图：

  | 网络号  | 主机号         | 源地址使用 | 目的地址使用 | 代表的意思                      | 例子           |
  | ------- | -------------- | ---------- | ------------ | ------------------------------- | -------------- |
  |         | 0              | 可以       | 不可         | 在本网络上的本主机              | 192.168.0.0/24 |
  |         | 全1            | 不可       | 可以         | 在本网络上进行广播              | 192.168.1.1/16 |
  | net-ID  | 全1            | 不可       | 可以         | 对net-ID上的所有主机进行广播    |                |
  | 127     | 非全0或全1的数 | 可以       | 可以         | 用作本地软件环回测试之用        | 127.0.0.1      |
  | 169.254 | 非全0或全1的数 | 可以       | 可以         | Windows主机**DHCP服务器故分配** | 169.254.0.0/16 |

### 域名

域名（**DomainName**）通常是用户所在的主机名字或地址。域名格式是由若干部分组成的每个部分又称子域名，它们之间用“.”分开，**每个部分最少由两个字母或数字组成**。域名通常按分层结构来构造，每个子域名都有其特定的含义。通常情况，一个完整、通用的层次型主机域名由如下4部分组成：
     **计算机主机名.本地名.组名.最高层域名**
    从右到左，子域名分别表示不同的国家或地区的名称（只有美国可以省略表示国家的顶级域名）、组织类型、组织名称、分组织名称和计算机名称等。域名地址的最后一部分子域名称为高层域名（或顶级域名），它大致可以分成两类：一类是组织性顶级域名：另一类是地理性顶级域名。

### 子网划分

- 子网划分：一般公司在申请网络时，会直接获得一个范围很大的网络，如一个B类地址，因为**主机数之间相差的太大了，不利于分配，我们一般采用子网划分的方法来划分网络，即自定义网络号位数**，就能自定义主机号位数，就能**根据主机个数来划分出最适合的方案，不会造成资源的浪费。**

- 因此就有子网的概念，一般的IP地址按标准划分为ABC类后，可以进行再一步的划分，**将主机号拿出几位作为子网号**，就可以划分出多个子网，此时IP地址组成为：**网络号+子网号+主机号**

  > **无分类ip后面 /x 的位数由网络号和子网号组成，32-x就是主机号**

- **网络号和子网号都为1，主机号都为0，这样的地址为子网掩码**。

  > 如255.255.255.0；**子网掩码不等同于子网地址**
  >
  > 要注意的是：**子网号可以为全0和全1，主机号不能为全0或全1，因此，主机数需要-2，而子网总个数不用-2，就是2^n个**

- 还可以**聚合网络为超网**，就是划分子网的逆过程，**将网络号取出几位作为主机号**，此时，这个网络内的主机数量就变多了，成为一个更大的网络。

![image-20240322201302483](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243694.png)

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243695.png)

> **子网个数的计算：2^(新划分的网络号-原网络号)^**

### IPv6

- 主要是为了解决IPv4地址数不够用的情况而提出的设计方案，IPv6具有以下特性：
-  **IPv6地址长度为128位**，地址空间**增大了2^96倍**；
- 灵活的IP报文头部格式，使用一系列固定格式的扩展头部取代了IPV4中可变长度的选项字段。IPv6中选项部分的出现方式也有所变化，使路由器可以简单播过选项而不做任何处理，加快了报文处理速度；IPv6简化了报文头部格式，加快报文转发，提高了吞吐量；
- 提高安全性，身份认证和隐私权是IPv6的关键特性；
- 支持更多的服务类型
- 允许协议继续演变，增加新的功能，使之适应未来技术的发展
-  **IPv4和IPv6的过渡期间，主要采用三种基本技术**

（1）双协议栈：主机同时运行IPv4和IPv6**两套协议栈**，同时支持两套协议，一般来说IPv4和IPv6地址之间存在某种转换关系，如**IPv6的低32位可以直接转换为IPv4地址**，实现互相通信。
（2）**隧道技术：这种机制用来在IPv4网络之上建立一条能够传输IP6数据报的隧道**，例如可以**将IPv6数据报当做IPv4数据报的数据部分加以封装**，只需要加一个IPv4的首部，就能在IP4网络中传输IPv6报
文。
（3）**翻译技术：利用一台专门的翻译设备（如转换网关），在纯IPV4和纯IPV6网络之间转换IP报头的地址**，同时根据协议不同对分组做相应的语义翻译，从而使纯IPV4和纯IPV6站点之间能够透明通信

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243696.png)

### NAT技术

​	因特网面临IP地址短缺的问题。这个问题有所谓长期的或短期的两种解决方案。长期的解决方案就是使用具有更大地址空间的IPv6协议，**网络地址翻译（NetworkAddressTranslatorsNAT）是许多短期的解决方案中的一种**
​    NAT技术最初提出的建议是在子网内部使用局部地址，而在子网外部使用少量的全局地址，通过路由器进行内部和外部地址的转换。**NAT的实现主要有两种形式。**
​    **第一种应用是动态地址翻译（DynamicAddressTranslation）**。为此，首先引入存根域的概念。所谓存根域（ShibDomain），就是内部网络的抽象，这样的网络只处理源和目标都在子网内部的通信。任何时候存根域内只有一部分主机要与外界通信，甚至还有许多主机可能从不与外界通信，所以整个存根域只需共享少量的全局IP地址。存根域有一个边界路由器，由它来处理域内与外部的通信。

### DNS

- **DNS的解析顺序：**

  **本地host文件->本地DNS缓存->本地DNS服务器->根域名服务器**

- **DNS的查询顺序：**

  **本地缓存->本地DNS服务器->服务器的缓存->根域名DNS服务器**

- DNS负载均衡：

**DNS负载均衡是通过启动循环，添加每个web服务器的主机记录来实现的**

![image-20240322200102499](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243697.png)

> DNS故障问题：
>
> - 本地的DNS服务器**工作不正常**
> - 本地DNS服务器**网络连接中断**
> - 直接将该计算机的DNS服务器**设置错误**也会导致DNS无法解析域名，从而出现使用域名不能访问该网站，但是使用该网站的IP地址可以访问该网站。
>
> 但是该计算机与DNS服务器不在同一子网不会导致DNS无法解析域名的现象发生，通常情况下大型网络里面的上网计算机与DNS服务器本易就不在一个子网，只要路由可达DNS都可以正常工作

### 动态地址分配

即DHCP

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243698.png)

### ping命令

 判断用户与外部站点的连通性，

1. ping（本地循环地址），**无法ping则说明本机TCP/IP协议不能正常工作，**
2. **ping+本机IP不通则说明网络适配器（网卡/MODEM）出现故障**
3. **ping+同一网段计算机的IP不通则说明网络线路出现故障**；
4. **netstat命令：用于显示TCP、UDP、IP、ICMP协议相关统计数据，一般用于检验本机网络端口的连接情况**；
5. **ARP命令：可以查看和修改本地计算机的ARP表项，和查看ARP缓存和解决地址解析问题非常使用。**
6. **Tracert命令：可以跟踪网络连接**，Tracert（路由跟踪）是路由跟踪程序，用于确定IP数据报访问目标所采取的路径，可以查看哪段路由出现连接问题。

## 网络安全概述

![image-20240322093453246](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243699.png)

### 网络安全威胁

-  一般认为，目前网络存在的威主要表现在以下5个方面：

  ​    （1）**非授权访问**：没有预先经过同意，就使用网络或计算机资源则被看作非授权访问，如有意避开系统访问控制机制，对网络设备及资源进行非正常使用，或擅自扩大权限，越权访问信息。它主要有以下几种形式：假冒、身份攻击、非法用户进入网络系统进行违法操作、合法用户以未授权方式进行操作等。

  ​    （2）**信息泄露**或丢失：指敏感数据在有意或无意中被泄露出去或丢失，它通常包括信息在传输中丢失或泄露、信息在存储介质中丢失或泄露以及通过建立隐蔽隧道等窃取敏感信息等如黑客利用电磁泄露或搭线窃听等方式可截获机密信息，或通过对信息流向、流量、通信频度和长度等参数的分析，推测出有用信息，如用户口令、账号等重要信息。

  ​    （3）**破坏数据完整性**：以非法手段得对数据的使用权，删除、修改、插入或重发某些重要信息，以取得有益于攻击者的响应：恶意添加，修改数据，以干扰用户的正常使用

  ​    （4）**拒绝服务攻击**：它不断对网络服务系统进行干扰，改变其正常的作业流程，执行无关

  程序使系统响应减慢甚至换，影响正常用户的使用，甚至使合法用户被排而不能进入计算机网络系统或不能得到相应的服务。

  ​    （5）**利用网络传播病毒**：通过网络传播计算机病毒，其破坏性大大高于单机系统，而且用户很难防范

- **计算机网络面临以下的四种威胁：截获（interception），中断（interruption），算改（modification），伪造（fabrication）。**
   （1）**重放攻击**：攻击者发送一个目的主机已接收过的包，达到欺骗系统的目的，主要用于身份认证过程
   （2）**拒绝服务**：攻击者向因特网上的服务器不停地发送大量分组，使因特网或服务器无法提供正常服务
  （3）**访问控制**：也叫做存取控制或接入控制。必须对接入络的权限加以控制，并规定每个用户的接入权限
   （4）**流量分析**：通过观察PDU的协议控制信息部分，了解正在通信的协议实体的地址和身份，研究PDU的长度和传输的频度，以便了解所交换的数据的某种性质
  （5）**恶意程序**：恶意程序（rogueprogram）通常是指带有攻击意图所编写的一段程序

![image-20240324165005289](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243700.png)

> **防御技术**
>
> **蜜罐技术是一种主动防御技术**，是入侵检测技术的一个重要发展方向。
> **蜜罐是一种在互联网上运行的计算机系统，是专门为吸引并透骗那些试图非法间入他人计算机系统的人而设计的。蜜罐系统是一个包含漏洞的诱骗系统**，它通过摸拟一个或多个易受攻击的主机和服务，给攻击者提供一个容易攻击的目标。
> 由于蜜罐并没有向外界提供真正有价值的服务，因此**所有试图与其进行连接的行为均可认为是可疑的。**

### 防火墙技术

​	防火墙（Firewall）是建立在**内外**网络边界上的过滤封锁机制，它认为内部网络是安全和可信赖的，而**外部网络**是不安全和不可信赖的。防火墙的作用是防止不希望的、未经授权地进出被保护的内部网络，通过边界控制强化内部网络的安全策略。

​	防火墙技术经理了**包过滤、应用代理网关和状态检测技术**三个发展阶段：

*   **VPN技术：通过隧道将两个内部网络通过公共网络进行连接使其成为一个总体网络。**
*   **防火墙技术：包过滤防火墙（屏蔽路由器）**：将**路由器放置于内部网络中，网络层安全**。
*   **应用代理防火墙：也就是双宿主机防火墙，应用层安全**。
*   **状态检测技术防火墙：以上两种技术的综合，屏蔽路由器置于外部网络，双宿主机置于内部网络。**
*   **屏蔽子网防火墙：设置DMZ（非军事区）由屏蔽路由器置于内部网络和双宿主机构成。**

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243702.png)

![image-20240324162628031](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243703.png)

包过滤防火墙和代理服务防火墙的叙述：**包过滤技术对应用和用户是透明的**

![image-20240322200220521](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243704.png)

### 入侵检测与防御

   入侵检测系统（Imtusion Detection System，**IDS**）作为防火墙之后的第二道安全屏障，通过从计算机系统或网络中的若干关键点收集网络的安全日志、用户的行为、网络数据包和审计
记录等信息并对其进行分析，从中检查是否有违反安全策略的行为和遭到入侵攻击的迹象，入
侵检测系统根据检测结果，自动做出响应。IDS的主要功能包括对用户和系统行为的监测与分析、系统安全漏洞的检查和扫描、重要文件的完整性评估、已知攻击行为的识别、异常行为模式的统计分析、操作系统的审计跟踪，以及违反安全策略的用户行为的检测等。入侵检测通过实时地监控入侵事件，在造成系统损坏或数据丢失之前阻止入侵者进一步的行动，使系统能尽可能地保持正常工作。与此同时，IDS还需要收集有关入侵的技术资料，用于改进和增强系统抵抗入侵的能力。
    入侵检测系统有效地弥补了防火墙系统对网络上的入侵行为无法识别和检测的不足，入侵检测系统的部署，使得在网络上的入侵行为得到了较好的检测和识别，并能够进行及时的报警然而，随着网络技术的不断发展，网络攻击类型和方式也在发生着巨大的变化，入侵检测系统
也地暴露出如漏报、误报率高、灵活性差和入侵响应能力较弱等不足之处

**被动攻击的概念：只拿数据，不修改、破坏数据**

**主动攻击的概念：将干扰通讯或导致信息传输不正确。**

> **攻击行为**
>
> 1. **DDOS（Distributed Denial of Service分布式阻断服务）：黑客利用DDOS攻击器控制多台机器同时攻击来达到“碍正常使用者使用服务”的目的。**
>
>    ![image-20240324164513426](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243705.png)
>
> 2. **TCP会话动持：是劫持通信双方已建立的TCP会话连接，假冒其中一方（通常是客户端）的身份，与另一方进行进一步通信。**
>
> 3. **SQL注入：是一种类型的SQL注入攻击，询问数据库真或假的问题，并确定基于该应用程序的响应的答复**。
>
>    > **SQL注入防范措施有**
>    > 1、通过**正则表达**校验用户输入
>    > 2、通过**参数化存储过程**进行数据查询存取
>    > 3、**参数化SQL语句**
>    > 4、采用**预编译语句集**
>    > 5、**字符串过滤**
>    > 6、使用**安全函数**
>
> 4. **ARP欺骗攻击：是针对以太网地址解析协议（ARP）的一种攻击技术。由攻击者发送假的ARP数据包到网上，其目的是要让送至特定的IP地址的流量被错误送到攻击者所取代的地方**
>
> 5. **重放攻击：攻击者发送一个目标主机已接受过的包，来达到欺骗系统的目的，主要用于身份认证过程**

### 恶意代码（病毒）

> 恶意代码（MaliciousCode）：违背目标系统安全策略的程序代码

| 传播             | 种类                                         | 说明                                                         | 特征&类型                                                    | 备注                                                         |
| ---------------- | -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **被动（触发）** | **计算机病毒Computer Virus**     **复制**    | 一组具有**自我复制、传播能力**的程序代码，有**宿主**         | ①**隐性**：附加在正常软件或文档中<br/>②**传染性：能进行自我复制**（区别普通程序）<br/>③**潜伏性：触发条件满足才执行**（如某日）  <br/>④破坏性：危害程度取决于设计者<br/> | 文档：Melissa（梅丽莎）病毒<br/>邮件：爱虫病毒、求职信病毒<br/>照片：库尔尼科娃<br/>网页：NIMDA病毒 |
|                  |                                              |                                                              | ①引导型病毒：磁盘杀手病毒、AntiExe病毒<br/>②**宏病毒：word宏病毒（批量处理程序命令）**<br/>③多态病毒：逃避静态特征扫描，需启发式杀毒<br/>④隐藏病毒：隐藏文件大小和时间、加密等 | ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243706.png) |
|                  | **特洛伊木马Trojan Horse**          **潜伏** | **具有伪装能力、隐执行非法功能的恶意程序<br/>需要宿主**      | ①**本地**特洛伊木马：只运行在本地，**盗用多用户口令，修改复制整个硬盘资料，达到控制计算机的目的**<br/>②**网络**特洛伊木马：**远程木马控制端+木马肉鸡** | 红色代码、广外女生、冰河、Rootkit、Netspy、YAI、SubSeven、Netbus、Back Office、sniffer |
|                  |                                              |                                                              | ①文件绑法：将**木马绑到常用软件包**中<br/>②邮件附件：将木马程序伪装成邮件附件<br/>③Web网页：**木马程序隐藏在html文件中** |                                                              |
|                  | 间谋软件<br/> Spyware<br/>**刺探**           | 在用户不知情时被安装的软件，执行用户非期望的功能             | 弹出广告、浏览器重定向、记录击键、浏览习惯、窃取用户隐私     | 2345浏览器、2345压缩软件；驱动精灵、驱动人生弹广告、360等    |
|                  | 间谋软件<br/> Spyware<br/>**刺探**           | 依附在其他软件中，具有触发执行破坏能力的程序代码             | 计数器触发、时问触发、文件触发、特定用户访问触发等           | 若管理员一个月没有登录系统，则清除服务器数据                 |
| **主动**         | 陷门（非授权访问）**特权**                   | 允许用户开系统安全机制而访问系统的代码                       | 软件开发商为调试和维护系统而设定的功能                       | 若允许特定用户识别码登录系统                                 |
|                  | **网络蠕虫**Worms<br/>**传播**               | 具有自我复制和传播能力、可**独立自动运行**的恶意程序         | 通过有漏洞的网络主机节点传播<br/>①随机扫描：IP段随机扫描（Slammer虫）<br/>②顺序扫描：所在网段扫描（W32.Blaster）<br/>③选择性扫描：有选择性去扫描感染目标主机（病毒发展方向）<br/> | **WannaCry勒索病毒**、震荡波、Nimda、worm.、**熊猫烧香**     |
|                  | **僵尸网络**（Botnets）**傀儡**              | 攻击者将户程序植入目标主机，进而操控受害机执行恶意活动的网络 | 构建方式：远程漏洞攻击；弱口令扫描入侵；邮件附件；恶意文档；文件共享；<br/>早期：类蟠虫病毒主动扫描+**远程**漏洞攻击<br/>目前：网页挂马（主流）<br/> |                                                              |
|                  | 细菌（**消耗**）                             | 具有**自我复制**功能的独立程序                               | 通过复制本身来消耗系统CPU、内存和磁盘资源                    |                                                              |

> - **普通病毒与蠕虫病毒区别**
>
>   1、普通病毒需要寄生到其他程序（宿主）内部；而虫是一种独立智能程序，不需要附着宿主，通过复制自身传播
>   2、普通病毒主要感染文件系统，蟠虫病毒目标是感染互联网上所有计算机
>
> - **僵尸网络与蠕虫病毒区别**
>
>   僵尸网络拥有同意的高度可控的系统，且僵尸网络追求规模，需要认为控制。而蠕虫病毒是自发性的，不需要人为的参与，且蠕虫病毒的目标是感染所有数字签名

![image-20240324164817579](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243707.png)

### 计算机安全等级

| 安全级别 | 定义                                                         |
| -------- | ------------------------------------------------------------ |
| A1       | 可验证安全设计。提供B3级保护，同时给出系统的形式化隐秘通道分析，非形式化代码一致性验证<br/> |
| B3       | 安全域。该级的TCB必须满足访问监控器的要求，提供系统恢复过程  |
| B2       | 结构化安全保护。建立形式化的安全策略模型，并对系统内的所有主体和客体实施自主访问和强制访问控制<br/> |
| B1       | 标记安全保护。对系统的数据加以标记，并对标记的主体和客体实施强制存取控制<br/> |
| C2       | 受控访问控制。实际上是安全产品的最低档次，提供受控的存取保护，存取控制以用户为单位<br/> |
| C1       | 只提供了非常初级的自主安全保护，能实现对用户和数据的分离，进行自主存取控制，数据的保护以用户组为单位<br/> |
| **D1**   | **最低级别，保护措施很小，没有安全功能**                     |

### 计算机安全十大原则

1. **机制的经济性**：着重强调在设计和实现安全措施时的简洁性
2. **故障安全默认配置**：所设计系统的默认配置应该具有保守的安全机制
3. **完备调停**：对于资源的每次访问必须检查以确保不违背安全机制
4. **开放设计：系统设计和安全体系结构应该公开，安全仅依赖于对的保密**
5. **特权分离**：为了访问受限资源或者让程序执行某些操作，多个条件需要被同时满足最小特权：要求每个用户和程序在操作时应当使用尽可能少的特权
6. **最少公共机制**：在多用户系统中，允许多个用户共享资源的机制应该最小化
7. **心理可接受性**：用户接口应该精心设计且非常直观，所有与安全相关的设置都按普通用户的期望进行配置
8. **工作因素**：在设计安全方案时，**绕过安全机制的代价应与攻击者的资源做对比**
9. **危害记录**：有时候**记录入侵细节比采用更复杂的措施来预防入侵更为理想**

### 信息安全

- [信息安全](#信息安全)

### 加密技术

- [加密技术](#加密技术)

# 数据库基础

## 基本概念

**DBMS的分类**

- 关系数据库系统RDBS

  有oracle、db2、sybase、microsof sql server、Microsoft access、mysql

- 面向对象的数据库系统OODBS

  包括对对象类、类属性、继承和子类的支持

  特点：能够表达数据见的嵌套、递归关系；具有面向对象技术的封装性和继承性

- 对象关系数据库系统ORDBS。

> **DBMS特点**
>
> 1. **数据结构化**
> 2. **数据的共享性高，冗余度低，易扩充**
> 3. **数据独立性高**
> 4. **数据又DBMS统一管理和控制**
> 5. **负责数据库的运行和维护**



- **数据库系统DBS：是计算机系统中引入数据库后的系统构成**。

  > 注意区分DB和DBMS
  >
  > **数据库技术**是负责研究数据库各方面的一门软件**学科**；**数据库管理系统**是一个管理的应用**软件**
  >
  > DBS是在先有了操作系统如Windows后将数据库引入的，而不是数据库进行管理的系统。一般就是别的操作系统＋数据库数据这些

- **数据库库系统的构成：数据库；硬件平台；软件（应用程序）；数据库管理员**。数据库系统的设计目标是允许用户逻辑的处理数据，而不必涉及这些数据在计算机中是怎样存放的，在数据组织和用户应用之间提供某种程度的独立性。

  

  **数据库系统的体系结构：**

- **集中式数据库系统（所有东西集中在DBMS电脑上）**

- **客户端/服务器体系结构（客户端负责请求和数据表示，服务器负责数据库服务）并行数据库系统（多个物理上在一起的CPU）**

  > CS与OS

- **分布式数据库系统（物理上分布在不同地方的计算机）**

### 三级模式

- **内模式（存储模式）：管理如何存储物理的数据**；是数据物理结构和存储方式的描述是数据在数据库内部的表示方法；**一个数据库只有一个内模式**。

  > 内模式就相当于是表里面的原始**数据（存储文件）**，是**物理模式**，因此只有一个
  >
  > **添加索引会改变数据库的内模式**

- **概念模式（模式、逻辑模式）**：就是我们通常使用的**表这个级别**；是数据库中全体数据的逻辑结构和特征的描述；是所有用户的公共数据视图，综合了所有用户的需求个数据库只有一个模式。

  > 概念模式就相当于是一个**表**，是**逻辑模式**，因此只有一个

- **外模式（子模式、用户模式）**：对应数据库中的**视图这个级别**；是数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述；数据库用户的数据视图，是与某一应用有关的数据的逻辑表示

  > 外模式相当于是很多个给用户看的**视图**表。**用户**方面的，相当于看到了概念模式表所创建的视图，无法修改表的结构，但可能可以修改表中的数据

- **外模式的地位：介于模式与应用之间，可以有多个外模式，通常是模式的子集**；反映了不同的用户的应用需求。

- **外模式的用途：保证数据库安全性的一个有力措施，每个用户只能看见和访问所对应的外模式中的数据。**

> **总的来说就是：外模式对应应用和用户**、概念模式对应逻辑、内模式对应物理

### 两级映像

> **从上往下的，从外模式到概念模式到内模式**

- **外模式一概念模式映像：当模式（表）改变时（如增加新的关系、新的属性、改变属性的数据类型等），由数据库管理员对各个外模式/模式的映像作相应改变，可以使外模式保持不变。**

  > **应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性**。

- **概念模式一内模式映像：模式/内模式映像是唯一的，它定义了数据库全局逻辑结构与存储结构之间的对应关系。**

  > 当数据库的内模式存储结构改变了（如选用了另一种存储结构），由数据库管理员对模式/内模式映像作相应改变，可以使模式保持不变，从而应用程序也不必改变，保证了数据与程序的物理独立性，简称**数据的物理独立性**

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243708.png)

### 三个级别

以上的数据库系统实际上是一个分层次的设计，可分为如下三级数据库

- **用户级数据库：对应于外模式**，是用户看到和使用的数据库，又称用户视图，一个数据库可有多个不同的用户视图
- **概念级数据库：对应于概念模式**，是所有用户视图的最小并集，一个数据库应用系统只有一个DBA视图
- **物理级数据库：对应于内模式**，是数据库的底层表示，它描述数据的实际存储组织，是最接近于物理存储的，又称为内部视图

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243709.png)

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243710.png)

## 数据模型

### 数据模型分类

- **关系模型是二维表**的形式表示的实体-联系模型，是将实体-联系模型转换而来的，经过开发人员设计的

- **概念模型（ER实体联系模型）是从用户的角度进行建模的**，是现实世界到信息世界的第一抽象，是真正的实体-联系模型

  > 先有概念模型而后有关系模型

- **网状模型表示实体类型及其实体之间的联系**，一个事物和另外几个都有联系，形成一张网。

- **面向对象模型是采用面对象的方法设计数据库，以对象为单位，每个对象包括属性和方法，具有类和继承等特点**

- **数据模型三要素：数据结构、数据操作、数据的约束条件（完整性约束等）**

  > **重点**
  >
  > ![image-20240405211047963](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243711.png)

### E-R模型

> **对应软件工程的数据模型**

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243712.png)

> **重点图型**
>
> 1. **双边矩形：弱实体（依赖于实体）**
> 2. **双边菱形：弱实体集对应的联系**
> 3. **虚线椭圆：派生属性**（根据非主属性可以得出的属性）
> 4. **双椭圆：多值属性**
> 5. 双实线：一个实体全部参与联系集中

#### 概念及两个实体之间的联系

用**E-R图来描述概念数据模型**，世界是由一组称作**实体**的基本对象和这些对象**之间的联系构成**的
在E-R模型中，使用**椭圆表示属性（一般没有）、长方形表示实体、菱形表示联系，联系的两端要填写联系类型（1和多）**，示例如下图

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243713.png)



- 实体：客观存在并可相互区别的事务。可以是具体的人、事、物或抽象概念。如人、汽车、图书、账户、贷款、

- **弱实体和强实体：弱实体依赖于强实体的存在而存在。**

  > **什么是弱实体？**
  >
  > **比如有学生，则家长必须是依赖于学生存在的，而学院、教师都可以不依赖学生存在而存在**
  >
  > ![image-20240405210227479](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243714.png)
  >
  > 弱实体：双边矩形

- **实体集：具有相同类型和共享相同属性的实体的集合，如学生、课程。**

- 属性**：**实体所具有的特性

- **属性分类**

  （1）简单属性和复合属性：简单属性是原子的、不可再分的，复合属性可以细分为更小的部分。如通信地址可以进一步细分为省、市、街道、邮编等。
   （2）单值属性和多值属性：指一个属性有单个值或多个值。如职工的亲属姓名。
   （3）NULL属性：当实体在某个属性上没有值或属性值未知时，使用**NULL值。表示无意义或不知道。**
   （4）**派生属性：可以从其他属性得来。如参加工作时间和工作年限身份证号和年龄等**。
  
- 域：属性的取值范围称为该属性的域

- **码（key键）：唯一标识实体的属性集。**

- 联系：现实世界中事务内部以及事务之间的联系，在E-R图中反映为实体内部的联系和实体之间的联系。

- 特殊化：

  ![image-20240405210419788](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243715.png)

- **联系类型：一对一1:1、一对多1:N、多对多MN**。

  > **多对多**的用字母nm表示也同样**可以用\*表示**

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243716.png)



#### 两种以上的不同实体集之间的联系

- 1：1：1
- 1：1：*

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243717.png)

> **两种以上实体机判断联系的方法**
>
> **如有三个实体，将任意两个实体作为基准，并且假设这个基准里的两个实体都为1个，接下来拿这个基准与另一个实体判断他们之间的联系（用两种实体判定的方法），分别判定三次即可。**
>
> > 注意：要按题目的要求，而不是完全由自己的主观想法
>
> ![image-20240405154822583](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243718.png)
>
> **如上图，①病人和医生都取1，然后对应的话是1个病房，因此病房是1**
>
> **②病人和病房都取1，然后对应的话是可以有多个医生负责，因此医生是多（*）**
>
> **③病房和医生都取1，然后对应的话是病人可以有多个住在病房里，因此病人是多（*）**
>
> **所以关系为1：\*：\***

> 三个实体集之间的多对多联系和三个实体集两两之间的多对多联系的语义是不同的

#### 同一实体集内的二元联系

![image-20240405155626340](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243719.png)

### 基本数据模型

#### 层次模型

用**树形结构表示数据与数据间的联系**。**每个节点表示一个记录（实体）**

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243720.png)

#### 网状模型

DBTG模型，比层次模型更具有普遍性的数据结构。**网状模型允许一个以上的节点无双亲，一个节点可以有多余一个的双亲**

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243721.png)

#### 关系模型

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243722.png)

**域**

- ​	是一组具有相同数据类型的值的集合，例如工号是一个域，而员工公告、经理公告这两个属性列的取值都来源于工号这个域。

**关系**

- 关系数据库中以关系来存储数据。对关系的要求如下
- 关系中的列满足原子性，即不可拆分；
- 关系中的行、列（属性、元组）可交换
- 关系中的列取自同一个域，每一列称为一个属性，不同的属性属性名不同，可以有多个列取自同一个域；
- 每一列中的分量是同一类型的数据，来自于同一个域
- 任意两个元组不能完全相同





**E-R图转换为关系模型：每个实体都对应一个关系模式；联系分为三种**

- **1:1联系中，联系可以放到任意的两端实体中，作为一个属性**（要保证1:1的两端关联）
- **1:N的联系中，联系可以单独作为一个关系模式，也可以在N端中加入1端实体的主键**
- **M:N的联系中，联系必须作为一个单独的关系模式，其主键是M和N端的联合主键**

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243723.png)

#### 面向对象数据模型

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243724.png)

## 数据存储和查询 

**存储管理器**

- 在数据库系统中负责在数据库中存储的低层数据与应用程序以及向系统提交的查询之间提供接口的部件，负责数据库中数据的存储、检索和更新

**存储管理器部件包括以下四个：**

- 权限及完整性管理器：检查访问数据库的用户权限，检测数据是否满足完整性约束。
- 事务管理器：保证一且发生故障，数据库的**一致性**状态，以及并发事务执行（事务并发）时不发生冲突。
- 文件管理器：管理磁盘存储空间的分配
- 缓冲区管理器：负责将数据从硬盘放入内存，并决定哪些数据应被缓冲区放入内存。



**查询处理器**

- 处理数据库系统和用户之间的查询接口及数据交互

**其组件包括**

- DDL解释器：解释DDL语句并将其放入数据字典中。
- DML编译器：将查询语言中的DML语句翻译为一个计算方案，包括一系列查询计算引能理解的命令。
- 数据仓库和数据挖掘基础知识

### 数据仓库DW

数据仓库是一种特殊的数据库，也是按数据库形式存储数据的，但是目的不同：数据库经过长时间的运行，里面的数据会保存的越来越多，就会影响系统运行效率，对于某些程序而言，很久之前的数据并非必要的，因此，可以除掉以减少数据，增加效率，考虑到删除这些数据比较可惜，因此，一般都将这些数据从数据库中提取出来保存到另外一个数据库中，称为数据仓库。
**数据仓库四大特点**

- **面向主题。**
- **集成。（重点）**
- **相对稳定。（重点）**
- **反映历史变化（重点）**

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243725.png)

> **OLAP服务器：联机分析处理**Online analytical processing；**对海量数据进行分析**
>
> **OLTP：联机事务处理OnLine Transaction Processing；**对海量数据进行处理**

- 数据仓库的后台工具：包括数据抽取、清洗、转换、装载和维护工具
- 数据仓库服务器：相当于数据库系统中的DBMS，负责管理数据仓库中数据的存储管理和数据存取，并给OLAP服务器和前台工具提供存取接口（如SQL查询接口）。
- **OLAP服务器：透明地为前台工具和用户提供多维数据视图；必须考虑物理上这些分析数据的存储问题。**
- 前台工具：包括查询报表工具、多维分析工具、数据挖掘工具和分析结果可视化工具

### 数据挖掘技术（常考）

**数据挖掘的分析方法**

- **关联分析**：关联分析主要用于发现不同事件之间的关联性，即一个事件发生的同时另一个事件也经常发生

  > **啤酒和尿布放一起销售量剧增**的案例

- 序列分析：序列分析主要用于发现**一定时间间隔内接连发生**的事件，这些事件构成个序列，发现的列应该具有普遍意义。

- **分类分析（重要）**：按照某种已有的标准**给对象贴标签，再根据标签来分类**。其首先为每个记录赋予一个标记（一组具有不同特征的类别），即按标记分类记录，然后检查这些标定的记录，描述出这些记录的特征。

  > **分类分析要求原本有标准，比如：根据xxx，分析xxx**

- **聚类分析（重要）**：聚类分析是根据“**物以类聚**”的原理，将本身没有类别的样本聚集成不同的组，并且对每个这样的组进行描述的过程

  > **聚类分析要求原本没有标准，比如：直接分类；于不知道数据对象有哪些类型时使用**

| 聚类                 | 分类                          | 关联          |
| -------------------- | ----------------------------- | ------------- |
| EM                   | **决策树decision trees**      | **Apriori**   |
| **K-means（K均值）** | **C4.5（classify）**          | **FP-Growth** |
| **层次Hierarchical** | **SVM（支持向量机）**         |               |
| **DBSCAN基于密度**   | **朴素贝叶斯（naive bayes）** |               |
| 光谱聚类（spectral） | **随机森林random forests**    |               |

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243726.png)

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243727.png)

# 关系数据库

## 关系数据库概述

**关系模型**中数据的逻辑结构是一张二维表，由行列组成。用**表格结构表达实体集**，用**外键标识实体间的联系**。如下图

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243728.png )

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243722.png)

> **一行称为元祖**
>
> 列称为属性
>
> **关系模式称为表**



优点：建立在严格的数学概念基础上；概念单结构简单、清晰，用户易懂易用；存取路径对用户透明，从而**数据独立性、安全性好，简化数据库开发工作。**
缺点：由于存取路径透明，查询效率往往不如非关系数据模型。



> **关系数据库基本知识**
>
> **超键：能唯一标识**此表的**属性的组合**
> **候选键：超键中去掉余的属性**，剩余的属性就是候选键。
>
> > 只**要是候选关键里的里的都是主属性，但不是都是主键，主键是一个，但是主属性可以多个**
>
> **主键：任选一个候选键**，即可作为主键。
> **外键：其他表中的主键**。
> **主属性：候选键内的属性为主属性**，其他属性为非主属性。
>
> > **元数：属性的个数（列数），注意不是元组的个数**
>
> > **n元关系：元数为几，就是几元关系**
>
> > **基数：记录的个数（行数）**

## 关系运算

![image-20240326221137457](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243729.png)

> 表和表之间的运算

### 算数运算符

- \>
- \>=
- <
- <=
- =
- !=

### 逻辑运算符

- 与：^
- 或：v
- **非：$\neg$**

> **注：位运算符**
>
> - 与：&
> - 或：|
> - **异或：^**

### 集合运算符

- **并**：结果是两张表中所有记录数合并，**相同记录只显示一次**

- 交：结果是**两张表中相同的记录**

- **差：S1-S2，结果是S1表中有而2表中没有的那些记录**

  > **上述三种操作必须具有相同的关系模式，也就是相同的列**

> **等价的select语句**
>
> - 并：**union**
>
> - **交：select a.* from a,b where a.xx=b.xx and a.yy=b.yy and a.cc=b.cc**
>
>   **intersect**
>
> - **差：select * from a where a.xx not in (select xx from b) and a.yy not in (select yy from b)...**
>
>   **except**

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243730.png)

- **笛卡尔积：S1Xs2，产生的结果包括S1和S2的所有属性列**，并且S1中每条记录依次和S2中所有记录组合成一条记录，最终**属性列为S1+S2属性列**，记录数为S1*S2记录数

### 关系运算符

![image-20240405152305597](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243731.png)

#### 选择和投影

- **投影**：实际是按条件**选择**某关系模式中的**某列**，**列也可以用数字表示**。**运算符号为 $\pi$ **

  > **投影有去重的效果**

- **选择**：实际是按**（列的）条件选择**某关系模式中的**某条记录**。运算符号为**δ**

  > **投影和选择总结**
  >
  > 投影运用了派<sub>1,2</sub>（s1）或派<sub>sno,sname</sub>（s1）。**投影就是对列进行筛选**，**等价于select xx**
  >
  > 选择运用了δ<sub>sno</sub>=No003(s1)。**选择就是对行进行筛选**。**等价于select b from a where b=xx**

  ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243732.png)

#### 自然连接

- **自然连接的结果显示全部的属性列，但是相同属性列只显示一次，显示两个关系模式中属性相同且值相同的记录**，符号：

  ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243733.png)

  设有关系R、S如下左图所示，自然连接结果如下图所示：

  ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243734.png)

  > **R自然连接S=派<sub>1,2,3,6</sub>[δ<sub>1=4 and 3=5</sub>(RXS)]**
  >
  > **笛卡儿积转换成自然连接需要对笛卡尔积进行投影，即派**
  >
  > 先对RXS的笛卡尔积进行行的选择运算筛选，使其满足自然连接中“两个关系模式中属性相同且值相同的记录”，即笛卡儿积的列结果“abcacd”，而第一个a和第二个a分别是1和4；而后对这个结果进行投影运算筛选，使其满足自然连接中“显示全部的属性列”，即上面的a、b、c、d列

  > **自然连接的等价**
  >
  > 如有a与b两个表进行自然连接的运算，则
  >
  > **等价于select A.*,B.\* from A,B where A.xx=B.xx**
  >
  > ![image-20240328201339269](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243735.png)

#### 除法

- **除法：选出被除数中与除数相同的信息，然后将结果去除除数出现的列，相同的结果只会出现一次**

  ![image-20240328135007712](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243736.png)

  ![image-20240328134750311](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243737.png)

### 连接关系运算

一**般连接和等值连接：先做笛卡尔积，在其基础上满足连接条件**，如下图分别是选取R X S笛卡尔积后按条件第C行小于第E的数据，R的第B行等于S的第B行数据

![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243738.png)

- **外连接（OUTER JOIN）**：关系RS进行**自然连接**时，把舍弃的元组也保存在结果关系中，在其他表的属性上填NULL。

  ![image-20240328153749307](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243739.png)

- 左外连接（LEFT OUTER JOIN）：关系RS进行自然连接时，**只把左边关系R中要舍弃的元组保留**。

  ![image-20240328153717294](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243740.png)

- 右外连接：关系RS进行自然连接时，只把右边关系中要舍弃的元组保留。

  ![image-20240328153723820](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243741.png)

  ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243742.png)

  > 就是sql的外连接

  ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243743.png)
  
  ![](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243744.png)

## 元组演算

> 行的演算

把数理逻辑的请词演算引入到关系运算中，就可得到以关系演算为基础的运算关系演算又可分为：

- 元组关系演算（**元组演算）：以元组为变量**
- 域关系演算（**域演算）：以属性（域）为变量**



- **元组关系演算（TupleRelationalCalculus）**

  元组中的表达式简称为元组表达式，其一般形式为**{t | P(t)}**其中，表示**用t代替元组P，以后t就是元组P了**；t是元组变量，表示一个元数固定的元组P是公式，在数理逻辑中也称为调词，也就是计算机语言中的条件表达式。

  {t | P(t)}表示满足公式P的所有元组t的集合。

- 元组关系演算（TupleRelationalcalculus）*  关系演算的3个原子公式

  1. R（t）：R是关系名，是元组变量，R（t）表示“**t是关系R的一个元组**”
  
  2. t[i]$\theta$ u[j]：其中u是元组变量， 是算术比较运算符，**t[i]$\theta$ u[j]表示“元组的第i个分量**和u的第个分量之间满足关系”
  
     > **t[i]就是指第i列，上述表示t[i]与u[j]进行比较**
  
  3. t[i]$\theta$ C[j]或C$\theta$ t[j]：其中**C是常量**。 **t[i] $\theta$ C表示“元组的第i个分量值与常量C之间满足关系”**
  
     > 如**t[2]>3这个条件，其中C是3， $\theta$就是>表示是运算符**

> **公式中运算符的优先顺序如下：**
>
> **算术比较运算符$\theta$和、$\exists$和$\forall$、$\neg$。**加括号时，括号中的运算符优先
>
> **^：并**
>
> **v：或**

- **元组演算案例**

  ![image-20240324092058367](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243745.png)

  > **解析**
  >
  > - R1：t是R中的任意一个元组，另一个t也是S的任意一个元组，非S（t）就表示，该t不属于S里的任意一个元组。因此表示等价于R-S
  
  

## 域运算

> 列的演算

- **域关系演算（DomainRelationalCalculus）**

  域演算表达式的一般形式为：{t1,..,tk   IR（t1,...,tk）}其中，**t1,..,tk是域变量**，R（t1....tk）是域演算公式。

- **域演算的3个原子公式**

  1. R（t1..,.ti,..tk）：表示“以t1,...ti,..tk为分量的元组在关系R中”
  2. ti$\theta$uj：ti和uj是域变量，表示“元组第i个分量和u的第j个分量之间满足$\theta$关系”
  3. ti$\theta$C或C$\theta$ ti：C是常量，表示“元组t的第个分量值与常量C之间满足关系”

  > **注意元组演算与域演算表达式的区别**
  >
  > **元组演算nR（t）：表示“t是关系R的一个元组**”
  >
  > t：表示元组的第个分量
  >
  > **域演算nR（t1,...ti,..tk）：表示“以t1,..ti,..tk为分量的元组在关系R中**
  >
  > ti：表示元组的的第个分量

- **域演算案例**

  ![image-20240406172948470](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243746.png)
  
  > **注意理解R（ut<sub>2</sub>v）和（t<sub>1</sub>wt<sub>3</sub>的含义）**👆
  
  ![image-20240324095653898](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243747.png)
  
  > **重点：前面是域，后面才是条件，可以从前面的定义中看出有多少列**

## 查询优化

**①选择操作的实现**
select * from stu where <条件表达式

> 条件表达式的几种情况：
> 无条件；
> sno=000001
> sage>20

- **查询方法**

  简单的**全表扫描**方法：对查询的基本表顺序扫描，逐一检查每个元组是否满足选择条件，把满足条件的元组作为结果输出

  **对于小表，这种方法简单有效；对于大表，顺序扫描十分费时，效率低**

- **优化方法**

  **索引（或散列）扫描方法**：如果选择条件中的属性上有索引（如**hash索引**），用索引扫描法；

  通过索引先**找到满足条件的元组主键或元组指针**，**再**通过元组指针直接在查询的基本表中**找到元组**





**②连接操作的实现**
连接操作是查询处理中最耗时的操作之一select *from R,S where R.sno=S.sno

- **查询方法**

  嵌套循环方法：对外层循环R的每一个元组，检索内层循环S中的每一个元组，并检查这两个元组在连接属性sno上是否相等，如果满足连接条件，则接后作为结果输出，直到双重循环结束

- **优化方法**

  排序-合并方法：适合连接的各表已经有序的情况，步骤为：

  1. 先给各表排序
  2. 取R表中第一个sno，依次扫描S表中具有相同sno的元组把它们连接起来
  3. 当扫描到sno不相同的第一个元组时，返回到R表扫描其下一个元组，再用其下一个元组去S表中查找相同sno的元组，重复这个过程



**查询优化的目标：选择有效策略，求得给定关系表达式的值，使得查询代价最小**

- 优化准则：

   - **提早执行选择运算**，目的是减少中间结果

   - **合并乘积与选择运算为连接运算**，目的是避免扫描大的关系

   - **将投影运算与其他运算同时进行**，目的是避免重复扫描关系。

   - **将投影运算与二日运算结合起来**，目的是减少扫描关系的次数

   - 在**执行连接前对关系适当的预处理，如索引连接法、排序合并法**


   - **存储公共子表达式**，目的是只需检索中间结果，**不需重复计算**。

-  效率问题

   关系代数运算的效率，归根结底是看参与运算的两张表格的属性列数和记录数属性列和记录数越少，参与运算的次数自然越少，效率就越高。

  >  因此，效率高的运算一般都是在两张表格参与运算之前就将条件判断完。如
  >
  >  $\pi$1,2,3.8（$\sigma$2=''大数据'\^1=5\^3=6\^8='开发平台'（R×S））和
  >
  >  π123.8（$\sigma$1=5^3=6（$\sigma2=$''大数据''（R）× $\sigma$4=''开发平台'（S）））
  >
  >  后者效率比前者效率高很多
  
  ![image-20240324203403666](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243748.png)

## 关系模式的设计问题

*   **数据冗余：同一数据重复出现多次。**
*   **操作异常（更新异常）：修改异常、插入异常和删除异常。**
*   **规范化的一个原则：“关系模式有冗余问题，就分解它”。**

## 函数依赖与码

### 函数依赖

给定一个，能唯一确定一个Y，就称X确定Y，或者说Y依赖于，例如Y=X*X函数。
函数依赖又可扩展以下几种规则

1. 平凡的函数依赖：x->y，且y $\subseteq$y，则称x->y是平凡的函数依赖

   > **子集就是平凡的函数依赖，我们讨论的都是非平凡依赖**

2. **部分函数依赖：（A,B）可确定C，（A,B）中的一部分（即A）也可以确定c，称为部分函数依赖。用符号(A,B)-^p^->C**

   > ![image-20240405144927806](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243749.png)

3. **传递函数依赖：当A和B不等价时**，A可确定B，B可确定c，则A可确定c，是传递函数依赖；**若A和B等价，则不存在传递**，直接就可确定C。表示为：A->B,B->C;A->C

> **判定函数依赖是否冗余**？
>
> **是函数传递依赖的，则函数传递依赖保留，剩下的是冗余的**
>
> ![image-20240509174322842](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243750.png)

- **最小函数依赖**：（不包含多余的函数依赖）满足一下三个条件（最小函数依赖集G）：G中的每个FD的**右边都是单属性**。**G中没有冗余的FD。G中的左边没有冗余的属性。**

### 函数依赖的公理系统（Armstrong）

设**关系模式R<U，F>，U是关系模式R的属性全集，F是关系模式R的一个函数依赖集**。对于R<U，F>来说有以下的定律：

1. **自反律：若Y $\subseteq$ X$\subseteq$U，则U->X→Y为F所逻辑蕴含**

   <img src="https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243751.png" alt="image-20240324205039886" style="zoom: 25%;" />

2. **增广律**：若X→Y为F所逻辑蕴含，且z$\subseteq$U，则XZ→YZ为F所逻辑蕴含

   **x->y;所以xz->yz**

3. 传递律：若X→Y和Y-Z为F所逻辑蕴含，则x->Z为F所逻辑蕴含。即传递依赖

4. **合并规则：若x→Y，X→Z，则x→YZ为F所蕴涵**

   <img src="https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243752.png" alt="image-20240324205350007" style="zoom: 50%;" />

5. **伪传递率：若x→Y，WY→Z，则WX→Z为F所涵**

6. **分解规则**：若x→Y，Z$\subseteq$Y，则X→Z为F所蕴涵

   **因为z$\subseteq$y，所以y->z，即x->y->z**

### 候选码

【定义7.7】设**K为R（U，F）中的属性的组合**，**若K→U，且对于K的任何一个真子集K都有K不能决定U，则K为R的候选码**（Candidatakey），若有多个候选码，则选一个作为主码（Primarykey）。

> 注意：**候选码通常也可以称为候选关键字，主码通常也可以称为主关键字或主键**。
>
> 包含在任何一个候选码中的属性叫作主属性（Primeattibute），否则叫作非主属性（Nonprimeattibute）或非码属性（Non-keyattribute）。
>
> **最简单的情况，关系的单个属性是码：最极端的情况，若关系的所有属性为码，则称该码为全码（All-key）**

> **F表示函数依赖集，U表示属性集**

> **候选关键字的求法**
>
> **根据依赖集（F表示），找出从未在右边出现过的属性，必然是组成候选键的成分之一，以该属性为基础，根据依赖集依次扩展（添加），看能否遍历所有属性，将无法遍历的加入候选键中**
>
> **可以存在函数依赖及依赖系统的操作**

> **主属性个数求法**
>
> unique（出现的候选关键字）后，数个数

![image-20240329150843497](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243753.png)

## 范式

### 第一范式1NF

关系中的每一个分量必须是 个**不可分的原子数据项**。通俗地说，第一范式就是表中不允许有小表的存在。比如，对于如下的员工表，就不属于第一范式：

![image-20240329140831464](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243754.png)

> **实例**
>
> 用一个单一的关系模式学生来描述学校的教务系统：学生（学号，学生姓名，系号，系主任姓名，课程号，成绩）
>  **依赖关系**（学号-学生姓名，学号->系号，系号->系主任姓名,学生->课程号，（学号，课程号）->成绩）

### 第二范式

如果**关系R属于1NF，且每一个非主属性完全函数依赖于任何一个候选码**，则R属于2NF。

> **消除了非主属性对主属性的部分函数依赖**

**通俗地说，2NF就是在1NF的基础上，表中的每一个非主属性不会依赖复合主键中的某一个列。**

> **只有联合主键才有部分函数依赖（依赖主键的一部分）；联合主键里两个都用上就是完全依赖，所以单主键一定符合第二范式**

按照定义，上面的学生表就不满足2NF，因为学号不能完全确定课程号和成绩（每个学生可以选多门课）

> **将学生表分解为：**
>
> 学生（<u>学号</u>，学生姓名，系编号，系名，系主任）
> 选课（<u>学号，课程号</u>，成绩）。
> 每张表均属于2NF

### 第三范式

**在满足1NF的基础上，表中不存在非主属性对码的传递依赖**

> **消除了非主属性对主属性的传递函数依赖**

继续上面的实例，学生关系模式就不属于3NF，因为学生无法直接决定系主任和系名，是由学号->系编号，再由系编号->系主任，系编号->系名，因此存在非主属性对主属性的传递依赖
**将学生表进一步分解为：**
学生（<u>学号</u>，学生姓名，系编号）
系（<u>系编号</u>，系名，系主任）
选课（<u>学号,课程号</u>，成绩）
每张表都属于3NF。

### BC范式

> **依赖于多个候选键，就是需要多个候选键
> 消除主属性对于码的部分函数依赖和传递依赖，且没有任何属性完全函数依赖于非码的任何一组属性**

**BCNF**，是指**在第三范式的基础上进一步消除主属性对于码的部分函数依赖和传递依赖，且没有任何属性完全函数依赖于非码的任何一组属性**

> **注：**
>
> 第二第三范式分别是消除**非主属性**对主属性的部分函数依赖，函数传递依赖，然而BCNF则是消除**主属性对于候选键的部分函数依赖和函数传递**
>
> ![image-20240408155120632](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243755.png)**该图则不符合BCNF**

> **通俗的来说，就是在每一种情况下，每一个依赖集的左边决定因素都必然包含候选键**
>
> 如下：

![image-20240329142936538](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243756.png)

上图中，候选键有两种情况：**候选（组合）键（S,T）或者（S,J），依赖集为(SJ--->T，T一>J)**，可知，STJ三个属性都是主属性，因此其天然达到了3NF（无非主属性），**然而，第二种情况，即（S,J）为候选键的时候，对于依赖集T->J，T在这种情况不是候选键（候选键是s，j），即T->J的决定因素不包含任意候选码，因此上图不是BCNF。**

> **第一种情况：(S,T)为候选键时，寻找依赖集：SJ-->T左边存在S，且S是候选键；T-->J时左边存在T，且T是候选键，所以组合键（S，T）符合BCNF**

**要使第二种情况的关系模式转换为BCNF也很简单，只需要将依赖T->J变为TS->J即可**，这样其左边决定因素就包含了候选键之一S。

![image-20240329150832090](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243757.png)

![image-20240331153450009](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243758.png)



### 第四范式

> **4NF就是消除表中的非平凡多值依赖关系**

> **多值依赖定义**
>
> 若关系模式R（U）中，X、Y、Z是U的子集，并且Z=U-X-Y。当且仅当对R（U）的任何一个关系T
> **给定一对（x,z）值，有一组Y的值，这组值仅仅决定于×值而与z值无关**，则称**“Y多值依赖于X 或 X多值决定Y”**成立。记为：**X→→Y。** 
>
> > 注：（**若Z为空集是平凡的多值依赖，Z不为空是非平凡**）
>
> > **字面意思去理解：x能够决定多个值的y**
> >
> > ![image-20240405150353921](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243759.png)
> >
> > 如上图，给定任意(x,z)如（数学，三平）能够决定多个y的值，且与z不关。
> >
> > 抽象的理解：给定任意(x,y)有(x1,z)->y1，(x2,z)->y2...，与z不关，此时为X多值决定Y
>
> > **例2**
> >
> > ![image-20240408161701449](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243760.png)
> >
> > 看黄色部分。①是平凡的多值依赖，但是作者与排名是有有关系的
> >
> > ②是非平凡的多值依赖，但书名和出版社是没有关系的，因为书名和出版社都由isbn决定
>
> 多值依赖具有如下6条性质
>
> - 多值依赖具有对称性。即若X→→Y，则X→→Z，其中Z=U-X-Y
> -  多值依赖的传递性。即若X→→Y→→Z， 则X→→Z-Y。
> -  函数依赖可以看成是多值依赖的特殊情况。
> - 若X→→YX→→Z，则X→→YZ。
> - 若X→J.X    则X→→Ynz。   
> - 若X→→YX→→Z，则X→Z-Y。

【定义7.14】关系模式REINF，若对于R的每个非平凡多值依赖X→→Y且YX时，X必合有码，则关系模式RU4NE

> **4NF是限制关系模式的属性间不允许有非平凡且非函数依赖的多值依赖。所以4NF允许表有函数依赖与平凡的多值依赖**

**注意：如果只考虑函数依赖，关系模式最高的规范化程度是BCNF：如果考虑多值依赖关系模式最高的规范化程度是4NF**
**根据4NF的定义可知，4NF所不允许的非平凡的多值依赖实际上就是函数依赖，4NF就是消除表中的非平凡多值依赖关系。**

- 实例：

  ![image-20240329152711702](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243761.png)

  ![image-20240329153847935](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243762.png)

### 模式分解

> **分解后的关系模式至少要达到3NF**

范式之间的转换一般都是**通过拆分属性，即模式分解，将具有部分函数依赖和传递依赖的属性分离出来**，来达到一步步优化，一般分为以下两种：

#### 保持函数依赖分解

**对于关系模式R，有依赖集F，若对R进行分解，分解出来的多个关系模式，保持原来的依赖集不变，则为保持函数依赖的分解**。另外，**注意要消除掉冗余依赖（如传递依赖）。**

实例：设原关系模式R(A,B,C)，依赖集F(A->B,B->C,A->C)，将其分解为两个关系模式R1（A,B）和R2（B,C），此时R1中保持依赖A->B，R2保持依赖B->C，说明分解后的R1和R2是保持函数依赖的分解，因为A-C这个函数依赖实际是一个**冗余依赖，可以由前两个依赖传递得到，因此不需要管**

- **保持函数依赖的判断（补充，第2点不强求）：**
  1、**如果F上的每一个函数依赖都在其分解后的某一个关系上成立，则这个分解是保持依赖的（这是一个充分条件）**。也即我们课堂上说的简单方法，**看函数每个依赖的左右两边属性是否都在同一个分解的模式中**

  > **重点看以下的例子**
  >
  > 如**{a->b,b->c}分为{a,b}和{a,c}，则可以得出a->b和a->c或者b->a和c->b，无法达到原本依赖{a->b,b->c}**，则称分解后的关系模式**不符合函数依赖**
  
  2、如果上述判断失败，并不能断言分解不是保持依赖的，还要使用下面的通用方法来做进一步判断。
  该方法的表述如下：
  算法二
  对F上的每一个使用下面的过程
  result:=a
  while（result发生变化）do
  foreach分解后的Ri
  t=（resultnRi）+nRi
  result=resultUt
  
  ![image-20240329184054914](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243763.png)

#### 无损分解（连接）

**分解后的关系模式能够还原出原关系模式（原属性），就是无损分解，不能还原就是有损。**

当分解为**两个关系模式**，可以通过以下定理判断是否无损分解

- **定理：如果R的分解为p={R1，R2}，F为R所满足的函数依赖集合，分解p具有无损连接性的充分必要条件是R1 n（交） R2->（R1-R2）或者R1 n R2->（R2-R1）；看能否-> 推出时，要去依赖集里找有无才行**

- 当分解为三个及以上关系模式时，可以通过表格法求解，如下：

  ![image-20240329184409882](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243764.png)

  > **真题**
  >
  > ![image-20240329185552130](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243765.png)

## 闭包

> **某种对象通过某种规则得到的更多同类对象+上原来的对象组成闭包**

### 函数依赖闭包F<sup>+</sup>

关系模式R（U，F）中，F所逻辑蕴含的函数依赖的全体（自有的+推导出来的）称为**F的闭包**

> **逻辑蕴含**
>
> **F能推出原本不存在F中的函数依赖**，则该函数依赖为F所逻辑蕴含的函数依赖。**如函数的传递依赖**
>
> ![image-20240502145152717](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243766.png)

![image-20240502145421237](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243767.png)

### 属性闭包<sup>+</sup><sub>F</sub>

**属性集X里的所有属性代入到函数F中**，**推导出的所有结果组成的集合称为X在函数F下的闭包（函数的闭包）**

![image-20240502145352688](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243768.png)

# SQL语言

> 考点：
>
> ①：关系运算-sql
>
> ②：sql
>
> ③：定义

## 数据库语言

数据定义语言DDL： 数据结构定义与数据库对象定义的语言，由create、alter、drop三个语法组成
数据操纵语言DML：实现对数据库的基本操作，包含select、update、insert、delete等语法。数据库语言的分类
作为独立语言使用；
嵌入到高级语言中使用：嵌入式SQL、宿主语言

## SQL概述

SQL由以下几个部分组成
 （1）数据定义语言。SQLDDL提供定义关系模式和视图、删除关系和视图、 修改关系模式的命令
 （2）交互式数据操纵语言。SQLDML提供查询、插入、删除和修改的命令
  （3）业事务控制。SQL提供定义事务开始和结束的命令。
 （4）嵌入式SQL和动态SQL。用于嵌入到某种通用的高级语言（C、C++、Java、PL/I、COBOL
和VB等）中混合编程。其中，SQL负责操纵数据库，高级语言负责控制程序流程
 （5）完整性。SQLDDL包括定义数据库中的数据必须满足的完整性约束条件的命令，对于破坏完整性约束条件的更新将被禁止
 （6）权限管理。SQLDDL中包括说明对关系和视图的访问权限

## 数据库定义

> 用的是mysql

![image-20240328140145998](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243769.png)

![image-20240328140301068](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243770.png)

![image-20240328140525352](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243771.png)

- **索引**
  *   **聚簇索引对表的物理数据页中的数据按列进行排序，然后再重新存储到磁盘上，即聚簇索引与数据是混为一体的，它的也节点中存放的是实际的数据。**
  *   **非聚簇索引是具有完全独立于数据行的结构**，不用将物理数据页中的数据按列排序，节点中存放的是索引的关键字值和行定位置。

![image-20240328140712220](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243772.png)

**视图**

![image-20240328140936986](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243773.png)

![image-20240328141110443](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243774.png)

**SQL对视图更新必须遵循以下规则**

-  （1）从多个基本表通过**连结**操作导出的视图**不允许更新**。
-   （2）对使用了**分组、集函数**操作的视图则**不允许进行更新**操作。
-   （3）如果视图是从**单个基本表通过投影、选取操作导出的则允许进行更新**操作，且语法同基本表和过程定义不同的是Createview子句会在数据库中建立视图定义，该视图定义会一直保存，直到执行drop.vieW命令。但是，**with子句提供了定义一个临时视图的方法，该定义只对with子句出现的那条查询有效。**
                     with max-Salary(value）AS
                      SELECT max(Salary）
                         FROM Teachers
                        SELECTTname
                     FROM Teachers，max-Salary
                            NHERE Teachers.Salary   max-Salary.value

## 数据操作 

![image-20240328141314514](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243775.png)

> **真题**
>
> ![image-20240328202038420](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243776.png)
>
> > 这里是unknown 或者 True ；而不是unknown or True一个整体
> >
> > **unknown就是表示不存在或不知道**
>
> ![image-20240328203421467](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243777.png)
>
> > 如何选择连接条件？看题目，**题目要求的表拿出外键去跟外表的主键连接**

> **select xxx相当于关系运算的投影 $\pi$，where xxx 是选择 $\sigma$，from 多个表是笛卡儿积**
>
> ![image-20240328201339269](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243735.png)

![image-20240328141812368](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243778.png)

![image-20240328142321386](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243779.png)

![image-20240328142511110](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243780.png)

> **注意：**
>
> group by后面的列必须是select的列

![image-20240328143039163](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243781.png)

![image-20240328145651563](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243782.png)

![image-20240328191345711](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243783.png)

## 完整性约束

**关系的完整性约束**

- **实体完整性约束：即主键约束， 主键值不能为空，也不能重复**
- **参照完整性约束：即外键约束**，外键必须是其他表中已经存在的**主键的值或者为空。**
- **用户自定义完整性约束：自定义表达式约束**，如设定年龄属性的值必须在0到150之间。

![image-20240328191603635](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243784.png)

![image-20240328191717189](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243785.png)

### 创建断言

通过声明性断言（declarative assertions）来指定更具一般性的约束。可以**定义涉及多个表或聚集操作的比较复杂的完整性约束**。断言创建以后，任何对断言中所涉及关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值得操作都会被拒绝执行。

> **语法：create assertion name check(condition)**
>
> ![image-20240404135342170](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243786.png)

## 授权与收权

> **grant update[(sal)] on table emp to scott with grant option;**

![image-20240328191810940](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243787.png)

![image-20240328191955267](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243788.png)

## 触发器

> **同一个表最多能创6个触发器**
>
> **改名操作：referencing old row as xx,new row as yy**
>
> **默认新值和旧值：**
>
> 1. 行级：old|new
> 2. **语句级：old-table|new-table**
>
> 行级触发器和语句级触发器
>
> 1. 行级：for each row
> 2. **语句级：for each statement**

![image-20240328192059038](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243789.png)

![image-20240328192342565](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243790.png)

![image-20240328192434149](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243791.png)

> 用before时失败，sql也会失败；sql失败，用after时也不会执行
>
> old==deleted，new=inserted
>
> 只有update有of：对**单独的列**进行触发器
>
> **on后面及when前面有个referencing，可以设置old与new的别名**
>
> > **referencing old row as xx,new row as yy**
> >
> > ![image-20240404135857006](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243792.png)

![image-20240328192825796](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243793.png)

![image-20240328193238684](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243794.png)

## 触发器

### oracle

create [or replace] procedure pro_name [(parameter1[,parameter2]…)] **is|as**
begin

### mysql

CREATE PROCEDURE TEST_PROC(IN ID int,OUT NAME VARCHAR(50))  -- **没有as|is**
BEGIN

## 函数

> **mysq是returns，要加s**
>
> **oracle是return .. is|as，没有s**

![image-20240328203648995](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243795.png)

## 事务操作

> **一条事务可以包含多条DML，但只能包含1条DDL或1条DCL**

```
begin transaction  #开始事务
update ...
commit
rollback
end transaction  #结束
```

## 嵌入式SQL

### 基本使用

**将SQL语言嵌入到高级程序设计语言中使用**

- 1.**区分主语言语句与SQL语句**

  为了区分主语言语句与SQL语句，需要**在所有的SQL语句前加前EXEC SQL**，而SQL的结束标志随主语言的不同而不同

  例如，PL/1和**C语言的引用格式为： EXEC SQL  <SQL语句>；**

  又如，COBOL语言的引用格式为：**EXEC SQL   <SQL语句>END-EXEC**

- **2.主语言工作单元与数据库工作单元通信**

  - 1）SQL通信区

    SQL通信区向主语言传递SQL语句执行的状态信息，使主语言能够根据此信息控制程序流程

  - 2）主变量

    **主变量也称共享变量。主语言向SQL语句提供参数主要通过主变量，主变量由主语言的程序定义**，并用SQL的DECLARE语句说明。例如在C语言中可用如下形式说明主变量

  ```sql
  EXEC SQL BEGIN DECLARE SECTION   -- 该语句是说明主变量（共享变量）
        char Msno[4],Mcno[3],givensno[5];
        int Mgrade；
       char SQLSTATE[6];
  EXEC SQL END DECLARE SECTION;
  
  -- 使用如下（用冒号开头的变量）：
  EXEC SQL SELECT sname,age,sex
      INTO：Msno，：Mcno，:givensno  -- 冒号使用
       FROM students
       NHERE ShO=:MSnO  -- 有值后c语言可以调用
  ```
  
  > **SQLSTART是一个特殊的共享变量，当sql语句执行成功是，系统自动赋值全零，否则是非全零“02000”**

### 游标

SQL语言是面向集合的，一条SQL语句可产生或处理多条记录。而主语言是面向记录的，一组主变量一次只能放一条记录，所以，**引入游标，通过移动游标指针来决定获取哪一条记录**。与游标相关的SQL语句有四条：

- （1）定义游标，，格式如下：

  ​          **EXEC SQL DECLARE <游标名> CURSOR FOR**

  ​               **<SELECT语句>**

  ​          **END_EXEC**

  > **但实际代码不用end_exec**

  ​        这是一条说明性语句，定义中的SELECT语句并不立即执行。

- （2）打开游标，格式如下：

  ​          **EXEC SQL OPEN  <游标名> END_EXEC**

  ​          该语句执行游标定义中的SELECT语句，同时游标处于活动状况。游标 是一个指针，此时指向查询结果的第一行之前。

-  （3）推进游标，格式如下：
  **EXEC SQL FETCH FROM <游标名> INTO <变量表> END_EXEC**
  该语句使用时，游标推进一行，并把游标指向的行（称为当前行）中的值取出，送到共享变量中。变量表由用逗号分开的共享变量组成。该语句常置于宿主语言程序的循环结构中

  > **嵌入式这里有from**
  
- （4）关闭游标，格式如下：
  **EXEC SQL CLOSE <游标名> END_EXEC**
  该语句关闭游标，使它不再和查询结果相联系。关闭了的游标，可以再次打开，与新的查询结果相联系使用实例：

  ![image-20240328194418219](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243796.png)

  ![image-20240328194657862](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243797.png)

  ```c
  define NO_MORE_TUPLES !(strcmp（SQLSTATE,02000”））
  void sel）
  EXEC SQL BEGIN DBCLARE SECTION       /*说明主变量
  char Nsno4]Mcno[3]givensno[5]
  int Mgrade
  char SQISTATE6]
  SXEC SQL END DECRRESECTION
  XEC SQE DECARE SCX CURSOR FOR         说明游标Scx，将查询结果与Scx建立联系*
  SELECT SnoCno,Grade
  FROM SC
  HERE Sno:givensno
  EXEC SQL OPEN SCx
  while（1）                                  /*用循环结构逐条处理结果集中的记录*{EXEC SQL FETCH EROM Scx              /*游标推进一行*/
           INTO Msno，Mcno，Mgrade；       /*送入主交量*/
  If （NO_MORE_TUPLES) Break             /*处理完退出循环*/
  IE（Mgrade<60）                           /*成绩<60*/
    EXEC SQL DELETE FROM SC
             NHERE CURRENT OF Scx
  EIS
     If （Mgrade<70）                      /*成绩<70*/
        EXEC SQL UPDATE SC
          SET grade=70
           WHERE CURRENT OF Scx
          MGrace-70
       Printf(s,s,a,Msno,Mcno,Mgrae）；     /*显示学生记录*/
  }
  ```


### 动态sql

![image-20240404141750772](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243798.png)

### 机制与无空置问题

若**查询结果为多条记录**时，将查询结果**交给主语言处理**时，应**使用**的机制是**游标**，**引入指示变量**来**解决主语言无空值**的问题

## SQL-99所支持的对象关系模型

### 嵌套关系

### 复杂类型

### 继承

### 引用类型

![image-20240404142149391](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243799.png)

### 与复杂类型有关的查询

### 函数和过程

就是oracle的存储过程和存储函数

![image-20240404142345731](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243800.png)

![image-20240404142416795](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243801.png)

![image-20240404142516481](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243802.png)

![image-20240404142610146](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243803.png)

### 异常处理

![image-20240404142736700](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243804.png)

# 非关系型数据库NoSQL

> not only sql：关系型的数据库之外的数据库

## No SQL概述

传统的关系数据库在应付Web2.0网站，特别是超大规模和高并发的SNS类型的Web2.0纯动态网站方面已经显得力不从心，暴露了很多难以克服的问题，主要包括以下几个方面。
1）对数据库高并发读写的需求
2）对海量数据的高效率存储和访问的需求
3）对数据库的高可扩展性和高可用性的需求

![image-20240330150651328](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243805.png)

## 相关理论基础

CAP原则又称CAP定理，指的是在一个分布式系统中，**Consistency（一致性）、Availability（可用性）、Partition tolerance（分区容错性），三者最多只能得其二。**

- **一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值**。 （等同于所有节点访问同一份最新的数据副本）

  > 分布式系统：数据分开存储

- **可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求**。（对数据更新具备高可用性）

- **分区容忍性（P）**：以实际效果而言，**分区相当于对通信的时限要求**。系统如果不能在时限内达成数据一致性，就意味看发生了分区的情况，必须就当前操作在C和A之间做出选择

  > **分区方法**
  >
  > （1）**内存缓存**：缓存技术可以看成一种分区。内存中的数据库系统将使用频率最高的数据复制到缓存中，加快了数据给用户传递的速度，同时也大大减轻了数据库服务器的负担
  > （2）**集群**：数据库服务器集群在为用户提供服务时的透明性（用户感觉数据像是在同一个地方），是另外一个对数据进行分区的方法。
  >  （3）**读写分离**：指定一台或多台主服务器，所有或部分的写操作被送至此，同时再设一定数量的副本服务器用以满足读请求。
  > （4）**范围分割技术/分片（sharding）**：指对数据按照如下方式进行分区操作，即对数据的请求和更新在同一个结点上，并且对于分布在不同服务器上的数据存储和下载的量大致相同


由于CAP理论的存在，为了提高性能，出现了ACID的一种变种BASE：**Basically Available（基本可用），Softstate（软状态）和Eventually consistent（最终一致性）**

> **ACID**，是指[数据库管理系统](https://baike.baidu.com/item/数据库管理系统/1239101?fromModule=lemma_inlink)（[DBMS](https://baike.baidu.com/item/DBMS/0?fromModule=lemma_inlink)）在写入或更新资料的过程中，为保证[事务](https://baike.baidu.com/item/事务/5945882?fromModule=lemma_inlink)（transaction）是正确可靠的，所必须具备的四个特性：**[原子性](https://baike.baidu.com/item/原子性/0?fromModule=lemma_inlink)（atomicity，或称不可分割性）、[一致性](https://baike.baidu.com/item/隔离性/0?fromModule=lemma_inlink)（consistency）、[隔离性](https://baike.baidu.com/item/隔离性/0?fromModule=lemma_inlink)（isolation，又称独立性）、[持久性](https://baike.baidu.com/item/持久性/0?fromModule=lemma_inlink)（durability）。**

- Base理论核心思想是：既然无法做到强一致性，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。

  > **nosql数据库保证了BASE特性**

- **基本可用：系统出现了不可预知的故障，但相比较于正常系统还是能用的**。

- **软状态：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性**，即允许系统在多个不同节点的数据副本存在数据延时

- **最终一致性：系统能够保证在没有其他新的更新操作的情况下，数据最终一定能够达到一致的状态**，因此所有客户端对系统的数据访问最终都能够获取到最新的值

  > **弱一致性** 

  ![image-20240330151743414](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243806.png)

  > **acid关注一致性，base关注可用性**

- 具体地说，**如果选择了CP（一致性和分区容忍性），那么就要考虑ACID理论。如果选择了AP（可用性和分区容忍性）那么就要考虑BASE系统。如果选择了CA（一致性和可用性），那么在网络发生分区的时候，将不能进行完整的操作。**

> **存储分布**
>
> 1.行存储和列存储：两者之间的主要区别在于，**行存储将每条记录的所有字段的数据聚合存储**，而**列存储将所有记录中相同字段的数据聚合存储**。**行存储主要适用于OLTP**，或者**更新操作，尤其是插入、删除操作频繁的场合**：而**列存储主要适用于OLAP**，**数据仓库，数据挖掘等查询密集型应用。**
>
> > OLTP（联机事务处理）、OLAP（联机分析处理）
>
> 2.**带有局部性群组的列存储**：是指根据需要将原来不存储在一起的数据，以列族为单位存储至单独的字表中。如用户对网站排名、语言等分析信息感兴趣，那么可以将这些列族放在单独的子表减少无用信息读取，改善存取效率。
> 3**.LSM-Tree**：日志结构合并树，与前面介绍的存储结构有所不同，前面的存储结构在描述如何序列化逻辑数据结构，而LSM-Tree描述的则是为了满足高效、高性能、安全地读写的要求，如何有效地利用内存和磁盘存储。主要用于解决日志记录索引的问题

> **查询模型**
>
> 1.**结合SQL数据库**：一个最直接的方式是通过将NoSQL数据库贝到关系数据库或者文本数据库来提供查询能力。
> 2.**分散/集合本地搜索**：一些NoSQL数据库提供本地数据库内的索引和查询处理机制。在这种情况下，我们可以让查询处理器将查询广播到DHT（分散哈希表）中的所有节点，在每个节点上将会执行查询，并将结果送回到查询处理器，然后查询处理器将结果聚集成一个单一响应。
> 3.**分布式B+树**：其基本思路是为了定位B+树的根节点哈希要搜索的属性。根节点的“值”包含其孩子节点的ID。
> 4.**前缀哈希表/分布式Trie**：前缀哈希表（Prefix Hash Table，PHT，又名分布式Trie）目的是一个树形数据结构。在这个树形结构中，从根节点到叶子的每一条路径上均包含了键值的前，并且每个Trie中的节点都包含了它是谁的前的所有数据

> **存储模式**
>
> 其他存储模式：
> 1**.多值数据库**：是分布式数据库系统的重要分支。它速度快，体积小，比关系数据库便宜，很快得到了认可。它提供了一个通用的数据集成与访问平台，屏蔽了现有各数据库系统不同的访问方法和用户界面，给用户呈现出一个访问多种数据库的公共接口。**多值数据库系统使用的多个异构的数据源之间可以共享它们相互依赖的数据，并具有相互操作的能力**。常见的多值数据库有Rocket U2，Extensible Storage Engin（ESE/NT）、Openlnsight 和OpenQM等。
> 2.**时间序列与流数据库**：时间序列数据库是指具有**处理时间序列数据**，能对时间数据数组建立索引的优化数据库系统。**流数据库又被称为实时数据库**，这是一种使用实时处理数据的方式来处理状态不断变化的数据库系统。对时间序列的数据库提出实时的处理要求，那么时间数据库就是流数据库。常见的时间序列数据库InfluxDB、OpenTSDBo
> 3.**网格和云数据库**：是基于网格计算或者云计算的数据库

## NoSQL数据库种类（重点）

> **重点记忆分类**
>
> 除了关系型数据库，其他的都叫nosql
>
> ![image-20240424144409960](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243807.png)
>
> ![image-20240330153342746](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243808.png)

### 文档数据库

> **BaseX、CouthDB、MongoDB、Lotus Notes、markLogic Server**
>
> | 数据库      | 优点                                                         | 缺点                       |
> | ----------- | ------------------------------------------------------------ | -------------------------- |
> | **MongoDB** | **无表结构**、比关系数据库**更快**、可以添加索引来高速处理、提供json和xml，**水平扩展能力好，高可用性，丰富的查询语言** | 不支持join查询             |
> | **BaseX**   | **轻巧高性能的xml**                                          |                            |
> | CouchDB     | 健壮性、高并发和容错，基于json，可以用js操作CouchDB，可以通过map/reduce函数来生成自己的试图 |                            |
> | Lotus Notes | 群件系统                                                     | 不适合关系数据库的事务处理 |
>
> 

![image-20240403141952655](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243809.png)

![image-20240403142247557](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243810.png)

![image-20240403142256419](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243811.png)

![image-20240403142354650](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243812.png)

![image-20240403142405195](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243813.png)

![image-20240403142440715](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243814.png)

### 键值存储

> **Memcached、Redis、Dynamo、Project Voldemort、Tokyo Tyrant、Riak、Scalaries**
>
> | 数据库    | 优点                                                         | 缺点                                                         |
> | --------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
> | Memcached | **高性能的分布式内存对象缓存系统，减少数据库访问次数，提高动态web应用的速度、提高可扩展性** | 并发能力受限                                                 |
> | Redis     | **基于内存存储和运行，性能非常出色，支持保存List链表和Set集合的数据结构，支持对List进行各种操作，单个value最大限制是1GB**（Memcached是1MB） | 容易受物理内存限制，不能用作海量数据的高性能读写，没有可扩展机制 |
>
> 

![image-20240403142609185](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243816.png)

![image-20240403142629931](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243817.png)

![image-20240403142711491](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243818.png)  

### 列存储

> **Bigtable、Hypertable、HBase、Cassandra**
>
> | 数据库     | 优点                                                         | 缺点 |
> | ---------- | ------------------------------------------------------------ | ---- |
> | Bigtable   | 通过主键组织海量数据、并实现高效的查询                       |      |
> | Hypertable | 开源、高性能、可伸缩                                         |      |
> | **HBase**  | **高性能、高可靠、面向列、可伸缩**                           |      |
> | Cassandra  | 分布式、基于列的结构化、高扩展，不是数据库，而是分布式网络服务 |      |

![image-20240403142820663](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243819.png)

> **Google云计算平台技术架构**
>
> 1. **分布式文件系统GSF**（Google distributed file system）
> 2. 并行数据处理模型：MapReduce
> 3. **分布式锁：chubby**
> 4. 结构化数据表：BigTable

### 图存储

> **FlockDB、Neo4j（高性能、可扩展、大规模）**

![image-20240403142913741](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243820.png)

![image-20240403142941371](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243821.png)

## 应用案例与新技术

### HBase数据库

![image-20240403143049893](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243822.png)

### 云数据库GeminiDB

![image-20240403143221405](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243823.png)

# 系统开发和运行知识

![image-20240322093535652](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243824.png)

## 软件工程基础

### 信息系统生命周期

- 软件工程基本原理：用分阶段的生命周期计划严格管理、坚持进行阶段评审、实现严格的产品控制采用现代程序设计技术、结果应能清楚的审查、开发小组的人员应少而精、承认不断改进软件工程实践的必要性

- **软件工程的基本要素：方法、工具、过程**
- **软件生命（存）周期**：可行性分析与项目开发计划、需求分析、概要设计（选择系统解决方案，规划子系统）、详细设计（设计子系统内部具体实现）、编码、测试、维护

![image-20240331153938403](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243825.png)

> **中间的五项目周期需要了解，了解定义及输出**
>
> - 1**.系统规划阶段**：任务是对组织的环境、目标及现行系统的状况**进行初步调查**，根据组织目标和发展战略确定信息系统的发展战略，**对建设新系统的需求做出分析和预测**，同时考虑建设新系统所受的各种约束，研究建设新系统的必要性和可能性。根据需要与可能，给出制建系统的备选方案
>
>   > **输出：可行性研究报告、系统设计任务书。**
>   >
>   > **系统设计任务书是系统规划阶段，系统设计说明书是系统设计阶段**
>
> - 2.**系统分析阶段**：任务是根据系统设计任务书所确定的范围，**对现行系统进行详细调查**，描述现行系统的业务流程，指出现行系统的局限性和不足之处，确定新系统的基本目标和逻辑功能要求，即提出新系统的逻辑模型。系统分析阶段**又称为逻辑设计阶段（设计出整个系统的逻辑模型）**。这个阶段**是整个系统建设的关键阶段**，**也是信息系统建设与一般工程项目的重要区别所在。**
>
>   > **输出：系统说明书（需求规格说明书--软件工程的图纸）**
>
> - 3.**系统设计阶段**：系统分析阶段的任务是回答系统“做什么”的问题，**而系统设计阶段要回答的问题是“怎么做”**。该阶段的任务是根据系统说明书中规定的功能要求，**具体设计实现逻辑模型的技术方案，也就是设计新系统的物理模型。这个阶段又称为物理设计阶段，可分为总体设计（概要设计）和详细设计**两个子阶段。
>
>   > **输出：系统设计说明书（概要设计、详细设计说明书）。**
>   >
>   > **任务书是系统规划阶段，说明书是系统设计阶段**
>
> - 4.**系统实施阶段：是将设计的系统付诸实施的阶段**。这一阶段的任务包括计算机等设备的购置、安装和调试程序的**编写和调试**、人员培训、数据文件转换、系统调试与转换等。这个阶段的特点是几个互相联系、互相制约的任务同时展开，必须精心安排、合理组织。系统实施是按实施计划分阶段完成的，每个阶段应写出实施进展报告。系统测试之后写出系统测试分析报告。
>
>   > **输出：实施进展报告（周报）、系统测试分析报告。**
>
> - 5.**系统运行和维护阶段**：系统投入运行后，需要经常进行维护和评价，记录系统运行的情况，根据一定的规则对系统进行必要的修改，评价系统的工作质量和经济效益
>
> > **完工后的产品：操作手册**
>
> ![image-20240331170351219](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243826.png)

### 软件能力成熟度模型CMM

　CMM是Capability Maturity Model for Software的简称，中文叫“软件能力成熟度模型”，是对组织软件过程能力的描述。CMM的核心是把软件开发视为一个过程，并根据这一原则对软件开发和维护进行过程监控和研究，以使其更加科学化、标准化，使企业能够更好的实现商业目标。它侧重于软件过程开发的管理及软件工程能力的改进与评估，因此CMM被用作评价软件承包商能力并帮助组织改善软件过程质量，是目前国际上最流行、最实用的一种软件生产过程标准，成为当今企业从事规模软件生产不可缺少的一项内容。

| 能力等级                   | 特点                                                         | 关键过程区域                                                 |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **初始级（initial)**       | 软件过程的特点是**杂乱无章**，有时甚至很混乱，几乎没有明确定义的步骤，项目的成功**完全依赖个人的努力和英雄式核心人物的作用**。<br/> | 不可复制的，混乱的                                           |
| **可重复级（Repeatable）** | **建立了基本的项目管理过程和实践来跟踪项目费用**、进度和功能特性，**有必要的过程准则来重复以前在同类项目中的成功**<br/> | **软件配置管理、软件质量保证**、软件子合同管理、软件项目跟踪与监督、软件项目策划、软件需求管理<br/> |
| **已定义级（Defined）**    | 管理和工程两方面的**软件过程已经文档化、标准化，并综合成整个软件开发组织的标准软件过程**。**所有项目都采用根据实际情况修改后得到的标准软件过程来发和维护软件**。<br/> | **同行评审、组间协调**、软件产品工程、集成软件管理、培训大纲、组织过程定义、组织过程集点 |
| **已管理级（Managed）**    | **制定了软件过程和产品质量的详细度量标准**。对软件过程和产品质量有定量的理解和控制<br/> | **软件质量管理和定量过程管理**                               |
| **优化级（optimized)**     | 加强了定量分析，通过来自过程质量反馈和来自新观念、新技术的反馈过程能**不断持续地改进** | **过程更改管理、技术改革管理**和缺陷预防                     |

![image-20240331170822046](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243827.png)

### 能力成熟度模型集成CMMI

CMMI的全称为Capability Maturity Model Integration，即能力成熟度模型集成，**是若干过程模型的综合和改进**，不仅仅软件，而是**支持多个工程学科和领域**的系统的、一致的过程改进框架，能适应现代工程的特点和需要，能提高过程的质量和工作效率

- CMMI两种表示方法：
- （1）**阶段式模型：类似于CMM， 它关注组织的成熟度**，五个成熟度模型如下

| 能力等级     | 特点<br/>              | 关键过程区域<br/>                                            |
| ------------ | ---------------------- | ------------------------------------------------------------ |
| **初始级**   | 过程不可预测且缺控制   |                                                              |
| **已管理级** | 过程为项目服务<br/>    | 需求管理、项目计划、配置管理、项目监督与控制、供应商合同管理、度量和分析、过程和产品质量保证<br/> |
| **已定义级** | 过程为组织服务<br/>    | 需求开发、技术解决方案、产品集成、验证、确认组织级过程焦点、组织级过程定义、组织级培训、集成项目管理、风险管理、集成化的团队、决策分析和解决方案、组织级集成环境<br/> |
| 定量管理     | 过程已度量和控制集中于 | 组织过程性能、定量项目管理<br/>                              |
| **优化级**   | **过程改进和优化**     | 组织级改革与实施、因果分析和解决方案                         |

- （2）连续式模型：关注每个过程域的能力，一个组织对不同的过程域可以达到不同的过程域能力等级。

### 软件生存周期模型

![image-20240404155244516](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243828.png)

#### 瀑布模型

> **定义明确，时间严格要求，适用于结构化方法开发**

- 瀑布模型（SDLC：布模型是一个经典的软件生命周期模型，**一般将软件开发分为**：可行性分析（计划）、需求分析、软件设计（概要设计、详细设计）、编码（含单元测试）、测试、运行维护等几个阶段。

  ![image-20240331171008571](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243829.png)

- 瀑布模型特点

  （1）**从上一项开发活动接受该项活动的工作对象作为输入**

  （2）**利用这一输入，实施该项活动应完成的工作内容**

  （3）**给出该项活动的工作成果，作为输出**传给下一项开发活动。

  （4）**对该项活动的实施工作成果进行评审**。若其工作成果得到确认，则继续进行下一项开发活动；否则返回前一项，甚至更前项的活动。尽量减少多个阶段间的反复。以相对来说较小的费用来开发软件

- 瀑布模型假设，**一个待开发的系统需求是完整的、简明的、一致**的，而且可以先于设计和实现完成之前产生。

- **瀑布模型的优点**

  容易理解，管理成本低；强调开发的阶段性早期计划及需求调查和产品测试

- **不足之处**

  **客户必须能够完整、正确和清晰地表达他们的需要；在开始的两个或三个阶段中，很难评估真正的进度状态**；当接近项目结束时，出现了大量的集成和测试工作，**直到项目结束之前，都不能演示系统的能力**。在澡布模型中，需求或设计中的**错误往往只有到了项目后期才能够被发现，对于项目风险的控制能力较弱，从而导致项目常常延期完成，开发费用超出预算**

![image-20240331172552799](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243830.png)

![image-20240401201136139](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243831.png)

#### 螺旋模型

> **在于风险，只适用于庞大复杂有高风险的系统，尤其是内部的**

-   **螺旋模型是一个演化软件过程模型，将原型实现的送代特征与线性顺序（布）模型中控制的和系统化的方面结合起来。在螺旋模型中，软件开发是一系列的增量发布。**

  ![image-20240331171420457](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243832.png)

  > **考风险分析，遇到风险分析，就选螺旋模型**

- **开发过程具有周期性重复的螺旋线状。四个象限分别标志每个周期所划分的四阶段：制订计划、风险分析、实施工程和客户评估。螺旋模型强调了风险分析，特别适用于庞大而复杂的、高风险的系统**

  （1）制订计划。确定软件的目标，选定实施方案，明确项日开发的限制条件。  
  （2）**风险分析。分析所选的方案，识别风险，消除风险**
  （3）实施工程。实施软件开发，验证阶段性产品。
  （4）用户评估。评价开发工作，提出修正建议，建立下一个周期的开发计划。

![image-20240331172839957](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243833.png)

#### V模型

> **强调每个阶段都要进行测试，适用传统项目**

V模型从整体上看起来，就是一个V字型的结构，由左右两边组成。左边的下画线分别代表了需求分析、概要设计、详细设计、编码。右边的上画线代表了单元测试、集成测试、系统测试与验收测试。V模型的特点如下：
  （1）**单元测试的主要目的是针对编码过程中可能存在的各种错误**
  （2）**集成测试的主要目的是针对详细设计中可能存在的问题**

  （3）**系统测试主要针对概要设计，检查系统作为一个整体是否有效地得到运行；**
  （4）**验收测试通常由业务专家或者用户进行，以确认产品能真正符合用户业务上的需要**
  （5）V模型用于需求明确和需求变更不频繁的情形

![image-20240331171636527](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243834.png)

> **记忆：单编、集详、系概、验需**

#### 原型模型

> **需求不明确，对应原型化开发方法**

- **原型化模型第一步就是创建一个快速原型**，能够满足项目干系人与未来的用户可以与原型进行交互，再通过与相关干系人进行充分的讨论和分析，最终**弄清楚当前系统的需求**，进行了充分的了解之后，在原型的基础上开发出用户满意的产品

- 原型法认为在很难一下子全面准确地提出用户需求的情况下，原型应当具备的特点如下。

   （1）**实际可行**

   **（2）具有最终系统的基本特征**

   **（3）构造方便、快速，造价低。原型法的特点在于原型法法对用户的需求是动态响应、逐步纳入的。**

#### 增量模型

-  **增量模型：首先开发核心模块功能**，而后与用户确认，之后再开发次核心模块的功能，即每次开发一部分功能，并与用户需求确认，最终完成项目开发**优先级最高的服务最先交付。**

-  特点：但由于并不是从系统整体角度规划各个模块，因此**不利于模块划分。难点在于如何将客户需求划分为多个增量**。与原型不用的是**增量模型的每一次增量版本都可作为独立可操作的作品**，而原型的构造一般是为了演示

-  **优点**

   瀑布模型的一个变体，具有瀑布模型的所有优点。第一个可交付版本所需要的成本和时间很少：开发由增量表示的小系统所承担的风险不大；由于很快发布了第一个版本，因此可以减少用户需求的变更：运行增量投资，即在项目开始时，可以仅对一个或两个增量投资。

-  **增量模型的不足之处**

   如果没有对用户的变更要求进行规划，那么产生的**初始增量可能会造成后来增量的不稳定；如果需求不像早期思考的那样稳定和完整，那么一些增量就可能需要重新开发，重新发布：管理发生的成本、进度和配置的复杂性，可能会超出组织的能力。**

![image-20240331172306505](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243835.png)

#### 演化模型

​	演化模型主要针对事先不能完整定义需求的软件开发，是在快速开发一个原型的基础上，根据用户在使用原型的过程中提出的意见和建议对原型进行改进，获得原型的新版本。重复这过程，最终可得到令用户满意的软件产品。
​     **演化模型的主要优点是，任何功能一经开发就能进入测试，以便验证是否符合产品需求可以帮助引导出高质量的产品要求。其主要缺点是，如果不加控制地让用户接触开发中尚未稳定的功能，可能对开发人员及用户都会产生负面影响。**

#### 喷泉模型

> **在于用户，适用面向对象的开发方法**

- **喷泉模型：是一种以用户需求为动力，以对象作为驱动**的模型，适合于**面向对象的开发方法**。使开发过程具有选代性和无间性。

- 它克服了瀑布模型不支持软件重用和多项开发活动集成的局限性。**喷泉模型使开发过程具有选代性和无间隙性。送代意味着模型中的开发活动常常需要重复多次，在选代过程中不断地完善软件系统**。无间隙是指在开发活动（如分析、设计、编码）之间不存在明显的边界，也就是说
  它不像布模型那样，需求分析活动结束后才开始设计活动，设计活动结束后才开始编码活动
  而是允许各开发活动交叉、选代地进行。

  ![image-20240402171935063](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243836.png)

#### 快速模型

- 基于构件的开发模型**CBSD（也叫快速开发模型**）：利用**预先包装的构件来构造应用系统**。构件可以是组织内部开发的构件，也可以是商品化成品软件构件

  **特点是增强了复用性**，在系统开发过程中，会构建一个构件库，供其他系统复用，因此可以提高可靠性，节省时间和成本。

#### 形式化模型

- **形式化方法模型：建立在严格数学基础**上的一种软件开发方法，主要活动是生成计算机软件形式化的数学规格说明。

### 软件开发方法

#### 结构化方法

> **面向数据流的开发方法，需求要明确，不适合解决大规模、特别复杂、难以适应的项目**

-   结构是指系统内各个组成要素之间的相互联系、 相互作用的框架（多个模块构成）

- 结构化分析是根据分解与抽象的原则，按照系统中数据处理的流程，**用数据流图来建立系统的功能模型**，从而完成需求分析工作。结构化设计是根据模块独立性准则、软件结构优化准则将数据流图转换为软件的体系结构，用软件结构图来建立系统的物理模型，实现系统的概要设计。结构化程序设计是根据结构程序设计原理，将每个模块的功能用相应的标准控制结构表示出来，从而实现详细设计

- **结构化方法也称为生命周期法**，是一种传统的信息系统开发方法，**由**

  - **结构化分析（Structured Analysis,SA）**

    > 产出三大模型＋一本数据词典
    >
    > 功能模型--对应数据流图
    >
    > 行为模型--对应状态转换图
    >
    > 数据模型--对应ER图
  
  -   **结构化设计（Structured Design，SD）**
  
  -   **结构化程序设计（Structured Programming，SP）**


  三部分有机组合而成  ，其**精髓是自顶向下、逐步求精和模块化设计**

  > **结构化方法与生命周期的对应关系**
  >
  > - **结构化分析==系统分析阶段（系统说明书，需求规格说明书）**
  > - **结构化设计==系统设计阶段（系统设计说明书）**
  > - **结构化程序==系统实施阶段（测试报告）**

- **结构化方法的主要特点**

 （1）**开发目标清晰化**。结构化方法的系统开发遵循“**用户第一**”的原则。

> 用户第一又有点对应喷泉模型

（2）**开发工作阶段化**。每个阶段工作完成后，**要根据阶段工作目标和要求进行审查**，这使各阶段工作有条不素地进行，便于项目管理与控制。

 （3）**开发文档规范化**。结构化方法每个阶段工作完成后，**要按照要求完成相应的文档**，以保证各个工作阶段的衔接与系统维护工作的遍历。

 （4）**设计方法结构化。在系统分析与设计时，从整体和全局考虑，自顶向下地分解**；**在系统实现时，根据设计的要求，先编写各个具体的功能模块，然后自底向上逐步实现整个系统。**

> 自底向上就是地基，自顶向下就是为了主要目的

- 结构化方法的不足和局限

  （1）**开发周期长**：按顺序经历各个阶段，直到实施阶段结束后，用户才能使用系统

   （2）**难以适应需求变化**：不适用于需求不明确或经常变更的项目。

   （3）**很少考虑数据结构**：结构化方法是一种面向过程，面向数据流的开发方法，很少考虑数据结构

- **结构化方法常用工具**

  结构化方法一般利用图形表达用户需求，常用工具有数据流图、数据字典、结构化语言、判定表以及判定树等

- **结构化方法基本原则：功能的分解与抽象**

  ![image-20240401205300669](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243837.png)

#### 面向对象方法

> **适用于大规模、特别复杂的项目，各种情况都可以采用面向对象的方法**

- 面向对象（Obiect-Oriented，OO）方法认为，客观世界是由各种对象组成的，**任何事物都是对象，每一个对象都有自己的运动规律和内部状态，都属于某个对象类**，是该对象类的一个元素。复杂的对象可由相对简单的各种对象以某种方式而构成，不同对象的组合及相互作用就构成了系统

- 面向对象开发方法**包括面向对象分析、面向对象设计和面向对象实现**。面向对象开发方法有Booch方法、Coad方法和OMT方法等。为了统一各种面向对象方法的术语、概念和模型1997年推出了**统一建模语言（unified Modeling Language，UML）。它是面向对象的标准建模语言，通过统一的语义和符号表示，使各种方法的建模过程和表示统一起来，已成为面向对象建模的工业标准。**

- **面向对象方法的特点**

   （1）使用OO方法构造的系统**具有更好的复用性**，其关键在于建立一个全面合理、统一的模型**（用例模型和分析模型）**

  > 对应软件的用例图和类图

   （2）OO方法也划分阶段，但其中的**系统分析、系统设计和系统实现三个阶段之间已经没有“缝隙**”。也就是说，这三个阶段的**界限变得不明确**，某项工作既可以在前一个阶段完成，也可以在后一个阶段完成；前一个阶段工作做得不够细，在后一个阶段可以补充

   （3）面向对象方法**可以普遍适用于各类信息系统的开发**

  > **只有面向对象普遍适用于各类信息系统开发**

  - 面向对象方法的**不足**之处

    **必须依靠一定的面向对象技术支持，在大型项目的开发上具有一定的局限性不能涉足系统分析以前的开发环节。**

    当前，一**些大型信息系统的开发，通常是将结构化方法和OO方法结合起来**。首先，使用结构化方法进行自顶向下的整体划分；然后，自底向上地采用方法进行开发。因此，结构化方法和OO方法仍是两种在系统开发领域中相互存的、不可替代的方法

#### 原型化方法

> **与结构化方法是相反的，适用于用户需求不明确，系统规模不大不复杂的情况，对应快速模型**

- **原型化方法也称为快速原型法，或者简称为原型法**。它是一种根据用户初步需求，利用系统开发工具，**快速地建立个系统模型展示给用户**，在此基础上与用户交流，最终实现用户需求的信息系统快速开发的方法

- 按**是否实现功能分类**：分为**水平原型**（行为原型，**功能的导航）、垂直原型（结构化原型，实现了部分功能**）。

  > 水平相当于p了个网页给客户看
  >
  > 垂直相当于做了个简单网站

- **按最终结果分类**：分为抛弃式原型、演化式原型

![image-20240401203551561](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243838.png)

- 原型法的**特点**

  **原型法可以使系统开发的周期缩短、成本和风险降低、速度加快，获得较高的综合开发效益**

  **原型法是以用户为中心**来开发系统的，用户参与的程度大大提高，开发的系统符合用户的需求，因而增加了用户的满意度，提高了系统开发的成功率。

  由于用户参与了系统开发的全过程，**对系统的功能和结构容易理解和接受**，有利于系统的移交，有利于系统的运行与维护。

- 原型法的**不足**之处

  **开发的环境要求高。管理水平要求高**

  由以上的分析可以看出，原型法的**优点主要在于能更有效地确认用户需求。从直观上来看，原型法适用于那些需求不明确的系统开发。事实上，对于分析层面难度大、技术层面难度不大的系统**，适合于原型法开发

  从严格意义上来说，目前的**原型法不是一种独立的系统开发方法，而只是一种开发思想**，它只支持在系统开发早期阶段快速生成系统的原型，没有规定在原型构建过程中必须使用哪种方法。因此，**它不是完整意义上的方法论体系。这就注定了原型法必须与其他信息系统开发方法结合使用**

#### 敏捷开发

> **尽可能早的、持续的对有价值的软件进行交付，使顾客满意，具有灵活性，使用户可以在后期改变需求，适用互联网项目**

**敏捷开发是一种以人为核心、代、循序渐进的开发方法，相对于传统软件开发方法**的“非敏捷”，**更强调程序员团队与业务专家之间的紧密协作、面对面的沟通（认为比书面的文档更有效）、频繁交付新的软件版本**、紧而自我组织型的团队、**能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发中人的作用。**

- **敏捷软件开发宣言**

  1.个体和交互胜过过程和工具

  2.可以工作的软件胜过面面俱到的文档

  3.客户合作胜过合同谈判

  4.响应变化胜过遵循计划

![image-20240401204012951](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243839.png)

> **考点：基本原则**
>
> - **结对编程：一个程序员开发，另一个程序在一旁观察审查代码**，能够有效的提高代码质量，在开发同时对代码进行初步审查，共同对代码负责
>
> - **自适应开发（ASD）**：强调开发方法的**适应性**（Adaptive）。不象其他方法那样有很多具体的实践做法，它更**侧重为软件的重要性提供最根本的基础**，并从更高的组织和管理层次来闸述开发方法为什么要具备适应性
>
> - **水晶方法：每一个不同的项目都需要一套不同的策略、约定和方法论。**
>
> - **特性驱动开发：是一套针对中小型软件开发项目的开发模式。是一个模型驱动的快速选代开发过程**，它强调的是简化、实用、易于被开发团队接受，适用于需求经常变动的项目。
>
> - **极限编程XP：核心是沟通、简明、反馈和勇气**。因为知道计划永远赶不上变化，XP**无需开发人员在软件开始初期做出很多的文档。XP提测试先行**，为了将以后出现bug的几率降到最低
>
> - **并列争球法SCRUM：是一种选代的增量化过程，把每段时间（30天）一次的送代称为一个“冲刺”**，并按需求的优先级别来实现产品，多个自组织和自治的小组并行地递增实现产品
>
>   > **每30天迭代一个产品**
>
> ![image-20240401205350331](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243840.png)

#### 统一过程（RUP）

提供了**在开发组织中分派任务和责任的纪律化方法。它的目标是在可预见的日程和预算前提下，确保满足最终用户需求的高质量产品。**

- **3个显著特点：用例驱动、以架构为中心、选代和增量**

  > 用例：实际的场景

- **4个流程：初始阶段、细化阶段、构建阶段和交付阶段**。每个阶段结束时都要安排一次技术评审，以确定这个阶段的目标是否已经达到

  ![image-20240401204803067](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243841.png)

- 适用：**一个通用过程框架**，可以用于种类广泛的软件系统、，不同的应用领域不同的组织类型、不同性能水平和不同的项目规模

### 软件项目管理

#### 成本估算

> **成本估算模型**

1. **Putnam模型**

   **动态多变量**模型，它是假设在软件开发的**整个生存期中工作量有待定的分布**

2. **cocomo模型**

   最精确、最易于使用的成本估算模型，分为以下三种：

   - （1）基本COCOMO模型：是一个**静态单变量模型，它是对整个软件系统进行估算。**
   
   - （2）中级COCOMO模型：是一个**静态多变量模型，它将软件系统模型分为系统和部件两个层次**，系统由部件构成，它把软件开发所需人力（成本）看作是程序大小和一系列“成本驱动属性”的函数
   
   - （3）详细COCOMO模型：它将软件系统模型分为**系统、子系统和模块三个层次**，它除包括中级模型所考虑的因素外，还考虑了在需求分析、软件设计等每一步的成本驱动属性的影响。
   
     > **第几种就对应的是多少层次，所以只用记Putnam在整个生存期中工作量有待定的分布**

#### 风险分析

> **风险的优先级根据风险暴露决定**

![image-20240404163645510](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243842.png)

![image-20240404173153638](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243843.png)

#### 进度管理

##### Gantt（甘特）图

- **优点：能够清晰描述每个任何何时开始何时结束**，任务的进展情况及任务之间的**并行性**
- **缺点：不能清晰反映各任务之间的依赖关系，难以确认项目的关键**

![image-20240404163917732](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243844.png)

##### 项目计划评审技术（PERT）图

- **优点：不仅给出了每个任务的开始时间、结束时间和完成该任务所需的时间**，还给出了任务之间的关系，即**完成哪些任务后才能完成另一些任务**，具体可以参考关键路径算法
- **缺点：不能反映任务之间的并行关系**

![image-20240404173400838](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243845.png)

![image-20240404173458331](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243846.png)

#### 人员管理

![image-20240404164124682](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243847.png)

> **沟通路径的计算**
>
> - **无主程序员：n*(n-1)/2**
> - **主程序员：n-1**
>
> 其中：n为开发人员的人头数

![image-20240407152422715](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243848.png)

## 系统分析

### 概念

> **逻辑模型**

  系统分析过程一般按如图所示的逻辑进行：
  （1）认识、理解当前的现实环境，**获得当前系统的“物理模型”**
  （2）从当前系统的“物理模型”**抽象出当前系统的“逻辑模型”**
  （3）对当前系统的“逻辑模型”进行分析和优化，**建立目标系统的“逻辑模型**”
  （4）对目标系统的逻辑模型具体化（物理化），**建立目标系统的物理模型**。

> (4)属于系统设计阶段

![image-20240402140000442](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243849.png)

  **系统开发的目的是把现有系统的物理模型转化为目标系统的物理模型**，即图中所描述的路径，**而系统分析阶段的结果是得到目标系统的逻辑模型**。逻辑模型反映了系统的功能和性质，而物理模型反映的是系统的某一种具体实现方案

### 需求分析

#### 需求分析的任务

1. 确定软件系统的综合要求
2. 分析软件系统的数据要求
3. 导出系统的逻辑模型
4. 修正项目开发计划
5. 如有必要，可开发一个原型系统

> 需求分析解决“做什么”问题，设计阶段阶段“怎么做”问题

#### 需求的分类

1. **功能需求：所开发的软件必须具备怎么样的功能**
2. **非功能需求：指产品必须具备的属性或品质，如可靠性、性能、相应时间、容错性和扩展性等**
3. **设计约束**：也称为限制条件、补充规约，这通常是对解决方案的一些约束说明

### 结构化分析方法SA

结构化分析与设计方法是一种**面向数据流**的传统软件开发方法，，**它以数据流为中心构建软件的分析模型和设计模型**。结构化分析（Structured Analysis，SA）结构化设计（Structured Design，SD）和结构化程序设计（Structured Programming Design，SPD）构成了完整的结构化方法

> **数据流图的数据流分为变换流和事务流**
>
> 结构化程序设计语言：c语言
>
> 面向对象：c++、java

结构化方法SA的**分析结果由以下几部分组成：一套分层的数据流图、 一本数据词典、一组小说明（也称加工逻辑说明）、补充材料。**

![image-20240404153547461](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243850.png)



#### 数据流图DFD

> **对应功能模型，描述了数据在系统中如何传送和变化及如何对数据流进行变换的功能或子功能，是设计阶段的接口设计；描述对数据的处理流程**
>
> 行为模型--对应状态转换图

**Data Flow Diagrom，是一种便于用户理解、分析系统数据流程的图像工具**，精确地在逻辑上描述系统的功能、输入、输出和数据存储等

基本图形元素：**外部实体、加工、数据存储、数据流系统设计**

![image-20240403145838629](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243851.png)

- 1）**数据流**：由一组固定成分的数据组成，表示数据的流向。在DFD中，**数据流的流向必须经过加工**

- 2）**加工**：描述了**输入数据流到输出**数据流之间的变换，数据流图中**常见的三种错误如图所示：**

  - 加工3.1.2有输入但是没有输出，称之为“黑洞”

  - 加工3.1.3有输出但没有输入。称之为“奇迹”

  - **加工3.1.1中输入不足以产生输出，我们称之为“灰洞”**

    > **下午主要考第三种错误，即灰洞**
    >
    > **同时，数据存储可以允许只输入不输出；可能也允许没输入有输出（原本就有）**
    
    ![image-20240403151459808](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243852.png)

- 3）**数据存储**：用来存储数据

- 4）**外部实体（外部主体）**：是指**存在于软件系统之外的人员或组织**，它指出系统所需数据的发源地（源）和系统所产生的数据的归宿地（宿）

  >  实体是一个名词
  
- **5）源/谭（source/sink）：表示系统和环境的接口，属于系统之外的实体**

![image-20240403151821001](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243853.png)

![image-20240403152759085](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243854.png)

> **数据流图的设计原则**
>
> **（1）数据守恒原则**：对任何一个加工来说，其所有输出数据流中的数据必须能从该加工的输入数据流中直接获得，或者说是通过该加工能产生的数据
> **（2）守恒加工原则**：对同一个加工来说，输入与输出的名字必须不相同， 即使它们的组成成分相同
> （3）对于**每个加工，必须既有输入数据流，又有输出数据流**
> （4）外部实体与外部实体之间不存在数据流
> （5）外部实体与数据存储之间不存在数据流
> （6）数据存储与数据存储之间不存在数据流
> **（7）父图与子图的平衡原则：子图的输入输出数据流同父图相应加工的输入输出数据流必须一致，此即父图与子图的平衡。父图与子图之间的平衡原则不存在于单张图**
> （8）数据流与加工有关，且必须经过加工。



#### 数据字典DD

数据流图描述了系统的分解，但没有对图中各成分进行说明。**数据字典就是为数据流图中的每个数据流、文件、加工，以及组成数据流或文件的数据项做出说明，进行描述；其中对加工的描述称为“小说明”，也可以称为“加工逻辑说明”**
**数据字典有以下4类条目：数据流、数据项、 数据存储和基本加工**

> 没有描述外部实体，但有了数据项

![image-20240404164803366](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243855.png)

#### 加工逻辑的描述

**加工逻辑也称为“小说明”。常用的加工逻辑描述方法有结构化语言、判定表和判定树3种。**

> **结构化语言就是伪代码（如C）**
>
> ![image-20240506170148463](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243856.png)

##### 结构化语言

![image-20240404165029518](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243857.png)

##### 判定表

![image-20240404165119156](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243858.png)

##### 判定树

![image-20240404165130625](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243859.png)

### 面向对象分析方法OO

#### 概念

- （1）对象：在面向对象的系统中，对象是基本的运行时的实体，它既包括数据（属性），也包括作用于**数据的操作（行为）**。
- （2）**消息：对象之间进行通信的一种构造叫作消息**
-  （3）类：一个类定义了一组大体上相似的对象。类是在对象之上的抽象，对象是类的具体化，是类的实例。
- （4）继承：继承是父类和子类之间共数据和方法的机制。这是类之间的一种关系，在定义和实现个类的时候，可以在二个经存在的类的基础上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。
- **（5）多态：在收到消息时，对象要予以响应。不同的对象收到同一消息可以产生完全不同的结果，这一现象叫作多态**
- （6）**动态绑定和静态绑定：绑定是一个把过程调用和响应调用所需要执行的代码加以结合的过程。**在一般的程序设计语言中，**绑定是在编译时进行的，叫作静态绑定。动态绑定则是在运行时进行的**。因此，一个给定的过程调用和代码的结合知道调用发生时才进行

#### UML

> **解题技巧：记一记+字面意思**
>
> unified modeling language统一建模语言

- （1）**类图**：类图描述一组**类、接口、协作和它们之间的关系。**

  > **主要用于对系统的静态设计视图建模**
  > **可以对逻辑数据库模式建模；对系统的词汇建模；对简单的协作建模**

  ![image-20240508200904328](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243860.png)

- （2）**对象**图：**对象图描述一组对象及它们之间的关系**

  > **描述了类实例的静态快照。**

- （3）**用例**图：用例图描述一组用例、**参与者与它们之间的关系**

  ![image-20240508200919502](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243861.png)

以下是**交互图（动态**方面的）

- （4）**序列图**：是场景的图形化表示，描述了以时间顺序组织的对象直接的交互活动，**它由一组对象或参与者以及它们之间可能发送的消息构成**。**交互图专注于系统的动态视图。序列图是场景的图形化表示，描述了以时间顺序组织的对象之间的交互活动，是强调消息的时间次序的交互图**

  ![image-20240508201152591](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243862.png)

- （5）**通信图**：**它强调收发消息的对象或参与者的结构组织**。**序列图强调的是时序，通信图强调的是对象之间的组织结构（关系）。**

- （6）**状态图**：状态图描述一个状态机，**它由状态、转换事件和活动组成**。**状态图关注系统的动态视图。**

  > **用于接口、类和协作的行为建模（根据状态推出行为）**

  ![image-20240508201448221](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243863.png)

- （7）**活动图**：活动图是一种特殊的状态图，它展现了在系统内**从一个活动到另一个活动的流程**。**活动图专注于系统的动态视图，它强调对象间的控制流程**

  > **用于系统的功能建模；强调控制流程**

**以下是静态模式**

- （8）**构件图：构件图描述一组构件之间的组织和依赖。构件图专注于系统的静态实现视图。它与类图相关，通常把构件映射为一个或多个类、接口或协作**
- （9）**部署图：部署图描述了运行时的处理节点以及其中的构件的配置。部署图给出了体系结构的静态实施视图。它与构件图相关，通常一个节点包含一个或多个构件**

## 系统设计

> **物理模型**
>
> **分为概要设计和详细设计**

### 系统设计步骤

​	系统设计的主要目的就是为系统制定蓝图，在各种技术和实施方法中权衡利，精心设计，合理使用各种资源，最终勾画出新系统的详细设计方案。
系统设计分为概要设计和详细设计。

#### 概要设计的基本任务

 （1）设计软件系统**总体结构**
将一个复杂的系统按功能划分成模块；**确定每个模块的功能；确定模块之间的调用关系；确定模块之间的接口**，即模块之间传递的信息；评价模块结构的质量。
 （2）**总体的数据结构及数据库设计**
 （3）**编写概要设计文档**
**文档主要有概要设计说明书、数据库设计说明书、用户手册以及修订测试计划**
 （4）**评审**
对设计部分是否完整地实现了需求中规定的功能、性能等要求进行评审

#### 详细设计的基本任务

详细设计阶段的根本目标是确定应该怎样具体地实现所要求的系统。

（1）对每个模块进行详细的**算法设计**。
 （2）对**模块内的数据结构**进行设计。
 （3）对数据库进行**物理设计，即确定数据库的物理结构**
 （4）其他设计。

> 代码设计、输入输出设计、用户界面设计

 （5）**编写详细设计说明书**
 （6）评审.对处理过程的算法和数据库的物理结构都要评审

### 系统设计基本原理

> **系统设计基本原理：抽象、模块化、信息隐蔽、模块独立**

#### 抽象

抽象是一种技术，重点说明一个实体的本质方面，而忽略或者盖不很重要或非本质的方面。

#### 模块化

在软件的体系结构中，模块是可组合、分解和更换的单元。模块化是指将一个待开发的软件分解成若干个小的简单部分-  一模块，每个模块可独立地开发、测试，最后组装成完整的程序。模块化的目的是使程序的结构清晰，容易阅读、理解、测试和修改

#### 信息隐蔽

信息隐蔽是开发整体程序结构时使用的法则，即将每个程序的成分隐蔽或封闭在一个单一的设计模块中，定义每一个模块时尽可能少地显露其内部的处理。信息隐蔽原则对提高软件的可修改性、可测试性和可移植性都有重要的作用

#### 模块独立（内聚和耦合）


  **衡量模块独立程度的标准有两个：耦合性和内聚性**。

  > **高内聚低耦合**

#### 内聚

**内聚程度从低到高如下表所示：**

> **内聚（内部的聚集程度）就是一个模块内部的功能点的关联（紧密）程度。内聚性越低，模块内的独立性越差，内聚越高越好**。

| 内聚分类     | 定义<br/>                                                    | 记忆关键字                           |
| ------------ | ------------------------------------------------------------ | ------------------------------------ |
| **偶然**内聚 | 一个模块内的各处理元素之间**没有任何联系**                   | **无直接关系**<br/>                  |
| **逻辑**内聚 | 模块内执行若干个逻辑上相似的功能，通过参数确定该模块完成哪一个功能<br/> | **逻辑相似、参数决定**               |
| **时间**内聚 | 把需要同时执行的动作组合在一起形成的模块。<br/>              | **同时执行**。<br/>                  |
| **过程**内聚 | 一个模块完成多个任务，这些任务必须按指定的过程执行<br/>      | **必须按指定的过程执行**             |
| **通信**内聚 | 模块内的所有处理元素都在**同一个数据结构**上操作，或者各处理使用相同的输入数据或者产生相同的输出数据 | **相同数据结构、输入输出相同**<br/>  |
| **顺序**内聚 | 一个模块中的各个处理元素都密切相关于同一功能且**必须顺序执行**，前一个功能元素的输出是下一个功能元素的输入<br/> | **顺序执行、输入为输出，类似管道\|** |
| **功能**内聚 | 最强的内聚，模块内的所有元素共同作用完成一个功能，缺一不可。 | **共同作用、缺一不可**               |

#### 耦合

**耦合程度从低到高：**

> **耦合（不同耦合之间的联系紧密程度）是针对模块与模块之间的联系。耦合性越高，模块独立性越差，耦合越低越好**。
>
> **耦合程度不取决于模块提供的功能数**，而**取决于调用模块的方式、通过接口的信息类型和各个模块之间接口的复杂程度**

| 耦合分类       | 定义                                                         | 记忆关键字                                           |
| -------------- | ------------------------------------------------------------ | ---------------------------------------------------- |
| **无直接**耦合 | 两个模块之间没有直接的关系，它们分别从属于不同模块的控制与调用，不传递任何信息 | **无直接关系**                                       |
| **数据**耦合   | 两个模块之间有调用关系，传递的是简单的数据值，相当于高级语言中的值传递 | **传递数据值调用**                                   |
| **标记**耦合   | 两个模块之间传递的是数据结构                                 | **传递数据结构**                                     |
| **控制**耦合   | 一个模块调用另一个模块时，传递的是控制变量，被调用模块通过该控制变量的值有选择的执行模块内的某一功能 | **控制变量、选择执行某一功能。类似于PV操作**         |
| **外部**耦合   | 模块间通过软件之外的环境联合（如I\O将模块合到特定的设备、格式、通信协议上）时。 | **软件外部环境**                                     |
| **公共**耦合   | 通过一个公共数据环境相互作用的那些模间的合。                 | **公共数据结构，类似于全局变量，与传递数据结构不同** |
| **内容**耦合   | 当一个模直接使用另一个模块的内部数据，或通过非正常入口转入另一个模块内部时。 | **模块内部关联**                                     |

![image-20240402142106417](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243864.png)

### 系统总体结构设计

> **设计原则：适中，既不能过大也不能过小**

- 系统总体结构设计是要根据系统分析的要求和组织的实际情况**对新系统的总体结构形式和可利用的资源进行大致设计**，这是一种宏观、总体上的设计和规划。

- **系统结构设计原则：**

  （1）分解-协调原则。

  （2）自顶向下的原则。

  （3）信息隐蔽、抽象的原则

  （4） 一致性原则。

  （5）明确性原则

  （6）模块之间的耦合尽可能小，模块的内聚度尽可能高

  （7）模块的扇入系数和扇出系数要合理。

  > 多扇入，少扇出

  （8）模块的规模适当。

- 子系统划分的原则：

  （1）子系统要具有相对独立性。

  （2） 子系统之间数据的依赖性尽量小。

  （3） 子系统划分的结果应使数据余较小。

  （4）子系统的设置应考虑今后管理发展的需要

  （5）子系统的划分应便于系统分阶段实现

  （6） 子系统的划分应考虑到各类资源的充分利用

- 子系统结构设计的**任务是确定划分后的子系统模块结构，并画出模块结构图**在这个过程中必须考虑以下几个问题。

  （1）每个子系统如何划分成多个模块

  （2）如何确定子系统之间、模块之间传送的数据及其调用关系。

   （3）如何评价并改进模块结构的质量

   （4）如何从**数据流图导出模块结构图**

  > **数据流图对应的是功能模型，属于分析阶段；设计阶段就是模块结构图；其次将数据流图转换成模块结构图**

### 系统模块结构设计

- 系统模块结构设计

  模块是组成系统的基本单位，它的**特点是可以组合、分解和更换。系统中的任何一个处理功能都可以看成是一个模块。**根据功能具体化程度的不同，**模块可以分为逻辑模块和物理模块**

  > 可以当成函数理解

- **一个模块应具备以下4个要素。**

  （1）输入和输出。

  （2）处理功能。指模块把输入转换成输出所做的工作

  （3）内部数据。指仅供该模块本身引用的数据

  （4）程序代码。指用来实现模块功能的程序。

  前两个要索是模块外部特性，反映了模块的外貌。后两个要索是模块的内部特性

- **模块结构图**为了保证系统设计工作的顺利进行，结构设计应遵循以下原则

  > 总体设计，概要设计

  （1）所划分的模块其**内部的凝聚性要强（高内聚），模块之间的联系要少（低耦合）**，即模块具有较强的独立性。

  （2）**模块之间的连接只能存在上下级之间的调用关系，不能有同级之间的横向联系**。

  （3）整个系统呈**树状结构**，不允许网状结构或交叉调用关系出现。

  （4）所有模块（包括后继IPO图）都必须严格地分类编码并建立归档文件。

  **模块结构图主要关心的是模块的外部属性**，即上下级模块、同级模块之间的数据传递和调用关系，并不关心模块的内部。

  ![image-20240402170230601](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243865.png)

### 结构化设计方法SD  

> **主要讲DFD数据流图转换成设计阶段的系统结构图**

#### 数据流的类型

​     在需求分析阶段，用SA方法产生了数据流图。面向数据流的设计能方便地将DFD转换成程序结构图。DFD中从系统的输入数据流到系统的输出数据流的一连串连续变换形成了一条信息流。**DFD的信息流大体上可以分为两种类型：变换流和事务流**

1. 变换流。**信息沿着输入通路进入系统，同时将信息的外部形式转换成内部表示**，然后通过变换中心（也称主加工）处理，再沿着输出通路转换成外部形式离开系统。具有这种特性的信息流称为变换流。**变换流型的DFD可以**明显地**分成输入、变换（主加工）和输出三大部分**
2. 事务流。 **信息沿着输入通路到达一个事务中心，事务中心根据输入信息（即事务）的类型在若干个动作序列（称为活动流）中选择一个来执行**，这种信息流称为事务流。事务流有明显的事务中心，**各活动流以事务中心为起点呈辐射状流出**

-  **结构化设计（Structured Design，SD）方法是一种面向数据流**的设计方法，它可以与SA方法衔接。结构化设计方法的**基本思想是将系统设计成由相对独立功能单一的模块组成的结构**

-  结构化设计方法中**用结构图（Structurechart）来描述软件系统的体系结构**指出一个软件系统由哪些模块组成，以及模块之间的调用关系。模块结构图是结构化设计的工具，**由模块、调用、数据、控制和转接五种基本符号组成**。

#### 结构化设计

- **结构化设计主要包括**

  ①**体系结构设计**：定义软件的主要**结构元素及其关系**

  > 就是架构设计

   ②**数据设计**：基于**实体联系图（er）**确定软件涉及的**文件系统的结构及数据库的表结构**

  > 和数据库相关

   ③**接口设计**：描述用户界面，软件和其他硬件设备、其他软件系统及使用人员的**外部接口，以及各种构件之间的内部接口**

  > 和数据流图相关

   ④**过程设计**：确定软件各个组成部分内的**算法及内部数据结构**，，并选定某种过程的表达形式来描述各种算法

  > 对应详细设计

![image-20240403153752780](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243866.png)

### 面向对象设计方法OOD

​    面向对象设计（Object-OrientedDesign，OOD）是OOA方法的延续，是在OOA模型基础上运用面向对象方法，主要解决与实现有关的问题，日标是产生一个符合具体实现条件的OOD模型。由于OOD以OOA模型为基础，且OOA与OOD采用一致的表示法，这使得从OOA到OOD不存在转换，只需做必要的修改和调整

#### 设计软件类

​	**类封装了信息和行为，是面向对象的重要组成部分，它是具有相同属性、方法和关系的对象集合的总称**。在系统中，每个类都具有一定的职责，职责是指类所承担的任务。**设计类是OOD中最重要的组成部分。在系统设计中，类可以分为三种类型：实体类、边界类和控制类**。
​    1）实体类
​    实体类通常对应现实生活中的实体，它包含了用于描述实体的不同实例的信息（称为属性），还封装了维护其信息或属性的行为（称为方法），它们是系统的核心。
​    **实体类**是对用户来说最有意义的类，通常采用业务领域术语命名，**一般来说是一个名词。**

​	2）边界类
​    用户通过边界类实现用户界面与系统通信。描述用户直接同系统交互的用例功能应放在边界类中。**每个参与者或用户都要通过各自的边界类同系统通信**。边界类将系统与其外部环境的变更分隔开，使这些变更不会对系统的其他部分造成影响。
​    3）控制类
​    **控制类实现系统的业务逻辑或业务规则**。一般来说，每个用例由一个或多个控制类来实现控制类通过向实体类发送消息和从实体类接收消息，处理来自边界类的消息并响应这些消息控制类用于对一个或几个用例所特有的控制行为进行建模

#### 面向对象设计过程

![image-20240415200719323](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243867.png)

## 系统测试

### 概念

​	**系统测试的目的是为了发现错误而执行程序的过程，成功的测试是发现了至今尚未发现的错误的测试。测试的目的就是希望能以最少的人力和时间发现潜在的各种错误和缺陷**

> **测试的目的：发现错误，不在乎是否完美无错**

**在进行信息系统测试时应遵循以下基本原则**：
 （1）**应尽早并不断地进行测试。测试不是在应用系统开发完之后才进行的**。
 （2）测试工作应避免由原开发软件的人或小组承担。
 （3）设计测试方案时，不仅要确定输入数据，而且要根据系统功能确定预期输出结果，将实际输出结果与预期结果相比较就能发现测试对象是否正确。
 （4）在设计测试用例时，不仅要设计有效合理的输入条件，也要包含不合理、失效的输入条件。  
（5）在测试程序时，不仅要检验程序是否做了该做的事，还要检验程序是否做了不该做的事。  
（6）严格按照测试计划来进行，避免测试的随意性。
 （7）妥善保存测试计划、测试用例，作为软件文档的组成部分，为维护提供方便
 （8）测试例子都是精心设计出来的，可以为重新测试或追加测试提供方便



> **测试的类型：软件测试可分为单元测试、集成测试、确认测试、系统测试和回归测试等类别**

 （1）**单元测试：单元测试也称为模块测试。单元测试侧重于模块中的内部处理逻辑结构和数据结构。**  
（2）**集成测试：集成测试的目的是检查模块之间，以及模块和已集成的软件之间的接口关系。并验证已集成的软件是否符合设计要求**
 （3）**确认测试**：确认测试主要用于**验证软件的功能、性能和其他特性是否与用户需求一致**

![image-20240407151238184](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243868.png)

> 属于性能要求

 （4）**系统测试：系统测试的对象是完整的、集成的计算机系统，系统测试的目的是在真实系统工作环境下，验证完整的软件配置项能否和系统正确连接**，并满足系统/子系统设计文档和软件开发合同规定的要求。技术依据是用户需求或开发合同
（5）**回归测试：回归测试的目的是测试软件变更之后，变更部分的正确性和对变更需求的符合性以及软件原有的、正确的功能、性能和其他规定的要求的不损害性**。

### 软件测试方法

1、**黑盒测试法：
    黑盒测试也称为功能测试，在完全不考虑软件的内部结构和特性的情况下，测试软件的外部特性。主要用于集成测试、确认测试和系统测试中。常用的黑盒测试技术有：等价类划分边界值分析、错误推测和因果图等**
2、白盒测试法
    **白盒测试也称为结构测试，主要用于软件单元测试中。它的主要思想是将程序看作是一个透明的白盒，测试人员完全清楚程序的结构和处理算法**，按照程序内部逻辑结构设计测试用例
    白盒测试**常用的技术是逻辑覆盖，循环覆盖和基本路径测试**。**主要的逻辑覆盖标准有语句覆盖、判定覆盖、条件覆盖、条件/判定覆盖、条件组合覆盖、路径覆盖等**

> **白盒测试都是什么覆盖什么覆盖的和路径测试，就是一些规范化定义啊；黑盒就是一块一块的，不需要考虑结构这些，除去白盒就是黑盒**

## 系统运行与维护

​	系统的可维护性可定义为：维护人员理解、改正、改动和改进这个软件的难易程度
1、**系统可维护性的评价指标**：
1）**可理解性**：是指别人能理解系统的结构、界面、功能和内部过程的难易程度。
2）**可测试性**：诊断和测试的容易程度取决于易理解的程度
3）**可修改性**：模块的耦合、内聚、作用范围与控制范围的关系等，都对可修改性有影响。
2、**软件维护的一般内容**：
 （1）**正确性维护**：是指改正在系统开发阶段已发生而系统测试阶段尚未发现的错误
 （2）**适应性维护**：是指使应用软件适应信息技术变化和管理需求变化而进行的修改
 （3）**完善性维护**：这是为扩充功能和改善性能而进行的修改，主要是指对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征。这些功能对完善系统功能是非常必要的。  
（4）**预防性维护**：为了改进应用软件的可靠性和可维护性，为了适应未来的软硬件环境的变化，应主动增加预防性的新的功能



# 数据库设计

## 数据库设计概述

### 数据库应用系统的生命周期

数据库应用系统的生命周期分为**数据库规划、需求描述与分析、数据库与应用程序设计、数据库设计实现、测试、运行维护**6个阶段。

> **记住顺序**

- 1、**数据库规划**

  数据库规划的任务是确定软件的开发自标及可行性。该阶段应该给出问题定义、可行性分析和项目开发计划

- 2、**需求描述与分析**

  需求描述与分析是以用户的角度，从系统中的数据和业务规则入手，收集和整理用户的信息，以特定的方式加以描述，是下一步工作的基础

- 3、**数据库与应用程序设计**

  **数据库的设计**是对用户数据的组织和存储设计；**应用程序**设计是在数据库设计基础上对数据操作及业务实现的设计，包括事务设计和用户界面设计。

- 4、**数据库设计实现**

  数据库设计实现是依照设计，使用DBMS支持的数据定义语言实现数据库的建立，用高级语言编写应用程序。

- 5、**测试**

  测试是在数据库系统投入使用之前，通过精心制订的测试计划和测试数据来测试系统的性能是否满足设计要求，以便**发现问题**。

- 6、**运行维护**

  数据库应用系统经过测试、试运行后即可正式投入运行。运行维护是系统投入使用后，必须不断地对其进行评价、调整和修改，直至系统消亡

### 数据库设计的一般策略

​     数据库设计的一般策略有两种：**自顶向下和自底向上**

### 数据库设计的基本步骤

  一般将数据库设计分为如下6个阶段：

（1）**用户需求分析。**

**（2）概念结构设计。**  

**（3）逻辑结构设计。**

**（4）物理结构设计。**

（5）数据库实施阶段。

（6）数据库运行和维护阶段。

> **记住顺序**

## 系统需求分析

### 需求分析的任务、方法和目标

  需求分析阶段的任务：综合各个用户的应用需求，对现实世界要处理的对象（组织、部门和企业等）进行详细调查，在了解现行系统的概况，确定新系统功能的过程中，收集支持系统目标的基础数据及处理方法
 （1）**信息要求**。用户需要在系统中保存哪些信息，由这些保存的信息要得到什么样的信息，这些信息以及信息间应当满足的完整性要求
 （2）**处理要求**。用户在系统中要实现什么样的操作功能，对保存信息的处理过程和方式，各种操作处理的频度、响应时间要求、处理方式等以及处理过程中的安全性要求和完整性要求
 （3）**系统要求**。包括安全性要求、使用方式要求和可扩充性要求。安全性要求：系统有几种用户使用，每一种用户的使用权限如何。使用方式要求：用户的使用环境是什么，平均有多少用户同时使用，最高峰有多少用户同时使用，有无查询相应的时间要求等。可扩充性要求：对未来功能、性能和应用访问的可扩充性的要求

![image-20240408200925309](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243869.png)

### 需求分析阶段的文档

> **重点**

   需求分析阶段的成果是系统需求说明书，主要包括**数据流图、数据字典、各种说明性表格、统计输出表和系统功能结构图等**
    **数据字典（Data Dictionary，DD）是各类数据描述的集合**，**它是关于数据库中数据的描述，即元数据，而不是数据本身**。如用户将向数据库中输入什么信息，从数据库中要得到什么信息，**各类信息的内容和结构，信息之间的联系等**

> **数据字典包括数据项、数据结构、数据流、数据存储和处理过程5个部分
> 注：数据库设计里需求分析阶段的数据字典与系统分析里需求分析阶段的数据字典不一致**

## 概念结构设计

> **建立ER图。先抽象、设计局部视图到合并取消冲突到修改重构消除冗余**

概念结构设计是在需求分析的基础上，依照需求分析中的信息要求，对用户信息加以分类、聚集和概括，建立信息模型
**概念结构设计最著名最常用的方法是实体-联系方法，简称E-R方法**。它将现实世界的信息结构统一用实体、属性以及实体之间的联系来描述
概念结构设计工作步骤包括：选择局部应用、逐一设计分E-R图和E-R图合并。

![image-20240408201408549](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243870.png)

> 局部ER图，各个子模块的ER图

**实施步骤**

 1、**选择局部应用
    选择适当层次的数据流图，让这一层的每一部分对应一个局部应用，实现某一项功能**，从这一层入手，就能很好地设计分E-R图
**2、逐一设计分E-R图**
      划分好各个局部应用之后，就要对每一个局部应用逐一设计分E-R图，又称为局部E-R图
     现实生活中许多事物，作为实体还是属性没有明确的界定，这需要根据具体情况而定，一般遵循以下两条准则：
   （1）**属性不可再分**，即属性不再具有需要描述的性质，不能有属性的属性
   （2）**属性不能与其他实体发生联系**，联系是实体与实体间的联系。
 **3、E-R图合并**
     根据局部应用设计好各局部E-R图之后，就可以对各分E-R图进行合并。合并的目的在于解决冲突，消除冗余。

> **合并ER图的冲突**
>
> 分E-R图合并时，它们之间存在的冲突主要有以下三类：
> （1）**属性冲突**：**同一属性可能会存在于不同的分E-R图中**，由于设计人员不同或是出发点不同，**对属性的类型、取值范围、数据单位等可能会不一致。比如说学生的学号与选课关系的学号，一边是数字，另一半是字符型**
> （2）**命名冲突：相同意义的属性，在不同的分E-R图上有着不同的命名**，**或是名称相同的属性在不同的分E-R图中代表着不同的意义**，这些也需要进行统一 。**比如员工号和教职工号，或是明喆的员工号与学校的员工号**
> （3）**结构冲突：同一实体在不同的分E-R图中有不同的属性，或同一对象在某一分E-R图中被抽象为实体而在另一分E-R图中又被抽象为属性。如员工实体和教职工实体，因为教职工实体本来就是属于员工实体的**
>
> ![image-20240409212414815](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243871.png)

## 逻辑结构设计

> **主要是设计关系模型（er图转关系模型）、关系规范化、模式优化及设计用户子模式（视图）**

**逻辑结构设计就是在概念结构设计的基础上进行数据模型设计，可以是层次模型网状模型和关系模型**
逻辑结构设计阶段的主要工作步骤**包括确定数据模型、将E-R图转换成指定的数据模型、确定完整性约束和确定用户视图**

![image-20240409170904765](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243872.png)

> 用户子模式：视图

### E-R图向关系模式的转换

1、实体向关系模式的转换

   ER图中的**每一个实体单独转换成一个关系模式，实体名对应关系模式的名称，实体的属性转换为关系模式的属性，实体标识符就是关系的码。**
       班主任（工号，姓名，身份证号，住址）
       班级（班级编号，名称，人数）

**2、联系向关系模式的转换**

![image-20240409210632405](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243873.png)

![image-20240409210741658](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243874.png)

![image-20240409210844379](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243875.png)

![image-20240409211014106](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243876.png)

> **以下情况没法无脑直接，需要具体分析，灵活使用**

![image-20240409211349864](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243877.png)

![image-20240409211658178](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243878.png)

### 关系模式的规范化

  由E-R图转换得来的初始关系模式并不能完全符合要求，还会有数据冗余、更新异常存在，这就需要经过进一步的规范化处理。
 （1）根据语义**确定各关系模式的数据依赖**。
 （2）根据数据依赖确定关系模式的范式，**判断关系模式是否达到了3NF或4NF。**
 （3）**如果关系模式不符合要求，要进行分解，达到3NF、BCNF或4NF**
（4）**关系模式的评价及修正。有时根据处理要求，可能还需要增加部分冗余以满足处理要求**，这就需要做部分关系模式的处理，**分解、合并或增加冗余属性，提高存储效率和处理效率。**

> 为了提高处理效率，可以进行反范式

### 确定完整性约束

### 用户视图的确定

 （1）**根据数据流图确定处理过程使用的视图**
 （2）**根据用户类别确定不同用户使用的视图**

## 物理结构设计

数据库在物理设备上的**存储结构与存取方法称为数据库的物理结构，它依赖于给定的计算机系统**。**为一个给定的逻辑数据模型设计一个最适合应用要求的物理结构的过程**，就是数据库的物理设计。

### 物理结构设计工作流程

![image-20240409171535838](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243879.png)

### 物理设计工作步骤

物理设计主要工作步骤包括：**确定数据分布、存储结构和访问方式**

1、**确定数据分布**
  （1）根据不同应用分布数据
  （2）根据处理要求确定数据的分布
  （3）对数据的分布存储必然会导致数据的逻辑结构的变化，要对关系模式做新的调整，回到数据库逻辑设计阶段做必要的修改。
2、**确定数据的存储结构**
     存储结构具体指数据文件中记录之间的物理结构
    为提高数据的访问速度，通常会采用**索引技术**。在物理设计阶段，要根据数据处理和修改要求确定数据库文件的索引字段和索引类型

> **索引技术是数据库物理设计阶段的工作**

 3、确定数据的访问方式
  （1）存储记录结构设计
  （2）存储记录布局
  （3）存取方法的设计

## 数据库运行维护与管理

### 数据库重组和重构

​    **数据库重组是指在不改变数据库逻辑和物理结构的情况下，去除数据库存储文件中的废弃空间以及碎片空间中的指针链**；使数据库记录在物理上紧连
​    数据库系统运行过程中，会因为一些原因而**对数据库的结构做修改，称为数据库重构。重构包括表结构的修改和视图的修改**

### 数据库系统的审计

​    **审计是一种DBMS工具，它记录数据库资源和权限的使用情况。启用审计功能，可以产生审计跟踪信息**，包括哪些数据库对象受到了影响，谁在什么时候执行了这些操作
​    **审计是被动的，它只能跟踪对数据库的修改而不能防止**，但作为一个安全性手段，起到对非法入侵的威作用，可以据此追究非法入侵者的法律责任
​    审计功能的开启会影响系统的性能

> **审计是被动的，不能防止修改，性能会下降**

### 数据库的存储管理

​    在数据库系统运行过程中，随着数据的不断变更，会影响到系统的响应效率。通过以下手段进行存储管理，可有效地提高系统性能
 （1）索引文件和数据文件分开存储，事务日志文件存储在高速设备上。
 （2）适时修改数据文件和索引文件的页面大小。
 （3）定期对数据进行排序。
 （4）增加必要的索引项

### 数据安全性管理

 （1）建立网络安全，主要是防火墙的设置
 （2）操作系统级安全，进行登录用户的管理
 （3）DBMS级安全，对访问数据库的用户进行密码验证。
 （4）角色和用户的授权管理
 （5）建立视图和存储过程加强安全性
 （6）使用审计功能，为追究非法入侵者法律责任提供证据，发现安全漏洞

### SQL语句的编码检验

 （1）**尽可能地减少多表查询或建立物化视图**
 （2）**以不相关子查询替代相关子查询，以in代替exists**。

> in和not in是不相关子查询
>
> exists和not exists是相关子查询

 （3）**只检索需要的列。**
 （4）**用带IN的条件子句等价替换OR子句**
 （5）**经常提交COMMIT，以尽早释放锁。**
 （6）**用UNION ALL而不用UNION**

### 表设计的评价

 （1）如果频繁的访问是对两个相关的表进行连接操作，则考虑将其合并
 （2）如果频繁的访问只是在表中的某一部分字段上进行，则考虑分解表，将该部分单独作为一个表
 （3）**对于更新很少的表，引入物化视图**

### 索引维护和改进

（1）如果查询是瓶颈，则在关系上建立适应的索引，**通常在作为查询条件的属性上建立索引，可以提高查询效率。**
 （2）如果更新是瓶颈，每次更新都会重建表上的索引，引起**效率的降低，则考虑删除某些索引。**
 （3）选择适当的索引类型，**如果是经常使用范围查询，则B树索引比散列索引更高效**
 （4）**将有利于大多数据查询和更新的索引设为聚族索引**

# 事务管理

> 很重要，上午8分，下午有时两题

## 基本概念

### 事务概述

事务：是一系列的数据库操作，是数据库应用程序的逻辑单位，即应用程序对数据库的操作都应该以事务的方式进行。

> **事务是一个操作序列，这些操作“要么都做，要么都不做”**

事务定义的语句如下：
 （1）**BEGIN TRANSACTION：事务开始。**
 （2）**END TRANSACTION：事务结束。**
（3）**COMMIT：事务提交。该操作表示事务成功地结束，它将通知事务管理器该事务的所有更新操作现在可以被提交或永久地保留**
（4）**ROLLBACK：事务回滚**。该操作表示事务非成功地结束，**它将通知事务管理器出故障了，数据库可能处于不一致状态，该事务的所有更新操作必须回滚或撤销**

![image-20240410144540179](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243880.png)

### sql中事务的开始与结束

SQL标准规定当一条SQL语句被执行，就隐式地开始了一个事务，SQL中的Commit work和Rollback work语句之一会结束一个事务
 （1）**Commit work**：提交当前事务。这意味着该事务所做的更新在数据库中永久保存。一但事务被提交后，一个新的事务自动开始。
 （2）**Rollback work**：回滚当前事务。这意味着将撤销该事务对数据库的更新

> **注意：如果事务已经执行了Commit work，就不能再用Rollback来撤销当前的操作了，只能撤销commit后的命令**

### 事务正确执行的特性

> **很重要**

数据库事务正确执行具有4个特性：**原子性、一致性、隔离性和持久性，统称ACID**

1. **原子性（atomicity）：事务的所有操作在数据库中要么都做要么都不做**

2. **一致性（consistency）：一个事务独立执行的结果，将保持数据的一致性，即数据不会因为事务的执行而遭受破坏**

3. **隔离性（isolation）：一个事务的执行不能被其他事务干扰。并发事务在执行过程中可能会对同一数据进行操作，这些事务的操作应该不会互相干扰，是相互隔离的**

4. **持久性（durability）：一个事务一旦提交（commit），它对数据库的改变必须是永久的，即使系统出现故障也是如此**

   > **没有写入硬盘的操作破坏了持久性**

### 事务的状态

事务是数据库的基本执行单元，**如果事务成功执行，则数据库从一个一致状态进入另一个一致状态**。如果因为某种原因事务没能成功执行，但其已经对数据库进行了修改，这时候可能会导致数据库处于不一致的状态，需要对事务已经造成的变更进行撤销（回滚）
1、**活动状态：事务的初始状态**，事务执行时处于这个状态
2、**部分提交状态：当操作序列的最后一条语句执行后，事务就处于部分提交状态。这时，事务虽然已经完全执行，但由于实际输出可能还临时驻留在内存中**，在事务成功完成前还有可能出现硬件故障，因此，部分提交状态并不等于事务成功执行。

> 需要使用commit才能提交更改，否则关闭后做出的修改就不见了

3、**失败状态：由于硬件或逻辑错误，使得事务不能继续正常执行，事务就进入了失败状态，处于失败状态的事务必须回滚。这样，事务就进入了中止状态。**
4、**中止状态：事务回滚并且数据库恢复到事务开始执行前的状态**。
5、**提交状态：当事务成功完成后，称事务处于提交状态**。只有事务处于提交状态后，才能说事务已经提交

![image-20240410150247679](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243881.png)

- **BEGIN TRANSACTION：开始运行事务，使事务进入活动状态**
- **END TRANSACTION**：说明事物中的所有读写操作都已完成，**使事务进入部分提交状态**，把事务的所有操作对数据库的影响存入数据库
- **COMMIT：标志事务已经成功地完成**，事务中的所有操作对数据库的影响已经安全地存入数据库事务**进入提交状态**，结束事务的运行
- **ABORT：标志事务进入失败状态**，系统撤销事务中所有操作对数据库和其他事务的影响，结束事务的运行。

## 数据库的并发控制

指我们有多个事务对同一个数据进行操作

### 事务调度

#### 串行调度

指多个事务依次串行执行，且只有当一个事务的所有操作都执行完成才执行另一个事务的所有操作

![image-20240410152233510](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243882.png)

#### 并发调度

利用分时的方法同时处理多个事务

![image-20240410152346233](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243883.png)

> **如果并发调度与串行调度的任意一种先后顺序的结果相同的话，则成为正确的并发调度，否则是错误的。**

![image-20240410153948704](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243884.png)

#### 可恢复调度

**指满足这样的条件的调度：当事务Tj要读事务Ti写的数据时，Ti事务必须要先于事务Tj提交，不满足则是不可恢复调度**

![image-20240410153253017](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243886.png)

### 并发调度带来的问题

包括带来的数据不一致性的三类：**丢失修改、不可重复读和读脏数据**

> **解决这三类问题的顺序：丢失修改=》读脏数据=》不可重复读**

1. **丢失修改**

   > **操作：update**

   **两个事务对同一个数据进行修改，导致事务A对数据库的修改被事务B的修改所覆盖**

   ![image-20240410154459272](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243887.png)

   > **丢失原本的修改**：本来应该是14的，但是修改被覆盖了，就只有15

2. **不可重复读**

   > **操作：update**

   **事务对同一数据进行两次读取的结果不同。原因是两次读取的间隙数据被另一事务修改了**

   ![image-20240410154650422](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243888.png)

   > **不能重复读到相同的数据**：本来读的是100但是在另一个事务修改了，导致没法读到原本的100了，也就是不能重复读相同数据

3. **读脏数据**

   > **操作：update、delete**

   **某事务读取的数据是其他事务修改后的值，但该修改后的值又被撤销了**

   ![image-20240410154806061](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243889.png)

   > **读到了别人撤销的数据：**一端事务先不撤销，等另一端读了之后撤销，导致这一端的数据在另一端不存在，所以就叫读到了脏数据

4. 幻读

   > **操作：insert，delete不是幻读**

### 并发调度的可串行性 

> **1.多个事务的并发执行是正确的，当且仅当其结果与某一次串行地执行它们的结果相同，称这种调度策略是可串行化的调度  
> 2.可串行性是并发事务正确性的准则。即：一个给定的并发调度，当且仅当它是可串行性的才认为是正确的调度  
> 3.保证并发事务正确执行的方法：满足两段锁协议  
> 总结：满足两段锁协议=》该调度是可串行性的调度=》该并发事务正确执行=保证了事务的隔离性和一致性**

![image-20240413212407881](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243890.png)

### 并发控制技术

> **对数据读之前先加读锁，写前加写锁**

​	**并发事务如果对数据读写时不加以控制，会破坏事务的隔离性和一致性**。为了保持事务的隔离性系统**必须对事务之间的相互作用加以控制，最典型的方式就是加锁**
1、**排它锁（独占锁Exclusive Locks，简称X锁）：也称为写锁，用于对数据进行写操作时进行锁定。如果事务T对数据A加上X锁后，就只允许事务T对数据A进行读取和修改**，其他事务对数据A不能再加任何锁，也不能读取和修改数据A，直到事务T释放A上的锁。

> **xlock(数据)**
>
> unlock()

2、**共享锁（Share Locks，简称S锁）：也称为读锁，用于对数据进行读操作时进行锁定。如果事务T对数据A加上了S锁后，事务T就只能读数据A但不可以修改，其他事务只能再对数据A加S锁来读取，只要数据A上有了S锁，任何事务都只能再对其加S锁读取而不能加X锁修改。**

> **slock（数据）**

![image-20240412151752792](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243891.png)

### 封锁协议

> **这里的封锁协议是针对一个事务而言的，也就是说，该封锁仅对一个事务生效**

- （1）**一级封锁协议：是指事务T在修改数据A之前必须先对其加X锁，直到事务结束才释放X锁。因为加了x锁，所以只有t能读取和修改，因此一级封锁协议解决了丢失修改的问题**

  > xlock(A)
  >
  > 仅事务T对A的各操作..
  >
  > unlock(A)

- （2）**二级封锁协议**：是**一级封锁协议加上事务T在读取数据A之前必须对其加上S锁，读完后即可释放S锁**。**因为加了读锁，仅能读取不能修改，所以二级封锁协议解决了读脏数据的问题**

  > slock(A)
  >
  > read(A)
  >
  > unlock(A)

- （3）**三级封锁协议**：是**一级封锁协议加上事务T在读取数据A之前必须对其加上S锁，直到事务结束才释放S锁。仅能读取不能修改直至事务结束，否则有可能读完解锁后，对其修改，导致第二次读取的结果不一致，产生不可重复读问题，所以三级封锁协议解决了不可重复读的问题**

  > slock(A)
  >
  > read(A)
  >
  > ..直至事务结束
  >
  > unlock(A)

| 封锁协议     | 要求                                             | 可解决                         |
| ------------ | ------------------------------------------------ | ------------------------------ |
| 一级封锁协议 | 修改前加X锁，事务结束后释放                      | **丢失修改**                   |
| 二级封锁协议 | 在一级之上添加：读取前加Ｓ锁，**读完后释放**     | **丢失修改、读脏**             |
| 三级封锁协议 | 在一级之上添加：读取前加Ｓ锁，**事务结束后释放** | **丢失修改、读脏，不可重复读** |

![image-20240430185537321](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243892.png)

### 两段锁协议

> **每年下午一道题，熟读甚至背下来**

- **两段锁协议（2PL）：是指同一事务对任何数据进行读写之前必须对数据加锁；在释放一个封锁之后，该事务不再允许申请和获得任何其他封锁。**

  > **也就是说，每个事务里都可以使用两段锁协议，即事务1的两段锁协议与事务2的两段锁不干扰，是分开的**

- **即事务分为两个阶段。第一个阶段是获得封锁**，也成为扩展阶段，**该阶段不能释放封锁，否则就进入了第二阶段，即释放封锁阶段，也成为收缩阶段，同样，该阶段不能获得封锁**

- 例：
  - **正确**T1：slock a...slock b...xclock c...unlock b...unlock a...unlock c
  - **错误**T2：slock a...unlock a...slock b...xlock c...unlock c
  
- **如果事务遵循两段锁协议，那么它们的并发调度是可串行化的（正确的意思）。如果不遵循，则无法判定正确性**

- **注意：采用两段锁协议也有可能产生死锁**，这是因为每个事务都不能及时解除被封锁的数据，可能会导致多个事务都要求对方已经封锁的数据而不能继续运行

![image-20240414151710639](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243893.png)

> **死锁定义**
>
> **指两个以上的事务分别请求封锁对方已经封锁的数据，导致长期等待而无法继续执行下去的现象。比如事务A对数据A加了写锁，而事务B对数据A用了共享锁，则进入死锁，因为必须等事务A放开才行，否则只能一直等待**
>
> ![image-20240506160638652](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243894.png)

> **回滚事务的代价**
>
> **选择发生离死锁最近的一个事务的操作**
>
> ![image-20240506160638652](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243894.png)
>
> 如图中的T2

### 事务的隔离级别

> **记单词，拼写**

- 1、**read uncommitted（读未提交）**：可避免**丢失修改**。

  > **RU级别**
  >
  > 因为不提交，所以不存在修改，也就没有丢失修改

- 2、**read committed（读已提交）**：可避免**丢失修改、读脏数据**。

  > **RC级别，oracle默认隔离级别**
  >
  > 提交了就不能rollback了，因此就没有脏数据

- 3、**repeatable read（可重复读）**：可避免**丢失修改、读脏数据，不可重复读**

  > **RR级别，mysql默认隔离级别**
  >
  > 可重复读就解决了不可重复读的问题

- 4、**serializable（串行化）：最高级别**，可避免**丢失修改、读脏数据、不可重复读、幻读**。

> 幻读：事务A查询得到N条数据，然后事务B又插入了M条数据，或者改变了这N条数据之外的M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了，就产生了幻读。
>
> - **不可重复读与幻读的区别：**
>
>   **不可重复读是针对具体的某一个值不相同**
>
>   **幻读则是针对两次查询的结果的行数不相同**

![image-20240413212503504](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243895.png)

> 【问题2】（1）：**判定事务并发执行正确性的准则是事务满足可串行性；当事务满足两段锁协议时，事务满足可串行性，此时的并发事务才能正确的执行**
>
> （2）：xlock(A),R(A,x),w(A,x-a),unlock(A)

## 数据的备份与恢复

### 数据库系统故障的种类

> **分为事务故障、系统故障和介质故障**

1. **事务故障：由于程序执行错误而引起事务非预期的、异常终止的故障**，有以下两类：

   （1）**逻辑错误：非法输入、找不到数据、溢出、超出资源限制**等原因引起的事务执行失败

   （2）**系统错误：系统进入一种不良状态（如死锁）**，导致事务无法继续执行

2. **系统故障：指硬件故障、软件（如DBMS、OS或应用程序**）漏洞的影响，**导致丢失了内存中的信息**，影响正在执行的事务，**但未破坏存储在外存上的信息。破坏了事务的原子性**

3. **介质故障：指数据库的存储介质发生故障，如磁盘损坏、瞬间强磁场干扰**。这种故障直接破坏了数据库，会影响到所有正在读取这部分数据的事务



### 数据库备份

数据转储是将数据库自制到另一个磁盘或磁带上保存起来的过程，又称为数据备份

1. **静态转储和动态转储：静态转储是指在转储期间不允许对数据库进行任何存取、修改操作；动态转储是在转储期间运行对数据库进行存取、修改操作**，因此，转储和用户事务可并发执行
2. **海量转储和增量转储：海量指每次转储全部数据；增量指每次只转储上次转储后更新过的数据**
3. **日志文件**：在事务处理的过程中，DBMS**把事务开始、事务结束以及对数据库的插入、删除和修改的每一次操作都写入日志文件**
4. **数据库镜像：为了避免磁盘介质出现故障影响数据库的可用性**，许多DBMS提供数据库镜像功能用于数据库恢复

### 数据库恢复

**要使数据库在发生故障后能够恢复，必须建立冗余数据**，在故障发生后利用这些冗余数据实施数据库恢复，**常用的是数据转储和日志文件**

#### 故障恢复的两个操作

> **已经commit用redo，没有commit用undo**

1. **撤销事务（UNDO）：将未完成的事务撤销，使数据库恢复到事务执行前的正确状态**

  撤销事务的过程：**反向扫描日志文件（由后向前扫描），寻找事务的更新操作；对该事务的更新操作执行逆操作**，用日志文件记录中更新前的值写入数据库，**插入的记录从数据库中删除，删除的记录重新插入数据库中**；继续反向扫描日志文件，查找该事务的其他更新操作并执行逆操作**直至事务开始标志**

2. **重做事务（REDO）：将已提交的事务重新执行**

  重做事务的过程：**从事务的开始标志起，正向扫描日志文件，重新执行日志文件登记的该事务对数据库的所有操作，直至事务结束标志**

#### 故障恢复策略

1. **事务故障的恢复：事务故障是事务在运行至正常终止点（SUMMIT或ROLLBACK）前终止，造成数据库的不一致，并且日志文件只有该事务的开始标志而没有结束标识。对这类故障的恢复通常是通过撤销UNDO产生故障的事务**，使数据库恢复到该事务执行前的正确状态来完成的。

  具体做法：

反向扫描**日志文件（仅用）**，查找该事务的更新操作

对该事务的更新操作执行逆运算

继续反向扫描日志文件，操作该事务的其他更新操作，并做同样的处理，直至事务的开始标志。

> **注：事务故障的恢复是由系统自动完成的，对用户是透明（看不见）的**

2. **系统故障的恢复：系统故障会使数据库的数据不一致**

  **原因：**

  - **一是**未完成的事务对数据库的更新可能已经写入数据库
  - **二是**已提交的事务对数据库的更新还可能在缓冲区没来得及写入数据库

  **修复手段：**

  因此**对于系统故障，利用日志文件（仅用），恢复操作是UNDO+REDO**

  - **一是撤销故障发生时未完成的事务（UNDO）**
  - **二是重做已经提交的事务（REDO）**

  ![image-20240414151944602](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243896.png)

3. **介质故障的恢复：介质故障时数据库遭到破坏，需要重装数据库，一般需要DBA（数据库管理员）的参与**，**装载故障前最近一次的备份和故障前的日志文件副本**，再按照系统故障的恢复过程**执行撤销（UNDO）和重做（REDO）来恢复**

> **介质故障的恢复步骤**
>
> 1. **首先重新安装数据库管理系统**
> 2. **利用备份的xx文件（完整备份）恢复到数据准备后状态==加载数据库最近的完全备份文件xx，把数据恢复到备份时的状态**
> 3. **依次利用增量备份zz文件和系统日志文件yy进行恢复==通过扫描数据库运行时的日志文件，将数据库恢复到系统出错误前的状态，事务A、B做redo，事务C、D做undo**
>
> **怎么看介质故障里是redo还是undo？**
>
> 1. 该日志中**有提交**操作（commit）的事务，执行**REDO**
> 2. 该日志中**没有提交**操作的事务，执行**UNDO**

![image-20240413212721870](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243897.png)

![image-20240413213649913](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243898.png)

> **检查点机制（CHECKPOINT）**
>
> 同时也是**【问题3】的回答**：在日志中设置检查点，**当发生故障需要利用日志文件核复时，反向扫描日志文件，找到检查点，确认检查点时刻正在执行的事务（活动事务）**，即检查点前有事务开始标志但没有事务结束标志。
> **对于检查点后提交的事务，执行REDO（重做）**
> **对于检查点后未提交的事务，执行UNDO（撤销）**
>
> ![image-20240414152012858](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243899.png)

## 数据库的安全性与完整性

> **数据库只有安全性和完整性，而完整性包括正确性和相容性**

### 数据库的安全性

除了完整性约束提供保护以外引入不一致问题之外，数据库中存储的数据还要防止未经授权的访问和恶意的破坏和修改

#### 安全性违例

**恶意访问的形式主要包括：未经授权读取数据（取信息）：未经授权修改数据：未经授权破坏数据。**
    数据库安全性（databasesecurity）指保护数据库不受恶意访问。需要注意的是**绝对杜绝对数据库的恶意用是不可能的，但是可以使那些企图在没有适当授权的情况下访问数据库的代价足够高**，以阻止绝大多数这样的访问企图。为了保护数据库的安全，可以在以下五个层次上采取安全性措施：
    （1）**数据库系统层次**（database system）。数据库系统的某些用户获得的授权可能只允许他访问数据库中有限的部分，而另外一些用户获得的授权**可能允许他提出查询，但不允许他修改数据**。保证这样的授权限制不被违反是数据库系统的责任
    （2）**操作系统层次**（operating system）。不管数据库系统多安全，操作系统安全性方面的弱点总是可能成为对数据库进行未授权访问的一种手段
    （3）**网络层次**（network）。由于几乎所有的数据库系统都允许通过终端或网络进行远程访问，网络软件的软件层安全性和物理安全性一样重要，不管在因特网上还是在私有的网络内。

（4）**物理层次**（physical）。计算机系统所位于的结点（一个或多个）必须在物理上受到保护，以防止入侵者强行闯入或暗中潜入
    （5）**人员层次**（human）。对用户的授权必须格外小心，以减少授权用户接受或其他好处而给入者提供访问机会的可能性
    为了保证数据库安全，用户必须在上述所有层次上进行安全性维护。如果较低层次上（物理层次或人员层次）安全性存在缺陷，高层安全性措施即使很严格也可能被绕过。下面主要在数据库系统层次上讨论安全性，主要包括：权限机制、视图机制和数据加密

#### 授权与视图

![image-20240417134850425](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243900.png)

![image-20240417134844932](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243901.png)

#### 权限的权限授予

- 权限授权图

  ![image-20240414145608058](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243902.png)

  **用户有授权当且仅当存在从授权图的根到该用户的结点的路径**

  **为了防止相互授权破坏权限回收规则，要求授权图中的所有边都必须是某条从数据库管理员开始的路径的一部分**

#### 数据加密

分为**数据传输加密技术、数据存储加密技术、数据完整性的鉴别技术和密钥管理技术**

   1）数据传输加密技术
    数据传输加密技术的目的是对传输中的数据流加密，通常有线路加密与端端加密两种。线路加密侧重在线路上而不考虑信源与信宿，是对保密信息通过各线路采用不同的加密密钥提供安全保护。端一端加密指信息由发送端自动加密，并且由TCPIP进行数据包封装，然后作为不可阅读和不可识别的数据穿过互联网，当这些信息到达目的地，将被自动重组、解密，从而成为可读的数据。
    2）数据存储加密技术
    数据存储加密技术的目的是防止在存储环节上的数据失密，数据存储加密技术可分为密文存储和存取控制两种。前者一般是通过加密算法转换、附加密码、加密模块等方法实现：后者则是对用户资格、权限加以审查和限制，防止非法用户存取数据或合法用户越权存取数据

​    3）数据完整性鉴别技术
​    数据完整性鉴别技术的目的是对介入信息传送、存取和处理的人的身份和相关数据内容进行验证，一般包括口令、密钥、身份、数据等项的鉴别。系统通过对比验证对象输入的特征值是否符合预先设定的参数，实现对数据的安全保护
​    4）密钥管理技术
​    密钥管理技术包括密钥的产生、分配、保存、  更换和销等各个环节上的保密措施

![image-20240414151740009](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243903.png)

### 数据库完整性

**指数据的正确性和相容性**

![image-20240414150220597](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243904.png)

![image-20240414152115615](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243905.png)

# 云计算与大数据处理

## 基础知识

- 权威定义：云计算是一种将可伸缩、弹性、共享的物理和虚拟资源池以按需自服务的方式供应和管理，并提供网络访问的模式。
- 狭义：云计算是一种提供资源的网络，使用者可以随时获取“云”上的资源，按需求量使用，并且可以看成是无限扩展的，只要按使用量付费就可以。
- **是以一种方便的使用方式和服务模式**，通过互联网**按需访问资源池模型**（例**如网络、服务器、存储、应用程序和服务**），以**快速和最少**的管理工作**为用户提供服务**。

### 云计算的关键特征

1. 关键特征

   - **广泛的网络接入**
   - **可测量的服务**
   - **多租户**
   - **按需自服务**
   - **快速的弹性和可扩展性**
   - **资源池化**

   ​        1）广泛的网络接入
   ​      用户可以通过网络，采用标准机制访问云中的物理和虚拟资源的特性。标准机制有助于用户通过异构平台使用资源。用户可以在任何有网络的地方，利用各种不同类型的客户端，如手
   机、电脑、工作站等设备，方便地访问云中的资源
   ​       2）可测量的服务
   ​       通过可计量的服务交付使得服务使用情况可监控、控制和计费的特性。这个特性强调用户只为自己使用的服务付费，降低用户成本，为用户带来价值。
   ​      3）多租户
   ​      通过对物理或虚拟资源的分配保证多个租户以及他们的计算和数据彼此隔离和不可访问的特性。在云中可以实现多种不同形式的租户组织，在不同的云计算部署模型下，可以灵活实现一组云服务用户由来自不同客户的用户组成
   ​      4）按需自服务
   ​      客户能够根据自身的实际需求，自动或在最少交互的情况下，配置计算能力的特性。该特性降低了用户的时间成本和操作成本，实现了企业业务的快速实现、部署与应用，降低了企业信息系统的运维成本，提高了企业快速响应市场的能力。
   ​       5）快速的弹性和可扩展性
   ​       物理或虚拟资源能够快速、弹性，有时是自动化地供应，以达到快速增减资源目的的特性用户在使用云服务时，无需为资源容量担心，对用户而言，可使用的资源（物理或虚拟资源）是无限的，其上限只受服务协议的限制
   ​       6）资源池化
   ​       将云服务提供者的物理或虚拟资源进行集成，以便服务于一个或多个云服务客户的特性该特性通过抽象对用户屏蔽了资源处理和分配的复杂性，**用户无需知道资源是如何分布，如何分配的。**

2. 其他关键特征

   - 虚拟化技术
   - 可靠性高
   - 性价比高

   ​     1）虚拟化技术
   ​     **虚拟化突破了时间、空间的界限，是云计算最为显著的特点**，虚拟化技术**包括应用虚拟和资源虚拟**两种。
   ​     2）可靠性高
   ​     若服务器故障也不影响计算与应用的正常运行。因为**单点服务器出现故障时，可以通过虚拟化技术将分布在不同物理服务器上面的应用进行恢复，或利用动态扩展功能部署新的服务器进行计算。**
   ​    3）性价比高
   ​     将资源放在虚拟资源池中统一管理，在一定程度上优化了物理资源，用户不再需要昂贵、存储空间大的主机，可以选择相对廉价的PC组成云，一方面减少费用，另一方面计算性能不逊于大型主机。

### 云计算分类

1. 按云部署模式和云应用范围分类

   1）**公有云**
    一般是被**一个云计算服务提供商所拥有，该组织将云计算服务销售给公众**，公有云通常在远离客户建筑物的地方托管（一般为云计算服务提供商建立的数据中心）
   2）**社区云**
     云的基础设施**被一些组织所共享**，并为一个有共同关注点的社区服务。可以是该组织或某个第三方负责管理。
   3）**私有云**
    云的基础设施是**为一个客户单独使用而构建**的，因而提供对数据、安全性和服务质量的最有效控制。私有云可部署在企业数据中心中，也可部署在一个主机托管场所，被一个单一的组织拥有或租用。
   4）混合云
   云的基础设施由以上两种或两种以上的云（私有、社区或公有）组成

2. **按云计算的服务层级和服务类型分类（重点，记缩写）**

   1. **基础设施即服务（Infrastructure as a service，IaaS）**

      **提供**虚拟化的**计算资源**，**如虚拟机、存储、网络和操作系统**。其**核心技术是虚拟化**。代表有亚马逊云计算AWS，弹性计算云EC2和简单存储服务S3，IBM蓝云等

   2. **平台即服务（Platform as a service，PaaS）**

      为开发、测试和管理软件应用程序**提供按需开发的环境。其核心技术是分布式并行计算**。PaaS实际上是指**将软件研发的平台作为一种服务**。如GAE只允许使用py和java

   3. **软件即服务（Software as a service，SaaS）**

      通过**互联网提供按需软件付费应用程序**，**云计算提供商托管和管理软件应用程序**，并允许用户连接到应用程序并通过互联网访问应用程序。**客户可以**自己**定制、配置、组装**来得到满足自身需求的**软件系统**。如CRM服务，google apps

### 云关键技术

#### 虚拟化技术

是一种资源管理技术，是将计算机的各种实体资源（CPU、内存、磁盘空间、网络适配器等）予以抽象、转换后呈现出来，并可供分割、组合为一个或多个电脑配置环境。云计算中的虚拟化往往指的是系统虚拟化
    **系统虚拟化是指将一台物理计算机系统虚拟化为一台或多台虚拟计算机系统**。每个虚拟计算机系统（简称虚拟机）都拥有自己的虚拟硬件（如CPU、内存和设备等），来提供一个独立的虚拟机执行环境，被称为虚拟机监控器 iualMachn  Monlor  VMM）。虚拟机基本结图如下所示

![image-20240414172240881](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243906.png)

#### 分布式数据存储

![image-20240414172340477](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243907.png)

![image-20240414172354997](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243908.png)

#### 并行技术

![image-20240414172405804](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243909.png)

![image-20240414172411607](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243910.png)

#### 运营支撑管理

![image-20240414172419060](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243911.png)



### 云计算安全性

云计算面临的主要数据安全问题和风险包括：
（1）数据存储及访问控制：数据丢失或损坏，数据被非法访问和算改，多租户之间的数据干扰、泄露，数据服务被阻塞，过期数据的妥善保管或销毁等等
（2）数据传输保护：数据在分布式应用中传递时被窃取或攻击。
（3）数据隐私及敏感信息保护：数据所有权问题，非法授信，隐私泄露等
（4）数据可用性：异常崩、业务中断等。
 （5）依从性管理：数据服务违反了法律及政策的要求等

## 大数据处理基础知识

### 基本概念

大数据的特征一般采用5V来描述：

1. **多样性（Variety）**：**数据类型繁多**。除了以往的以文本为主的结构化数据，非结构化数据越来越多，如音频，视频，图片，地理位置信息等
2. **速度（Velocity）：处理速度快**。一方面是数据的增长速度快，另一方面是要求数据访问、处理、交付的速度快，**通常要求具有时效性。是大数据区别于传统数据挖掘的最显著特征。**
3. **大量（Volume）：数据体量巨大**。聚合在一起供分析的数据规模非常庞大。
4. **价值（Value）：价值密度低**。大数据的本质是需要从海量数据中获取具有高价值的数据。
5. **真实性（Veracity）**：是指数据是来自于各种、各类信息系统网络以及网络终端的行为或痕迹



### 大数据处理流程

从大数据生命周期的角度看，大数据处理的基本流程包括：**数据采集、数据分析和数据解释**

1. **数据采集（挖掘）**

   > **数据挖掘是采用适当的算法，从数据仓库的海量数据中提取潜在的信息和知识**

   数据采集阶段的主要任务就是获取各个不同数据源的各类数据，按照统一的标准**进行数据的转换、清洗**等工作，以形成后续数据处理的符合标准要求的数据集。
       原始数据往往形式多样，包括：结构化数据，例如业务系统中的交易明细、操作日志等：非结构化数据，例如企业中的各种文档数据，视频、音频等数据：半结构化数据，例如Web页面的HTML文档等。而且其来源和种类也存在很大差距

   ![image-20240414173510394](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243912.png)

   **网络爬虫**（又称为网页 网络机器人），是一种按一定的规则，自动地取万联信息的程序或者脚本。网络爬虫基本的体系结构如图13-6所示

   ![image-20240414173622055](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243913.png)

2. **数据分析**

   ![image-20240414173730950](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243914.png)

3. **数据分析**

   ![image-20240414173852261](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243915.png)

4. **数据解释**

### 大数据应用

1. 智能交通
2. 电子商务
3. 智能制造

# 数据库主流应用技术

> 1-2分

![image-20240414162232036](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243916.png)

## 分布式数据库

**分布式数据库系统是数据库系统和计算机网络相结合的产物**。一方面，由于计算机功能增强，成本下降，几乎每个办公室、实验室，个人用户都可以拥有自己的计算机，从而增加了数据分散处理的需求。另一方面，由于通信技术的迅速发展，出现了各种计算机网络，降低了数据传输费用，而计算机局部网络的广泛应用，则为分布式数据库系统的出现提供了实现的可能性。

### 基本概念

​	**要使数据库系统能够正常运行，必须制订运行策略**，运行策略的制订要从两个方面考虑：正常运行策略和非正常运行策略

1. **优点：**
   1. 有**灵活的体系结构**
   2. **分布式的管理**和控制机构
   3. **经济性能优越**
   4. 系统的**可靠性高、可用性好**
   5. 局部应用的**响应速度快**
   6. 可**扩展性好**，易于集成现有的系统
2. **缺点：**
   1. **系统开销大**，主要花在通信部分
   2. **存储结构复杂**
   3. 数据的**安全性和保密性较难处理**

#### 正常运行策略

​    **分布式数据库系统（Distributed Database System，DDBS）是面向地理上分散，而管理上又需要不同程度集中管理的需求而提出的一种数据管理信息系统**。在明确地给出分布式数据库的定义之前，我们先来看一下一般的分布式数据库系统的组成，如图14-1所示

![image-20240415204142129](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243917.png)

​	可以看出，分布式数据库系统首先是由多个不同节点或场地的数据库系统通过网络连接而成的（如不加特别说明，本章中的**场地和节点表示同一含义**），每个节点都有**各自的数据库管理系统（Local Database Management System，LDBMS**），同时还有**全局数据库管理系统（Global Database Management System，GDBMS**）。图14-1中的局部用户是针对某一个节点而言的，**局部用户只关心他所访问的节点上的数据，而全局用户则可能需要访问多个节点上的数据**。每个节点的**LDBMS完成对局部用户的应用请求，GDBMS则为全局用户提供服务**。我们还可以看出，**全局用户可以从任意一个节点访问分布式数据库系统中的数据**

- **完全分布式数据库系统的条件**
  1. **分布性**：即**数据存储在多个不同的节点**上
  2. **逻辑相关性**：即数据库系统内的数据**在逻辑上具有互相关联的特性**
  3. **场地透明性**：即是**用**分布式数据库中的**数据时不需指明数据所在的位置**
  4. **场地自治**性：即**每一个单独的节点能够执行局部的应用**请求

#### 分布式数据库的特点

分布式数据库是传统集中式数据库系统的发展，因此它具有集中式数据库系统的特点

1. **数据的集中控制性**

   ​	**能够对信息资源提供集中控制，是主张采用数据库最强有力的动机之一**。数据库是随着信息系统的演变而发展起来的，在这些信息系统中，每个应用程序都有自己的专用文件，这样就不利于数据的管理和共享，由于数据本身已被当作企业的重要投资，在这样的需求推动下，传统的数据库系统孕育而生。分布式数据库系统是在传统数据库系统的基础上的新发展，所以，它也具有集中控制的特性
   ​     在传统的数据库系统中，数据库管理员（Database Admimistrator，DBA）的基本任务是保证数据的安全，并负责对数据进行管理以达到用户和应用能够高效地访问数据。而在分布式数据库中可以认为存在全局数据库管理员和局部数据库管理员，这是一种分层控制结构，**一般来说，全局数据库管理员负责管理所有数据库，而局部数据库管理员只负责各自节点的局部数据库**，但是在有些情况下，局部数据库管理员可以有更高的自主性，甚至完成节点间的协调工作，从而不再需要全局数据库管理员。
   
2. **数据独立性**

   数据独立性也是集中式数据库和文件系统相比所具有的一大特征，**独立性是指数据的组成对应用程序来说是透明的。应用程序只需要考虑数据的逻辑结构，而不用考虑数据的物理存放，因而数据在物理组织上的改变不会影响应用程序。**
        在分布式数据库系统中，数据的独立性同样具有重要的意义，分布式数据库的数据独立性除了具有传统意义上数据独立性的含义，还有分布式透明的含义。所谓分布式透明是指虽然应用程序所面对的是分散存放的数据，但就像使用集中式数据库一样，不必考虑数据库的分布特性。

3. **数据冗余可控性**

   将数据组织在数据库中可以方便地实现数据的共享，因此**要尽量减少数据元余，这不仅使存储代价降低，还可提高查询效率**，便于数据一致性维护，这是数据库系统优于文件系统的特点之一。但是，对数据库系统来说，也不可能达到绝对的无元余数据
        对于分布式数据库来说，由于数据存储的分散性，各场地在网络上需要传输数据，与集中式数据库相比，查询中就增加了传输代价。因此，分布式数据库中的数据一般存储在经常使用的场地上，但两个或两个以上的场地应用对同一数据有存取要求也是时常发生的，而且当传输代价高于存储代价时，可以将同一数据存储在两个（甚至更多）场地上，以节省传输的开销。另外，数据有多个副本，也可以提高系统的可用性，即当系统中某个节点发生故障时，因为数据有其他副本在非故障场地上，对其他所有场地来说，数据仍然是可用的，从而保证数据的完各性。由于这种元余度是在系统控制之下的，所以给系统造成的不利的影响是可控制的。
       另外，由于可用副本的存在也相应地提高了场地自治性的性能。

4. **场地自治性**

   在分布式数据库系统中，**多个场地的局部数据库在逻辑上集成为一个整体，这个整体被称为全局数据库，并为分布式数据库系统的所有用户使用，这种应用称为分布式数据库的全局应用，其用户为全局用户**；同时，分布式数据库系统还允许用户只使用本地的局部数据库，这种应用为局部应用，其用户为局部用户，甚至局部用户所使用的数据可以不参与到全局数据库中去。这种局部应用独立于全局应用的特性就是局部数据库的自治性。
        由于自治性，对每个场地来说就有两种数据，一种是参与全局数据库的局部数据，而另-种则是不参与全局数据库的数据。

5. 存取的有效性

   ​	在传统的数据库系统中，采用二次索引、文件链接等复杂的存储结构是提高存取效率的主要方法。但在分布式数据库系统中，仅仅采用复杂的存取结构并不是一个正确的方法。分布式数据库系统中的全局查询被分解成等效的子查询，即全局查询的执行计划分解成多个子查询执行计划加以执行，它是根据系统的全局优化策略产生的，而子查询计划又是在各场地上分布执行的。因而，**分布式数据库系统中查询优化有两个级别：全局优化和局部优化**
   ​    **全局优化主要决定在多个副本中选取合适的场地副本，使得场地间的数据传输量传输次数最少**，从而使系统通信开销少。而**局部优化就和传统的集中式数据库中的优化是一致的了。**

### 体系结构

#### 分布式数据库的模式结构（重点）

把分布式数据库抽象为四层的模式结构，如下图所示

![image-20240417135952911](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243918.png)

> **分布式数据库的模式结构与常规数据库的对应关系**
>
> 1. **全局外层--外模式**
>
>    多个用户试图，最高层
>
> 2. **全局概念层--概念视图**
>
>    包括：
>
>    1. 全局概念模式
>    2. 分片模式
>    3. 分配模式
>
>    **全局模式发哦分片模式的映射是一对多的**
>
>    **分片模式到分配模式可以一对一也可以一对多**
>
> 3. **局部概念层--概念模式和外模式**
>
>    **组成分布式数据库时**，需要一个统一的全局描述，即数据模型的**同种化的集成，而对于不同的规格化的统一，则称之为一体化**
>
> 4. **局部内层--内模式**
>
>    相当于集中式数据库的内层。其描述的内容和方法与之大致相同

​	这**四种模式划分为：全局外层、全局概念层、局部概念层和局部内层**。在各层间还有相应的层间映射。**四层模式的划分不仅适用于完全透明的分布式数据库系统，而且也适合各种透明性要求的分布式数据库系统**。无论是对同构型分布式数据库系统，还是异构型分布式数据库系统都能适用。

1. **全局外层**
       **分布式数据库是一组分布的局部物理数据库的逻辑集合**。分布式数据库的全局视图如同集中式数据库一样，**由多个用户视图组成**。用户视图是针对分布式数据库特定的全局用户的，**是对分布式数据库的最高层的抽象**
        分布式数据库与集中式数据库的视图有同样的概念，不同的是，它不是从某一个具体场地上的局部数据库中抽取，而是从一个虚拟的由各局部数据库逻辑集合中抽取，对全局用户而言，不论他在分布式数据库系统中的哪一个节点上访问系统中的数据，都可以认为所有的数据库都在本场地，而且他只关心自己所使用的那部分数据

   ​	 如果是完全透明的关系模型的分布式数据库结构，则视图就和集中式数据库的视图一样，其定义方式也基本相同，因此全局用户在使用视图时，就不必关心数据的分片和具体的物理细节。若为非完全透明的分布式数据库，则在视图定义中，根据透明性支持的程度，需要给出-定的数据细节、物理存取的细节等

2. **全局概念层**
       全局概念层是分布式数据库的整体抽象，**包含了系统中全部数据的特性和逻辑结构**。就像集中式数据库中的**概念视图**一样，是对数据库的整体的描述，但在分布式数据库的四层抽象的结构中，全局概念层比集中式的概念层有更多的描述
        从分布透明特性来说，分布式数据库的**全局概念层应具有三种模式描述信息**
       （1）**全局概念模式**：描述分布式数据库全局数据的逻辑结构，是分布式数据库的全局概念视图。与集中式数据库的概念视图的定义相似，全局概念模式应包含模式名、属性名以及每种属性的数据类型的定义和长度。
       （2）**分片模式**：描述全局数据逻辑划分的视图，它是全局数据的逻辑结构根据某种条件的划分，**每一个逻辑划分即一个片段，或称为分片。**
       （3）**分配模式**：描述局部逻辑的局部物理结构，**是划分后的片段（或分片）的物理分配视图**。它与集中式数据库物理存储结构的概念不同，**是全局概念层的内容。**
       分布式数据库的定义语言除了需要提供概念模式的定义语句外，还必须提供分片模式和分配模式的定义语句。
       从**全局模式到分片模式，再到分配模式，它们之间存在着映射。全局概念模式到分片模式的映射是一对多的**，即一个全局概念模式有若干个分片模式与之相对应，而一个分片模式只能对应一个全局概念模式。**分片模式到分配模式映射可以是一对多的或者一对一的**，这是由数据分布的元余策略所决定的。当采用一对多时，表明分片数据有多个副本存储在不同的场地上，且同一场地一般情况下不允许有相同的副本存在：当采用一对一时，则表明数据是非元余的，即分片数据只有一个副本。

   ​	从全局概念层观察分布式数据库，它定义了全局数据的逻辑结构、逻辑分布性和物理分布性，但并不涉及全局数据在每个局部场地上的物理存储细节。所以**全局概念层，仍然是概念层视图，或全局数据库管理员视图**，因而，全局数据库管理员将负责全局数据结构的定义、逻辑分布的定义和物理分布的定义。

3. **局部概念层**
       局部概念层由局部概念模式描述，一般情况下，**它是全局概念模式的子集，全局概念模式经逻辑划分后被分配在各局部场地上。**
       在分布式数据库局部场地上，每个全局关系有该全局关系的若干个（可允许是全部）逻辑片段的物理片段集合，该集合是一个全局关系在某个局部场地上的物理映像，全部的物理映像组成局部概念模式。如果两个场地上的所有物理映像都相同，则其中一个场地上的数据必然是另一个场地的副本，两个场地的局部概念模式亦相同。
       如果分布式数据库只支持全局应用，则**局部概念模式可理解为局部数据库的概念模式和外模式**，在此情况下，外模式和概念模式是相同的：如果分布式数据库还支持局部用户，而局部用户定义的局部数据不参与分布式数据库的全局数据，则局部概念层还应划分为局部外模式和局部模式，并且由局部DBA描述，这些将不属于全局概念模式。这时值得注意的是，**全局数据和局部数据分别由全局DBA和局部DBA管理**。因此，全局用户是否可以使用全局数据则由全局DBA授权，局部DBA无权授予全局用户各种权限
         当全局数据模型与局部数据模型不同时，则物理映像与各局部数据库的数据模型之间还业须有数据模型的转换。即使是数据模型相同时，也可能有数据类型和格式的各种转换。也就是说，**各局部数据库是多种数据模型构成的数据库时，在组成分布式数据库时，需要一个统一的全局描述**，**即数据模型的同种化的集成，而对于不同的规格化的统一，则称之为一体化**。这就是**分布式数据库中的全局概念层到局部概念层的映射模式的描述。**

4. **局部内层**
       局部内层是分布式数据库中关于物理数据库的描述。**相当于集中式数据库的内层。其描述的内容和方法与之大致相同。**
       总之，分布式数据库四层结构及其模式定义之间的相互映射关系，体现了分布式数据库是一组网络连结的局部数据库的逻辑集合

**这四层结构也体现了分布式数据库的特点（重点）：**

1. **全局数据库与局部数据库分离**
2. **数据库的数据独立性**
3. **透明性**
4. **数据冗余控制**

#### 数据分布

​	**数据分布是分布式数据库系统中的基本问题**，解决好这个问题**对提高分布式数据库系统的效率和性能有积极的作用**。所谓**数据分布是指在分布式环境中通过合理分布数据.提高数据操作自然并行度，以达到最好的执行效率的日的**。在构建分布式数据库系统的运行环境时，必须考虑数据如何分布在系统的各个场地上，或者说，必须考虑构成分布式数据库系统的各个组成部分各自如何使用数据的问题。所以，在分布式数据库系统中，同样存在着分布式数据库的设计问题。数据分布就是讨论这个问题，它包括分布式数据库的逻辑划分和物理分配，以及用户对分布式数据库的划分或分配的感知程度（透明度）。
​    **数据分布要研究的问题是在分布式数据库中，如何放置数据，从而使得相关数据之间的相对位置最佳**

> **称之为位置透明**

**解决数据分布的策略：**

1. **集中式：把所有全局数据片段都安排在一个节点上**

   这种分布策略把系统数据都存放在一个节点上，**对数据的控制和管理都比较容易**，数据的致性和完整性能够得到保证。但是由于数据的检索和修改都必须通过这个节点，使得这个节点的负担过重，容易出现瓶颈。另外，**系统对这个节点的依赖性也过多，一旦这个节点出现故障，将使整个系统崩，系统的可靠性就相对较差**，为了提高系统的可靠性，该节点的设备就必须提高。

2. **分割式：所有全局数据有且仅有一份，它们被分割成若干个逻辑片段，每个逻辑片段被分别指派在特定的节点上**，可以说对全局数据进行了划分

   这种分布策略充分利用各个站点上的存储设备，数据的存储量大。在存放数据的各个节点可自治地检索和修改数据，发挥系统的并发操作能力。同时，由于数据是分布在多个节点上的所以当某部分节点**出现故障时，系统仍可运行，提高了系统的可靠性。对于全局查询和修改，所需的时间会比集中式长些**，因为数据不在同一场地上，需要进行网络通信。

3. **复制式：全局数据有多个副本，每个站点都有一个完整的数据副本**

   采用这种策略的系统**可靠性较高，响应速度快。数据库的恢复也较容易，可从任意的场地得到数据的副本**。但是要保持各个站点上数据的同步修改，**将要付出昂贵的代价**。另外，整个系统的**数据元余很大**，系统的数据容量也只是一个节点上数据库的容量

4. **混合式：全部数据被分为若干个数据子集，每个子集被放在不同的节点上，但任何一个节点都没有保存全部的数据，根据数据的重要性决定各个数据子集副本的数量**

   这种分布策略，**兼顾了分割式和复制式的做法，也获得了二者的优点，它灵活性好，能提高系统的效率**，但同时也包括了二者的复杂性。

#### 数据分片

​	**数据分片也称数据分割，是分布式数据库的特征之一**。在一个分布式数据库中，**全局数据库是由各个局部数据库逻辑组合而成。相反，各个局部数据库则是全局数据库的某种逻辑分割而得**。

​	在分布式数据库中，**数据存放的单位是数据的逻辑片段**。对关系型数据库来说，一个数据的逻辑片段是关系的一部分。数据分片有三种基本方法，它们是通过关系代数的基本运算来实
现的：
​    （1）**水平分片：按特定条件把全局关系的所有元组，分划成若千个互不相交的子集，每一子集为全局关系的一个逻辑片段**。它们通过对全局关系施加选择运算得到，并可通过对这些片段执行合并操作来恢复该全局关系。
​    （2）**垂直分片：把全局关系的属性分成若干子集，对全局关系作投影运算得到这些子集要求全局关系的每一属性至少映射到一个垂直片段中，且每一个垂直片段都包含该全局关系的关键字**。这样，通过对这些片段执行连接操作可以恢复该全局关系。

> **为保证全局数据的可重构和最小冗余，分片满足的必要条件是<u>对于任意分片，总存在另一个分片能够和它进行无损链接</u>**

​    （3）**水平和垂直结合的分片：以上两种方法的混合**。可以先水平分片再垂直分片，或先垂直分片再水平分片。
​    不论采用哪一种方法进行数据分片，**都要遵守如下规则：**
​     （1）**完备性条件**：**必须把全局关系的所有数据映射到各个片段中**，绝不允许有属于全局关系却不属于任何一个片段的数据存在
​    （2）**可重构条件**：必须保证能够由同一个全局关系的各个片段来重新构造该全局关系。对于水平分片可用并操作重构全局关系：对于垂直分片可用连接操作重构全局关系。
​    （3）**不相交条件**：要求一个全局关系被**分割后所得的各数据片段互不重叠或只包含关键字重叠**。

#### 分布透明性

​	在分布式数据库中，数据独立性是十分重要的，其内容比集中式数据库更加复杂。除了数据的逻辑独立性与数据的物理独立性外，还有数据的分布独立性。**所谓数据分布独立性是指用户或用户程序使用分布式数据库如同使用集中式数据库那样，不必关心全局数据的分布情况，即用户不必关心全局数据的逻辑分片情况、逻辑片段的场地位置分配情况以及各场地上数据库的数据模型等**。也就是说，**全局数据的逻辑分片、片段的物理位置分配、各场地数据库的数据模型**等情况**对用户和应用程序是透明的**。所以，在分布式数据库中分布独立性也称为分布透明性。下面我们来看看分布透明性的各种级别：

1. **分片透明性
       分片透明性是分布透明性中的最高层**，在四层分布式数据库模式结构中，**分片透明性位于全局概念模式与分片模式之间**。当分布式数据库**具有分片透明性时，用户编写的应用程序只对全局关系进行操作，而不必考虑数据的逻辑分片**，当分片模式改变时，只要改变全局概念模式分片模式之间的映像，从而不会影响应用程序，实现了数据分片透明性

2. **分配透明性
        分配透明性也称位置透明性，是分布透明性的中间层**，在四层的分布式数据库模式结构中**位于分片模式与分配模式之间**。实际上，分配透明性包含了**两种情形：一种**是各片段被复制的情况，即每一片段是否被复制、复制了几个副本：**另一种**是片段及其各副本的场地的位置分配情况。**前者也称复制透明性或数据余透明性**。当分布式数据库具有分配透明性时，**用户编写的应用程序要了解全局数据的数据分片情况，但不必了解各逻辑片段的复制副本情况，也不必关心各片段及其副本的站点位置分配情况**。当片段及其副本的存储站点改变时，只要改变从分片模式到分配模式之间的映像，从而不会影响用户程序，实现了数据片段的位置透明性。

3. **局部数据模型透明性**

   局部数据模型透明性**也称局部映像透明性，即与各场地上数据库的数据模型无关，是分布透明性的最低层**，在四层分布式数据库模式结构图中，**处于分配模式与局部概念模式之间**。当分布式数据库只具有局部数据模型透明性时，用户编写应用程序不但要了解全局数据的逻辑分情况，还要了解各逻辑片段的副本复制情况，以及各片段和它们副本的站点位置分配情况，但不必了解各站点上数据库的数据模型。全局数据模型与每个节点上的局部数据库的数据模型的转换是由分配模式与局部概念模式之间的映像实现的。**当某个节点上数据库的数据模型改变时，只要改变分配模式到该站点局部概念模式之间的映像即可，应用程序不受影响**，从而实现了局部数据模型透明性。显然，在同构分布式数据库系统中，其各站点上的数据模型相同，且有可能全局数据库的数据模型就采用局部数据库的数据模型，此时，就大大减少这种映像的复杂性。

4. 三者的关系

   1. ​	**如果一个分布式数据库系统提供分片透明性，它一定也提供了分配透明性和局部数据模型透明性，所以也称为完全分布透明性，是分布透明性的最高级别**。此时，对用户和用户程序而言，他们所面对的分布式数据库系统，如同集中式数据库一样，不必考虑数据的分片细节，不必考虑各片段的副本情况，不必考虑片段及副本的分配细节，也无需考虑各站点上数据库是什么数据模型等
   2. **如果一个分布式数据库系统提供分配透明性，而没有提供分片透明性，它一定也提供局部数据模型透明性，所以也称为中级分布透明性**。此时，对用户和应用程序而言，他们必须知道分布式数据库全局数据的逻辑分片情况，在程序中必须指出所需要访问的逻辑片段名。但不必关心逻辑片段是否被复制以及它们被分配在哪些站点上，也不必考虑站点的数据模型。
   3. ​    **如果一个分布式数据库系统只提供局部数据模型透明性而不提供分片透明性，也不提供分配透明性，则被称为低级分布透明性**。此时，对用户和应用程序而言，他们不但必须知道分布式数据库全局数据的逻辑分片情况，还必须知道各片段是否有副本、有多少副本、各片段及其副本被分配在哪些站点上。即在程序中要指定要访问的数据逻辑片段名，因此，要指定它们所在的节点名。但不必考虑站点上的数据模型
   4. ​    **如果一个分布式数据库系统，连局部数据模型透明性也不提供，即将异构数据模型转换也交给用户和用户程序自己处理，这种分布式数据库系统称为无分布透明性。**

   由此可见，**一个分布式数据库系统可能提供的分布透明性的层次越高，用户编写应用程序越容易**

#### 分布式数据库管理系统

> **distributed：分布式**

分布式数据库管理系统（Distributed Database Management System，**DDBMS**）**用以支持分布式数据库的建立和维护**。分为两大类：综合型和联合型

1. **综合型体系结构**：是指在分布式**数据库建立之前，还没有建立**独立的集中式数据库**管理系统，设计人员根据用户的需求，设计出一个全新的完整的数据库管理系统。**
2. **联合型体系结构：是指每个节点的数据库管理系统已经存在，在此基础上建立的分布式数据库系统**。同时，联合型体系结构**又分为同构系统和异构系统**。所谓**同构系统是指每个节点的局部数据库管理系统支持同一种数据模式、命令语言及查询语言：而异构系统是指各个节点上的数据库管理系统有不同的数据模式、命令语言及查询语言。**

- 分布式数据库系统**应遵循的12条尊则：**

  1. **本地自治性**
  2. **不依赖于中心站点**
  3. **可连续操作性**
  4. **位置和分片的透明性和独立性**
  5. **数据分片独立性**
  6. **数据复制独立性**
  7. **分布式查询处理**
  8. **分布式事务管理**
  9. **硬件独立性**
  10. **操作系统独立性**
  11. **网络独立性**
  12. **DBMS独立性**

  如果能够满足上面的12条准则，我们就可称这个分布式管理系统为**完全的分布式管理系统**

- 分布式数据库**管理系统的四个组成部分：**

  1. **LDBMS（Local），局部场地上的数据库管理系统，其功能是建立和管理局部数据库，提供场地自治能力，执行局部应用及全局查询的子查询**
  2. **GDBMS，全局数据库管理系统，主要功能是提供分布透明性，协调全局事务的执行**，协调各局部数据库管理系统以完成全局应用，**保证数据库的全局一致性，执行并发控制，实现更新同步**，提供全局回复功能
  3. **全局数据字典（Global Data Directory，GDD），用来存放全局概念模式、分片模式、分配模式的定义以及各模式之间映像的定义**，存放用户存取权限的定义，以**保证全部用户**的**合法权限和数据库的安全性**，还**存放数据完整性约束条件的定义**，其功能**与**集中式数据库的**数据字典类似**
  4. **通信管理（Communication Management，CG）**，通信管理系统在分布数据库各场地之间传送消息和数据，完成通信功能

### 分布式查询处理和优化

  在集中式关系型数据库中，**数据的存取过程和数据的存储结构对用户和应用都是透明的，用户依据数据模型表达查询要求**。借助于SQL些语言来存取数据。这些数据存取及优化过程由数据库管理系统中的数据操作处理模块去完成，它们决定了系统的效率。**分布式数据库中查询处理问题的基础是集中式关系型数据库系统中的概念及策略**。分布式查询处理从讨论分布式查询的特点入手，并假设分布式数据库管理系统提供完全透明性
    分布式数据库环境中的查询与集中式数据库环境中的查询相比较，要增加对以下两个方面的考虑：
（1）数据和信息均要通过通信线路进行传输，**存在延迟的问题**将减慢整个查询的执行过程。

（2）网络中多处理器的存在提供了并行数据处理和传输的机会，应充分利用以加快查询的速度。
    在分布式数据库系统中，**查询优化器的主要任务是控制和加快查询执行与数据传输过程**。在分布式查询处理技术中，查询优化的基本类型通常包括两类：针对查询执行代价的优化和针对查询响应时间的优化。**执行代价是指查询所需要的系统资源：查询响应时间是指查询开始提交到获得第一个结果之间的时间**。一般情况下，查询响应时间对一个组织机构而言，往往就代表着执行代价。例如对于一个商业组织机构，因为响应时间的延误而失掉了销售额或其他机会，就意味着商业损失，但是，出于教学和编程方面的某些原因，我们需要将查询执行代价和响应时间加以区分。
    针对查询执行代价进行优化的目标是，使查询执行所使用的系统资源的总和尽量地少，从而降低系统开销，整个系统的开销可以从各单个系统资源的开销表达式中推出。针对查询响应时间优化的目标是尽量减少查询的响应时间，而不计较系统资源的耗费。**可以形象地说，执行代价优化的日标是“最便宜，而响应时间优化的日标是“最快”**

### 分布事务管理

![image-20240422201038028](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243919.png)

![image-20240422201119917](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243920.png)

![image-20240422201226796](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243921.png)

> 分布式数据库除了三大故障，**还有通信故障**
>
> 通信故障包括
>
> 1. **报文故障**
>    1. **报文错**
>    2. **报文失序**
>    3. **报文丢失**
>    4. **长时间延迟**
> 2. **网络分割故障**

![image-20240422201521590](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243922.png)

![image-20240422201547096](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243923.png)

![image-20240422201632476](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243924.png)

## web与数据库（不考，仅了解）

> 也叫网络数据库
>
> **主要有Sql Server、Oracle和mysql**

### 概述

  数据库是指按照一定的结构和规则组织起来的相关数据的集合，是存放数据的“仓库”，据此将网络数据库定义为以后台数据库为基础的，加上一定的前台程序，通过浏览器完成数据存储、查询等操作的系统。**数据库技术是计算机处理与存储数据的最有效、最成功的技术**，而**计算机网络的特点是资源共享**，因此数据与资源共享这两种技术的结合即成为今天广泛应用的Web数据库（也叫网络数据库）。
      一个Web数据库就是用户利用浏览器作为输入接口，输入所需要的数据，浏览器将这些数据传送给网站，由网站对这些数据进行处理。例如，将数据存入后台数据库，或者对后台数据库进行查询操作等。最后网站将操作结果传回给浏览器，通过浏览器将结果告知用户。**网站上的后台数据库就是Web数据库**

- 连接数据库的常用方法：

    **（1）ODBC**（Open Database Connectivity，开发式数据库连接）是微软开发的一套统一的程序接口。通过这个接口可以存取不同厂商生产的数据库。经过多年的改进，它已成为存取服务数据库的标准。事实上，ODBC技术成了后来DAO、RDO及ADO等数据库访问技术的基础。
      **（2）DAO**（Data Access Obiects，服务器访问对象）是微软公司开发的一套主要应用程序及开发工具，用它可以访问数据库的标准对象，如Access、VB、Excel、Word等。
      **（3）RDO**（Remote Data Obiects，远程数据库访问对象）是微软公司为增强DAO的功能而推出的新产品。该产品强化了SQLServer的访问功能，提高了它的执行效率。
      **（4）ADO**（Activtex Data Objects，Activte数据对象）是微软在Iternet领域采取的新举措。它本身并不是一项新技术，从对象结构的角度来看，它比DAO提供的对象更少：从存取SQL服务器的角度来看，它提供的功能也不如RDO。但它派取了DAO和RDO最精华的部分，成为一个更适合于Internet的小而精的对象群。因此，ADO实际上是脚本程序连接数据库的种选择。

### CGI

   **公共网关接口（CommonGatewayInterface，CGI**）是最早出现的动态发布网页技术，由于其开发较早，技术成熟，因此日前仍是动态网页开发的主力之一。Common表示确保CGI可以使用多种程序语言和多种不同的系统交互，Gateway表示CGI的力量不在于它本身所做的事，而在于它提供了连接其他系统的潜力，例如数据库和图形生成工具等，Iterface表示CGI对如何更好地利用其特性提供了明确的定义，换句话说，可以设计程序来适当利用这个接口。C**GI是Web服务器调用外部程序的接口。通过CGI，Web服务器能完成一些本身所不能完成的工作**。早期很多著名的服务器都以白己独特的方式，支持服务器端的可执行程序，用来帮助完成客户机的请求。为某个服务器写的程序要在其他服务器一同使用时，就必须做较大的修改，原因是每个服务器与可执行程序之间传递信息的内容和方式都不尽相同。为此就形成了一个公共标准CGI，使得为一个服务器写的程序能够在任何服务器上运行。通过这个公共网关接口，服务器可以向CGI程序发送信息，**CGI程序也可以向服务器发送信息。可以使用CShell、Perl、C、C++、Fortran和数据库语言等任何能够形成可执行程序的语言编写。**
    如果现在要让Web服务器与其他系统结合，比如后台数据库系统，则CGI程序会起到程序接口的作用，将接收到的参数进行预处理，转换成所要结合的数据库系统能够识别的形式，对于数据库系统而言，常常就是指数据库系统能够识别运行的标准的SQL语句。当其他系统完成数据处理后如果有结果返回，则CGI程序获得并处理其他系统所传回的数据，然后将其按一定的标准格式再送回至Web服务器，由Web服务器以网页的形式传回到客户端。为了灵活使用各种数据库系统，CGI程序支持ODBC方式。**CGI程序不直接访问数据库系统，而是通过ODBC数据库接口管理器实现**。应用程序以标准SQL语句访问ODBC，通过ODBC由不同的数据库所提供的ODBC驱动程序将SQL语句转换成本数据库所能执行的语言，然后访问数据库。当数据库将结果返回ODBC时，ODBC同样将返回结果进行预处理，以标准形式返回给CGI程序。这样使用ODBC方式访问数据库的优点是程序员在开发系统时不必考虑后台数据库的类型，只要以标准SQL语句编写数据库查询语句访问ODBC数据库接口，由ODBC来负责对各种数据库的支持。不论是使用大型数据库，还是小型数据库，开发人员都不必更改CGI程序。这样就给系统的开发、维护和升级都带来很大的方便和灵活性。

### ASP应用

-   **ASP（ActiveServerPage）提供了一个在服务器端执行脚本指令的环境（包括HTML、VBScript和JavaScript等），通过这种环境，用户可以创建和运行动态的Web应用程序。由于所有的程序都在服务器端执行，这样就大大减轻了客户端浏览器的负担，提高了交互速度。利用ASP不仅能够产生动态的、交互的、高性能的Web应用程序，而且可以进行复杂的数据库操作。ASP本身包含了VBScript和JavaScript的引擎，使得脚本可以直接嵌入HTML中**，而且还可以通过Activex控件实现更为强大的功能。
      确切地说，**ASP并不是一种语言，它所使用的语言通常是VBScript或者JavaScript**，通过这两种脚本语言，我们能够很方便地开发ASP应用。但决不能将ASP与VBScript或者JavaScript等同起来，VBScript和JavaScript之间最大的区别就是它们的结构。VBScript是VisualBasic的子集，如果你曾经用过VisualBasic或者是VisualBasicforApplications（VBA），就会觉得非常熟悉。不过它们并不是完全一样的，因为VBScript是特意为在浏览器中进行工作而设计的，它不包括一些在脚本这个范围以外的特性，如文件访问和打印等等。JavaScript是从一组编程语言如C、C++以及Java等之中脱离出来的。如果你以前曾经用过C或者是Java，那么JavaScript的结构你会觉得非常熟悉。但是，JavaScript和Java是完全不同的两种语言。**Java是一种对于网页应用程序和非网页应用程序都可以使用的完全成熟的开发语言。而JavaScript是一种主要用于脚本编写的脚本语言。**
      ASP能够提供六个内建对象，能够很方便地实现状态保存功能，可以很容易地从客户浏览
  器获取信息，并向浏览器反馈信息，这样，我们就能够很方便地运用ASP开发Web应用ASP有以下几个特点
- （1）ASP无须编译。ASP脚本集成于HTML中，无需编译或链接即可直接解释执行。
- （2）ASP易于生成。使用常规文本编辑器即可进行页面的设计。
- （3）ASP独立于浏览器。用户端只要使用可解释常规HTM码的浏览器，即可浏览ASP所设计的主页。
- （4）ASP脚本是在站点服务器端执行的，因此，若不通过从服务器下载来观察ASP主页，在浏览器端将看不到正确的页面内容
- （5）在ASP脚本中可以方便地引用系统组件和ASP的内置组件，还能通过定制Activex服务器组件来扩充功能。与任何ActivexScripting语言兼容。
- （6）源程序码不会外漏。ASP脚本在服务器上执行，传到用户浏览器的只是ASP执行结果所生成的常规HTML码，这样可保证程序代码不会被他人盗取
       **ASP所完成的功能主要有：**
  （1）处理由浏览器传送到站点服务器的表单输入。
  （2）访问和编辑服务器端的数据库表。使用浏览器即可输入、更新和删除站点的数据库中的数据。

 （3）读写站点服务器的文件，实现访客计数器等功能
    （4）取得浏览器信息管理等内置功能。
    （5）由Cookies读写用户端的硬盘文件，以记录用户的数据。
    （6）可以实现在多个主页间共享信息，以开发复杂的商务站点应用程序。
    （7）使用VBScript或JavaScript等简易的脚本语言，结合HTML，快速完成站点的应用程序。通过站点解释器执行脚本语言，产生或更改在客户端执行的脚本语言。
    （8）扩充功能的能力强，可通过使用多种程序语言制作的ActivexServerComponent满足自己的特殊需要。
    ASP通过ADO的对象模块来存取数据库，无论采用什么数据库，只要该数据库具有对应的ODBC或OLEDB驱动程序，ADO对象就能加以存取。事实上，ASP提供的ADO对象模块包含了下列6个对象和3个集合，其中Connection、Recordset、Command和Field对象比较
常用。

### servlet和jsp的应用

  **Servlet是一种Web组件程序，它可以动态地生成Web内容，支持Web应用的HTTP协议使用请求一响应机制**。服务器接收、处理请求并返回适当的响应。**Servlet用面向对象的方式对这一过程建模，使你能编写代码处理客户的请求并能动态地响应**。例如，Servlet可能从一个表单读取数据并用它更新公司的订单数据库。Servlet技术在通过动态HTML页面扩展WebServer上呈现出一种强有力的方法。一个**Servlet就是一个运行在Web服务器中的Java程序，Servlet从浏览器中获取一个HTTP请求，生成动态内容（例如查询一个数据库），并把HTTP的响应返回给浏览器。**
    在Servlet之前，CGI技术被用在动态内容中。然而，由于它的结构以及可升级性的限制CGI最后被证明为是不太理想的解决方案
    Servlet技术，在可升级性上有了很大的改善，它提供了公认的Java平台扩展、安全性以及强壮性等方面的优点。
    Servlet能使用所有的标准JavaAPIS，在Java领域中，Servlet技术为密集型应用程序（比如访问一个数据库）提供了很多的优点。优点之一就是Servlet运行在服务器端，服务器端具有多种资源且属于一个相对强壮的机器，因此占用客户端的资源相当少。另外一个优点就是Servlet在访问数据时更加直接，因为运行Servlet的Web服务器或者数据服务器在数据被访问时是与网络防火墙在一端。
    JSP技术由Sum公司提出，利用它可以很方便地在页面中生成动态的内容，使网络应用程序可以输出多姿多彩的动态页面。JSP技术通常与JavaServlet技术相结合，可以在HTM页面或者其他标记语言中内嵌Java代码段并且调用外部Java组件。它作为一个前端处理工具，可以使用JavaBeans实现复杂的商业逻辑和动态功能
    JSP代码与JavaScript等网页脚本语言是不同的，在标准的HTML页面中可以出现的任何内容都可以在JSP页面中出现
     在一个典型的数据库应用中，JSP页面将会调用某些JavaBean组件，这些组件可以通过DBC或者SOLJ直接或间接地访问数据库
    JSP页面在运行之前要被解释成JavaServlet（解释过程是按需进行的，有时可能会提前进行），然后它可以处理HTTP请求并生成响应信息，JSP技术为编写Servlet程序提供了更为便利的途径。
    另外，**JSP页面和Servlet程序是可以相互操作的**，也就是说JSP页面可以包含从Servlet程序输出的内容，可以将内容输出到Servlet程序，反过来Servlet程序也可以包含从JSP页面输出的内容，并且可以将内容输出到JSP页面中。JSP技术的最大优点就是可以将网页的静态内容与动态内容开发分隔开来，从而可以使得精通HTML但对Java不很精通的开发人员专门负责网页静态内容的开发，而那些对Java很在行但却不熟悉HTML的开发人员就可以专注于网页的动态内容的开发。

## xml与数据库（不考，了解）

### 概念

 **XML（Extensible Markup Language），意为可扩展的标记语言。XML是一套定义语义标记的规则**，这些标记将文档分成许多部件并对这些部件加以标识。它也是元标记语言，即定义了用于定义其他与特定领域有关的、语义的、结构化的标记语言的句法语言。

  **关于XML要理解的第一件事是，它不只是像HTML超文本标记语言或是格式化的程序。这些语言定义了一套固定的标记，用来描述一定数目的元素。如果标记语言中没有所需的标记用户也就没有办法了**。这时只好等待标记语言的下一个版本，希望在新版本中能够包括所需的标记，但是这样一来就得依赖于软件开发商的选择了。但是XML是一种元标记语言。用户可以定义自己需要的标记。这些标记必须根据某些通用的原理来创建，但是在标记的意义上，也具有相当的灵活性。例如，假如用户正在处理与家谱有关的事情，需要描述人的出生、死亡、理葬地、家庭、结婚、离婚等，这就必须创建用于每项的标记。新创建的标记可在**文档类型定义（Document Type Definition，DTD）**中加以描述。**XML定义了一套元句法，与特定领域有关的标记语言都必须遵守。如果一个应用程序可以理解这一元句法，那么它也就自动地能够理解所有的由此元语言建立起来的语言**。浏览器不必事先了解多种不同的标记语言使用的每个标记。事实是，浏览器在读入文档或是它的DD时才了解了给定文档使用的标记。关于如何显示这些标记的内容的详细指令是附加在文档上的另外的样式单提供的。有了XML就意味着不必等待浏览器的开发商来满足用户的需要了。用户可以创建白己需要的标记，当需要时，告诉浏览器如何显示这些标记就可以了。
    关于XML要了解的第二件事是，XML标记描述的是文档的结构和意义。它不描述页面元素的格式化。可用样式单为文档增加格式化信息。文档本身只说明文档包括什么标记，而不是说明文档看起来是什么样的。**XML是一种元标记语言，可用来设计与特定专业领域有关的标记语言**。每种基于XML的标记语言都叫作XML应用程序。这种应用不是像Web浏览器或XMLPro那样的编辑器一样地使用XML，而是在特定的领域中应用XML，如化学上用的化学标记语言（Chemical Markup Language，CML）。每种XML应用程序有它自己的句法和词汇表。这种句法和词汇表遵守XML的基本规则。这有点像人类语言，每种语言都有它们自己的词汇表和语法，但同时遵循人体解学和大脑结构所要求的基本规则。**XML是以文本数据为基础的非常灵活的格式**。在本章中讨论的广泛的应用都选择了XMI作为基础的原因是（排除大肆宣传的因素），XML提供了切合实际的并清楚地描述了的易
于读写的格式。应用程序将这种格式用于它的数据，就能够将大量的处理细节让几个标准工具和库函数去解决。更进一步说，对于这样的程序也容易将附加的句法和语义加到XMI提供的基本结构之上。

### XML存储问题

 如果采用文件存储XML，那么会受到文件系统的限制，出现如下问题
   **1）大小**
    第一个局限是文档大小。**如果XMI文件存储了太多的数据，将变得非常不实用**。不仅仅是因为它太大了，而且想维护文档的不同部分也变得难于操纵。我们希望处理巨大的文档，并且想检查同其他部分分离的部分文档。
    **2）并发性**
    我们也希望让不同的人在不同的时间更新不同的部分。在一个文件系统中只有一个单一文档，在一个时间只能有一个人可以处理信息
    **3）工具选择**
      个XML编辑器可能不是处理一个文档不同部分的合适工具。我们想使用最适合处理数据的工具维护文档的各个部分。
    **4）版本**
    一个经常考虑的重要问题是控制同一文档的不同版本。我们想能够记录一个文档不同版本的轨迹。
   **5）安全**
    使用不同的工具处理文档的不同部分，并且允许不同的用户在同一时刻处理文档的不同部分引发出安全问题。我们希望控制一个文档的某一部分只有某人可以查看或修改。
    **6）综合性：集中和重复**
    我们希望在文档中无缝地集成其他的外部数据。
     **文件系统的局限限制了XML，而数据库则可以突破文件系统的这些限制**，所以将XML与数据库相结合是必要的。

### xml与数据库的数据转换

![image-20240424153037854](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243925.png)

## 面向对象数据库

  数据库技术**与面向对象程序设计方法相结合形成了面向对象数据库系统（Object Oriented Database System,OODBS）**，它是支持将数据当作对象来模拟和创造的一种数据库管理系统。通常认为，对象数据库必须满足两项标准：它必须是一个数据库管理系统，并且必须是面向对象的系统，例如在尽可能的范围内它必须与当前的面向对象的程序语言相兼容。第一个标准转换为**五个特征：持续性、二级存储管理、同步性、防御性和一个特定询问工具**。第二个标准转换为**八个特性：复杂的对象、对象一致性、封装、类型、继承性、约束、可延长性和计算的完全性**。
	面向对象数据库有以下几大优势
    （1）**更快的开发速度**，直接使用程序开发语言实现，不需要再编写烦项的操作SQL的语句，大大**节约了开发成本**。
    （2）**更快的运行速度**，采用导航式的搜索模式，对数据的获取可以更高效。对象数据库保持着世界上最大的数据库和被记录到的最高摄取率。
    （3）**强大的数据管理支持能力**，适用于复杂数据的管理
    （4）**支持分布式数据节点管理**，适用于建立统一的大型数据环境
     在这里我们主要对db40进行一下简单的介绍。db40是一个开源的纯面向对象数据库引擎，对于Java与NET开发者来说都是一个简单易用的对象持久化工具。同时，db40已经被第三方验证为具有优秀性能的面向对象数据库。db40的一个突出的优点是无需DBA的管理，占用资
源很小，很适合嵌入式应用以及Cache应用。所以自从db40发布以来便迅速吸引了大批用户将db40用于各种各样的嵌入式系统，包括流动软件、医疗设备和实时控制系统。
    **db40**的目标是提供一个功能强大的，适合嵌入的**数据库引擎**，其主要特性如下：
     （1）开源模式。
    （2）原生数据库
     （3）高性能。
    （4）易嵌入。
     （5）零管理。
     （6）支持多种平台。

### 面向对象数据库系统的特征

1. **具有表达和管理对象的能力**

   应该支持对象标识，是的对象的存在不依赖于本身的值，而只依赖于它的表示，对象间能够通过对象标识而相互区分

2. **对象可以具有任意复杂的的对象结果**

   使对象能够包含所有描述该对象的必要信息

3. **必须具有与面向对象编程语言交互的接口**

   把对象持久地存储起来

4. **具有表达和管理数据库变化的能力**

### 面向对象数据模型

   **数据模型是现实世界对象或实体，以及对象的约束和对象间联系的逻辑组织**。面向对象数据模型借鉴了面向对象的概念，是面向对象数据库系统所必须支持的数据模型。
    面向对象数据库系统是以面向对象数据模型为基础的，是当今数据库技术发展的一大趋势。对于面向对象数据模型，已经有许多基本概念达成了共识，但是仍然缺少一个统一的严格的定义。面向对象数据模型可以看作是一个更高层次上的实现数据模型的新成员，它经常被用作高层概念模型，无其在软件工程领域中更是如此
       系列面向对象的概念构成了面向对象数据模型的基础。概括起来，面向对象数据模型的基本概念有对象、类、继承、对象标识、对象嵌套等

#### 对象结构

   我们可以认为**一个对象对应着E-R模型中的一个实体。对象中封装的属性和方法对外界是不可见的，对象之间的相互作用要通过消息来实现**。一般来讲，一个对象有如下相关内容：

- **（1）属性集合：一个对象的属性值构成了该对象的状态，类似于关系数据库中关系元组的属性**。属性的**值域可以是任何类，包括原子类，如整型值、字符串**等。一个属性可以有一个单值，**也可以**有一个来自于某个值域的值集，即一个对象的属性可以是一个对象，从而**形成了嵌套关系**。
- **（2）方法集合：一个对象的方法作用于该对象的状态上，同一类对象所有操作的实现相同。方法的定义和实现：定义规定了方法名称、参数的个数和类型、返回值的类型，以及可能的语义描述：实现是一段代码，用来实现方法的功能。方法的定义和实现是相互分离的，为程序员提供了极大的灵活性，甚至可以用不同的语言实现不同的操作。**
- **（3）消息集合：消息是发送给对象以存取属性值的，除了通过对象所指定的公共界面外没有其他方法可以访问该对象。对象接收外部传送的消息，执行相应的操作，操作的结果同样可以以消息的形式返回**

#### 对象类

> **面向对象与关系模型的对照**
>
> 1. 类=实体
> 2. 对象=元组
> 3. 属性=属性

  在面向对象数据库中，**类是一系列相似对象的集合**，对应于E-R模型中的实体集概念。**类是面向对象系统和数据库系统之间最重要的连接**。首先，**类直接说明了一个实例及其所属类之间的实例关系**；其次，类提供了构成查询的基础；再次，类可以用来增加面向对象数据库的语义完整性；最后，类提出了所有对象的属性和方法的规格说明，便于生成对象。

   每个对象是它所在类的一个实例。类的概念类似于关系模式，**类的属性类似于关系模式中的属性；对象类似于元组，类的一个实例对象类似于关系中的一个元组**。如果**把类本身看作一个对象，则称之为类对象**。**与其相关的属性集和方法集适用于该类对象而不适用于该类的实例这样的属性和方法称之为类属性和类方法**。一个类的**类属性常常用来描述该类的实例的聚集特性。例如，所有学生实例的“平均年龄”就是一个聚集特性的例子。**


#### 继承和多重继承

  在面向对象数据模型中，**所有类形成了一个有限的层次结构或者是有根的无环有向图，我们称之为类层次**。如有一个类C和一个连接到C的一组较低层类的集合S，则集合S中的类称为类C的子类，而类C又称为集合S中类的父类。集合S中的任何类继承类C的所有属性和方法，并可以有白己定义的属性和方法。一个父类可以有多个子类，一个子类也可以有多个父类，都存在直接关联或者间接关联的现象。
    在面向对象数据模型中存在着两种继承：继承（单继承）和多重继承。在大多数情况下，类的继承足以满足应用的要求，**典型的树型结构组织用来表示类层次。在树型结构组织中，每个类最多有一个父类，即一个子类只能继承一个父类的属性、方法和消息**。然而，有些情况用树型结构并不能很好地表达类层次。**多重继承允许一个类从多个直接父类中继承属性、方法和消息，此时类层次可以用一个有向无环图来表示。**
    在图14-10中给出了一个学校数据库的类层次结构图，通过它我们分别来解释类层次、继承和多重继承。

![image-20240424160223082](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243926.png)

  类的继承带来很多的优点，**子类在继承父类特性的同时**，还可以定义白身的属性、方法和消息，但这样就**可能和父类的属性、方法和消息发生冲突。这类冲突可能发生在子类和父类之间，通常由系统解决**。对于**子类和父类之间的同名冲突，一般是以子类定义的为准。但是在多继承中，一个子类可以有多个父类，如果这些父类中存在同名冲突，就会发生二义性**。例如，教工和学生都有方法“显示信息”，它们共同的子类在职研究生就不知道应该继承哪一个方法了。在多继承中有三种处理二义性的方案：一是由用户选择继承的优先次序；二是由系统指定
继承某一个父类的定义：三是如果出现了二义性问题，就不允许多继承，甚至有些面向对象数据库系统根本不允许多继承

#### 对象标识

**每个对象有一个唯一的、由系统生成的对象标识（Object Identifier，OID）。OID的值对外部用户来说是不可见的，但是系统会在内部用这个值唯一地标识每个对象，并用这个值创建和管理内部对象引用**
    相对于非面向对象数据模型和程序设计语言来说，对象标识给出了一种更强的标识概念几种常用的标识形式如下：
    **（1）值：用于标识的一个数据值**。这种形式的标识常在关系数据库中使用。如一个元组的主码标识了这个元组。
    **（2）名称：用于标识的用户提供的一个名称**。在程序设计语言中，用户赋予每个变量一个名字来标识它：在文件系统中，用户给每个文件赋予一个名称来唯一地标识这个文件。
    **（3）内置名**：以上两种标识是由用户给出的，而内置名则是一种由系统来提供的标识。这种形式的标识在数据模型或程序设计语言中使用
     不同的**标识符其持久性程度**是不同的，主要有以下几种
    **（1）过程内持久性：标识只有在单个过程的执行期间才是持久的**，如过程内的**局部变量**

> 局部变量

**（2）程序内持久性：标识只有在单个程序或查询执行期间才是持久的**，如程序设计语言中的**全局变量、内存指针，SQL语句中的元组标识符**。

> 全局变量

​    **（3）程序间持久性：标识在从一个程序的执行到另一个程序的执行期间都保持不变**，如**指向磁盘上的文件系统数据的指针提供了程序之间的标识，SQL语句中的关系名也具有程序间持久性**

> 环境变量？

 **（4）永久持久性：标识的持久性不仅仅跨越了各个程序的执行，还跨越了数据结构的重新组织。这种持久性正是面向对象系统所要求的。**

> 系统变量？

​    **对象标识符必须具有永久持久性，也就是说，特定对象一经产生，系统就赋予一个在全系统中唯一的对象标识符，应该是固定不变的，一直到它被删除。面向对象数据库系统必须具有生成对象标识并维护其永远不变性的机制。**
​     **标识符通常是由系统动生成的，不需要用户来完成这项工作**。然而在使用这种功能时要注意：系统生成的标识符通常是特定于这个系统的，**如果要将数据转移到另一个不同的数据库系统中，则标识符必须进行转化。而且，如果一个实体在建模时已经有一个系统之外的唯一标识符，则系统生成的标识符就可能是多余的。如身份证号码可以作为个人的唯一标识符。**
​    早期的面向对象数据模型要求把所有的一切表示为对象，无论是一个简单的值还是一个复杂的对象，导致这样的情况出现：两个整型数值10和20，需要创建两个具有不同OID的对象这种模型需要生成很多的对象标识符，很不实用。因此，大多数的面向对象数据库系统允许有对象和值两种表示方法，即**每个对象必须有一个永远不变的OID，但是值没有OID，值只是代表它自己。**
​    

#### 对象嵌套

对象嵌套是面向对象数据库系统中的一个重要概念。
    在面向对象数据模型中，对象的一个属性可以是一个单一值，也可以是一个来自于值域的值集，即**一个对象的属性可以是一个对象，形成了嵌套关系**，产生了一个嵌套层次结构。
      **一个对象被称为复杂对象，如果它的某个属性的值是另一个对象**。**复杂对象主要分为两类：非结构化的复杂对象和结构化的复杂对象**。**非结构化的复杂对象通常是数据库系统不明结构、需要大量存储空间的数据类型，如图像或大文本对象。结构化的复杂对象是指数据库系统清楚对象内部结构，并可以通过递归生成的对象。**
    关系模式是对一个二维关系的描述，具有平面的结构。前面讲到的类层次结构形成了对象间的纵向关系，这里的对象嵌套层次结构则形成了对象间的横向关系。我们通过图14-11来说明。每台笔记本电脑包括：产地、型号、外部设备和内部器件等属性。其中产地和型号的数据类型是字符串，外部设备和内部器件都不是标准数据类型，而是对象。外部设备包括：外接鼠标和外接光驱等属性；内部器件包括：显示器、CPU、内存、硬盘等属性；外接光驱也是一个对象，包括：产地、型号、功率等属性。这样一种嵌套层次结构允许不同的用户采用不同的粒度来观察对象，突出了对象的特征，隐藏了不必要的信息，简化了查询。

![image-20240424161137102](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243927.png)

### 面向对象数据库语言

   **面向对象数据库语言用于描述面向对象数据库的模式，说明并操纵类定义与对象实例**。与关系数据库的标准语言SQL类似，面向对象数据库语言主要包括对象定义语言和对象操纵语言。对象查询语言是对象操纵语言的一个重要子集
    面向对象数据库语言一般应具备下列功能
    **（1）类的定义和操纵**。面向对象数据库语言可以操纵类，包括定义、生成、存取、修改与撤销类。其中类的定义**包括定义类的属性、操作特征、继承性与约束等。**
    **（2）操作/方法的定义**。面向对象数据库语言可用于对象操作/方法的定义与实现。在操作实现中，语言的**命令可用于操作对象的局部数据结构**。对象模型中的封装性允许操作/方法由不同程序设计语言来实现，并且隐藏不同程序设计语言实现的事实。
    **（3）对象的操纵**。面向对象数据库语言可以用于操纵实例对象

### 对象关系数据库系统

![image-20240424163303554](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243928.png)

![image-20240424163342784](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243929.png)

![image-20240424163350842](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243930.png)

![image-20240424163409936](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243931.png)

![image-20240424163454186](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243932.png)

![image-20240424163519319](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243933.png)

![image-20240424163535055](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243935.png)

## 大数据与数据库（重点）

  大数据（BigData）是一种具有海量的数据规模，在获取、存储、管理和分析等方面都远远超过传统数据库处理范围的数据集合。大数据渗透在每个行业和业务领域，为人类提供辅助服务，以及为智能体（Agent）提供决策服务。
     大数据能够有访问大量数据的能力，在重复处理和数据模式独特时，也就是无法使用传统技术、处理算法等方案处理，大数据能够从这些数据中获得关键的见解，人为干预少，数据分析更加简单无误。在当下，**基础设施结合新的数据处理框架和平台（例如Hadoop**和NoSQL）能够显著降低成本，而且具有很高的扩展性。大数据不仅包括企业应用系统的数据分析，还包括行业产业深度融合，下面是一些例子：

![image-20240424163731209](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243936.png)

### 数据仓库设计

**数据仓库四个基本特征：**

1. **面向主题**
2. **集成**
3. **不可更新**
4. **随时间不断变化**

这些特点说明了数据仓库从数据组织到面向分析的数据处理都与原来的数据库有较大区别，这决定了我们在进行数据仓库系统设计时，不能够照搬原来传统的数据库系统开发方法因而需要寻找一个适于数据仓库设计的方法
  所谓数据模型，就是对现实世界进行抽象的工具，抽象的程度不同，也就形成了不同抽象级别层次上的数据模型。**数据仓库的数据模型与操作型数据库的三级数据模型又有一定的区别，主要表现在：**
 **（1）**数据仓库的数据模型中**不包含纯操作型的数据**
**（2）**数据仓库的数据模型**扩充了码结构，增加了时间属性作为码的一部分。**
**（3）**数据仓库的数据模型中**增加了一些导出数据。**
可以看出，上述三点差别也就是操作型环境中的数据与数据仓库中的数据之间的差别，同样是数据仓库为面向数据分析处理所要求的。虽然存在着这样的差别，在数据仓库设计中，仍然存在着三级数据模型，即概念模型、逻辑模型和物理模型。
    **在数据仓库的设计中采用的逻辑模型就是关系模型**。无论是主题还是主题之间的联系，都用关系来标识。关系模型概念简单、清晰，用户易懂、易用，有严格的数学基础和在此基础上发展的关系数据理论；关系模型简化了程序员的工作和数据仓库设计开发的工作，当前比较成熟的商品化数据库产品都是基于关系模型的。因此采用关系模型作为数据仓库的逻辑模型是合适的。数据仓库的逻辑模型描述了数据仓库的主题的逻辑实现，即每个主题所对应的关系表的关系模式的定义。

　所谓数据仓库的物理就是逻辑模型在数据仓库中的实现，如物理存取方式、数据存储结构、数据存放位置以及存储分配等等。物理模型是在逻辑模型的基础之上实现的，在进行**物理模型设计实现时，所考虑的主要因素有：IO存取时间、空间利用率和维护代价**；在进行数据仓库的物理模型设计时，**考虑到数据仓库的数据量大，但是操作单一的特点，可采取其他的一些提高数据仓库性能的技术，如：合并表、建立数据序列、引入元余、进一步细分数据、生成导出数据、建立广义索引等等。**
     建立数据仓库过程中的一个重要问题是如何提高系统的性能。因为数据仓库的数据量很大，分析处理时涉及的数据范围也较广，往往涉及大规模数据的查询。提高系统性能，主要是要提高系统的物理IO性能，因为IO瓶颈常成为影响系统性能的主要因素。在数据仓库的设计中，**应尽量减少每次查询处理要求的IO次数，而使每次IO又能返回尽量多的记录**。事实上，由于数据仓库的数据极少甚至不再更新，数据仓库的物理设计可以有更多的方法和途径来提高系统性能。下面介绍粒度划分和数据分割
    **1）粒度划分**
    对数据仓库开发者来说，**划分粒度是设计过程中最重要的问题之一。所谓粒度指数据仓库中数据单元的详细程度和级别。数据越详细，粒度越小级别就越低；数据综合度越高，粒度越大级别就越高**。在**传统的操作型系统中，对数据的处理和操作都是在详细数据级别上的，即最低级的粒度。但是在数据仓库环境中主要是分析型处理，粒度的划分将直接影响数据仓库中的数据量以及所适合的查询类型**。一般**需要将数据划分为：详细数据、轻度总结、高度总结三级或更多级粒度。不同粒度级别的数据用于不同类型的分析处理**。粒度的划分是数据仓库设计工作的一项重要内容，粒度划分是否适当是影响数据仓库性能的一个重要方面。
    **2）数据分割**
    数据分割是数据仓库设计的另一项重要内容，**是提高数据仓库性能的一项重要技术。数据的分割是指把逻辑上是统一整体的数据分割成较小的、可以独立管理的物理单元进行存储，以便于重构、重组和恢复，以提高创建索引和顺序扫描的效率。数据的分割使数据仓库的开发人员和用户具有更大的灵活性**。数据仓库中数据分割的概念**与数据库中的数据分片概念是相近的**。数据库系统中的数据分片有水平分片、垂直分片、混合分片和导出分片多种方式。水平分片是指按一定的条件将一个关系按行分为若干不相交的子集，每个子集为关系的一个片段：垂直分片是指将关系按列分为若干子集，垂直分片的片段必须能够重构原来的全局关系。
    在进行数据仓库设计时需要把数据分割与粒度划分结合起来考虑。
    **数据仓库中的元数据就是关于数据的数据，它描述了数据的结构、内容、码、索引等项内容。传统数据库中的数据字典是一种元数据，但在数据仓库中，元数据的内容比数据库中的数据字典更丰富、更复杂**。设计一个描述能力强、内容完善的元数据，是有效管理数据仓库的具有决定意义的重要前提。因此元数据的设计在整个数据仓库设计中占有重要的地位，是数据仓库设计的一个重要组成部分

![image-20240424164911676](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243937.png)

![image-20240424164925462](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243938.png)

### 数据转移技术

![image-20240424165227192](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243939.png)

![image-20240424165349753](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243940.png)

![image-20240424165517525](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243941.png)

![image-20240424165558661](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243942.png)

### 数据挖掘技术（常考）

**数据挖掘的分析方法**

- **关联分析**：关联分析主要用于发现不同事件之间的关联性，即一个事件发生的同时另一个事件也经常发生

  > **啤酒和尿布放一起销售量剧增**的案例

- 序列分析：序列分析主要用于发现**一定时间间隔内接连发生**的事件，这些事件构成个序列，发现的列应该具有普遍意义。

- **分类分析（重要）**：按照某种已有的标准**给对象贴标签，再根据标签来分类**。其首先为每个记录赋予一个标记（一组具有不同特征的类别），即按标记分类记录，然后检查这些标定的记录，描述出这些记录的特征。

  > **分类分析要求原本有标准，比如：根据xxx，分析xxx**

- **聚类分析（重要）**：聚类分析是根据“**物以类聚**”的原理，将本身没有类别的样本聚集成不同的组，并且对每个这样的组进行描述的过程

  > **聚类分析要求原本没有标准，比如：直接分类；于不知道数据对象有哪些类型时使用**

**数据挖掘算法（了解分类即可）**

- **EM**：在概率模型中寻找参数最大似然估计的算法，**聚类**
- **Apriori**:先验算法是**关联**规则学习的经典算法之一
- **K-means**：是非监督学习中的**聚类算法**。
- **SVM**：中文名为支持向机，是常见的一种判别方法。在机器学习领域，是一个有监督的学习模型，通常用来进行**模式识别、分类以及回归分析。**
- **决策树**：典型的**分类算法**
- **C4.5：分类**

| 聚类                 | 分类                          | 关联          |
| -------------------- | ----------------------------- | ------------- |
| EM                   | **决策树decision trees**      | **Apriori**   |
| **K-means（K均值）** | C4.5                          | **FP-Growth** |
| **层次Hierarchical** | **SVM（支持向量机）**         |               |
| **DBSCAN基于密度**   | **朴素贝叶斯（naive bayes）** |               |
| 光谱聚类（spectral） | **随机森林random forests**    |               |



### 联机分析处理ＯＬＡＰ

**联机分析处理（On-LimeAnalyticalProcessing，OLAP）是针对待定问题的联机数据访问和分析。为了反映用户所能理解的企业的真实的“维”，原始的数据被进行了转换，从而形成了可用的信息**。通过对信息的很多种可能的观察形式进行快速、稳定一致的交互性存取，允许管理决策人员对数据进行深入观察。
    **OLAP是以数据仓库进行分析决策的基础**，针对特定问题的联机数据访问和分析，**OLAP能够对不同数据集合进行基于某个或是多个角度的比较，它能够从不同角度切割数据集合从而进行分析。从某种意义来说，OLAP是有预见性的。OLAP的分析是建立在经验的基础上，对数据进行某种指定关联的分析**。在联机事务处理系统中，由于数据的离散性，而使OLAP实现起来相当复杂甚至是不可能，而以数据仓库为依托，辅之以OLAP工具，OLAP的实现将十分简单易行。

#### OLAP中的基本概念

- ​    **（1）变量：变量是数据的实际意义，即描述数据“是什么**”。例如，数据“10000”本身并没有意义或者说意义未定，它可能是一个学校的学生人数，也可能是某产品的单价，还可能是某商品的销售量等等。一般情况下，变量总是一个数值度量指标，例如，“人数”“单价”“销售量”等都是变量，而“10000”则是变量的一个值。

- ​    **（2）维：维是人们观察数据的特定角度**。例如，企业常常关心产品销售数据随着时间推移而产生的变化情况，这时他是**从时间的角度来观察产品的销售**，所以**时间就是一个维，简称为时间维**。企业也时常关心自己的产品在不同地区的销售分布情况，这时他是从地理分布的角度来观察产品的销售，所以**地理分布也是一个维，称为地理维。**

- ​    **（3）维的层次：人们观察数据的某个特定角度（即某个维）还可以存在细节程度不同的多个描述方面，我们称这多个描述方面为维的层次**。一个维往往具有多个层次，例**如描述时间维可以从日期、月份、季度、年等不同层次来描**述，那么日期、月份、季度、年等就是时间维的层次；**同样，城市、地区、国家等构成了一个地理维的多个层次**

- **（4）维成员：维的一个取值称为该维的一个维成员。如果一个维是多层次的，那么该维的维成员是在不同维层次的取值的组合。例如，我们考虑时间维具有日期、月份、年这三个层次，分别在日期、月份、年上各取一个值组合起来，就得到了时间维的一个维成员，即“某年某月某日**”。**一个维成员并不一定在每个维层次上都要取值**，例如，“某年某月”“某月某日”“某年”等等都是时间维的维成员。对应一个数据项来说，维成员是该数据项在某维中位置的描述例如对一个销售数据来说，时间维的维成员“某年某月某日”就表示该销售数据是“某年某月某日”的销售数据，“某年某月某日”是该销售数据在时间维上位置的描述。

- ​    **（5）多维数组：一个多维数组可以表示为（维1，维2，，维n，变量）。例如，（地区，时间，销售渠道，销售额）就是一个多维数组**，其中**销售额是变量，它定义在地区维、时间维和销售渠道维这三者的基础上**

  > 多维数组里的变量的值是根据各维度的值去确定的就叫做变量

- ​     **（6）数据单元：多维数组的取值称为数据单元。当在多维数组的各个维中都选中一个维成员，这些维成员就唯一确定了一个变量的值。**

  那么数据单元就可以表示为（维1的维成员，维2的维成员，…维的维成员，变量的值）。

#### 多维分析

​    **多维分析是指对以多维形式组织起来的数据采取切片、切块、旋转**等各种分析动作，以求析数据，使最终用户能从多个角度、多侧面地观察数据库中的数据，从而深入地了解包含在数据中的信息、内涵。多维分析方式迎合了人的思维模式，因此减少了混滑并且降低了出现错误解释的可能性。多维分析的基本动作有：
​    **（1）切片：在多维数组的某一维上选定一维成员的动作称为切片**，即在多维数组（维1，维2，…，维n，变量）中选一维，并取其一维成员。
​     **2）切块：在多维数组的某一维上选定某一区间的维成员的动作称为切块，即限制多维数组的某一维的取值区间**。显然，当这一区间只取一个维成员时，即得到一个切片。
​    **（3）旋转：旋转即改变一个报告或页面显示的维方向**。例如，旋转可能包含了交换行和列，或是把某一个行维移到列维中去，或是把页面显示中的一个维和页面外的维进行交换（令其成为新的行或列中的一个）。
​     **OLAP的数据来源于数据库。通过OLAP服务器**，将这些数据抽取和转换为多维数据结构以反映用户能理解的企业的真实维。通过多维分析工具对信息的多个角度、多个侧面进行快速、致和交互的存取，从而使分析员、经理和行政人员能够对数据进行深入地分析和观察。
​    在数据仓库系统中OLAP使用的多维数据可以位于不同的层次，可以作为数据仓库的一部分，也可以作为数据仓库工具层的一部分。由于所处的层次的不同，其分析结果的综合程度也相应有高低之分，所以可以满足具有不同应用需求用户的要求

#### 十二条准则

​    1993年，Codd提出了有关OLAP的十二条准则，这也是他继关系数据库和分布式数据库提出的两个“十二条准则”后提出的第三个“**十二条准则**”

 **（1）OLAP模型必须提供多维概念视图**：从用户分析员的角度来看，整个企业的视图在本质上是多维的，因此OLAP的概念模型也应是多维的。企业决策分析的目的不同，决定了分析和衡量企业的数据总是从不同的角度来进行的，所以企业数据空间本身就是多维的。
    **（2）透明性准则：无论OLAP是否是前端产品的一部分，对用户来说，它都是透明的**。如果**在客户服务器结构中提供OLAP产品，那么对最终分析员来说，它同样也应透明**。透明性原则**包括两层含义：首先，OLAP在体系结构中的位置对用户是透明的**。OLAP应处于一个真正的开放系统结构中，允许分析工具嵌入到分析人员指定的任何位置而不影响嵌入工具的性能这对保持用户现有的效率，保证良好的性能至关重要。同时必须保证OLAP的嵌入不会引入和增加任何复杂性。**其次，OLAP的数据源对用户也是透明的**。用户只需使用熟悉的查询工具进行查询，而不必关心输入OLAP工具的数据是来自于同构还是异构的企业数据源

> **位置透明和数据源透明**

   **（3）存取能力准则：OLAP系统不仅能进行开放的存取，而且还提供高效的存取策略**。OLAP用户分析员**不仅**能在**公共概念视图的基础**上对关系数据库中的企业数据进行分析，**而且**在**公共分析模型的基础**上还可以对关系数据库、非关系数据库和外部存储的数据进行分析。OLAP系统应提供高效的存取策略，应使系统只存取与指定分析有关的数据，避免多余的数据存取

**（4）稳定的报表性能：当数据的维数和综合层次增加时**，提供给最终分析员的**报表能力和响应速度不应该有明显的降低和减慢**，这**对维护OLAP产品的易用性和低复杂性至关重要**。即便当企业模型改变时，关键数据的计算方法也无需更改。**只有**做到这一点，OLAP工具提供的数据报表和所做的预测分析结果**才是可信**的。
     **（5）客户/服务器体系结构：OLAP是建立在客户/服务器体系结构上的**。这要求它的多维数据库服务器能够被不同的应用和工具访问到。服务器端智能地**以最小的代价**完成同多种服务器之间的挂接任务，服务器端必须完成分散的企业数据库的逻辑模式和物理模式之间的映射并**确保它们的一致性**，从而保证透明性和建立统一的公共概念模式、逻辑模式和物理模式。客户端负责应用逻辑和用户界面
     **（6）维的等同性准则：每一数据维在数据结构和操作能力上都是等同的**。系统可以将附加的操作能力赋予所选的维，但必须保证该操作能力可以赋予其他任意的维，即**要求维上的操作是公共的**。
    **（7）动态的稀疏矩阵处理准则：OLAP工具的物理模型必须充分适应指定的分析模型，提供“最优”的稀疏矩阵处理**，这是OLAP工具所应遵循的**最重要的准则之一**。该准则包括**两层含义：第一，对任意给定的稀疏矩阵，存在且仅存在一个最优的物理视图，它能提供最大的内存效率和矩阵处理能力。稀疏度是数据分布的一个特征，如果不能适应数据集合的数据分布将会导致快速、高效操作的失败。第二，OLAP工具的基本物理数据单元可配置给可能出现的维的子集。同时，还要提供动态可变的访问方法并包含多种存取机制，使得访问速度不会因数据维的多少、数据集的大小而变化**
    **（8）多用户支持能力准则：多个用户分析员可以同时工作于同一分析模型上，或者可以在同一企业数据上建立不同的分析模型**。该准则可由准则5推出。OLAP工具**必须提供并发访问数据完整性及安全性机制**。实际上，OLAP工具**必须支持多用户**也是为了适合数据分析工作的特点。我们推荐以工作组的形式来使用OLAP工具，这样多个用户可以交换各自的想法和分析结果。

 **（9）不受限的跨维操作：多维数据之间存在固有的层次关系**，这就**要求OLAP工具能白己推导出而不是由最终用户明确定义出相关的计算**。对于无法从固有关系中得出的计算，要求系统提供计算完备的语言来定义各类计算公式。该准则是对准则1的一个补充，对操作能力和操作范围做出了要求。
    **（10）直观的数据操纵：要求数据操纵直观易懂。综合路径重定位、向上综合、向下挖掘和其他操作都可以通过直观、方便的点拉操作完成**。
     **（11）灵活的报表生成：报表必须从各种可能的方面显示出从数据模型中综合出的数据和信息，充分反映数据分析模型的多维特征**。
     **（12）不受限制的维数与聚集层次：OLAP工具的维数应不小于15维，用户分析员可以在任意给定的综合路径上建立任意多个聚集层次**。

### 联机事务处理ＯＬＴＰ

- **OLAP的特点**

 **OLAP主要是关于如何理解聚集的大量不同的数据**。与OLTP应用程序不同，**OLAP包含许多具有复杂关系的数据项。OLAP的日的就是分析这些数据，寻找模式、趋势以及例外情况OLAP是决策人员和高层管理人员对数据仓库进行信息分析处理**。联机分析处理可以被刻画为具有下面特征的联机事务：
    （1）可以存取大量的数据，比如几年的销售数据，分析各个商业元素类型之间的关系，如销售、产品、地区、渠道。
     （2）需要包含聚集的数据，例如销售量、预算金额以及消费金额
     3）按层次对比不同时间周期的聚集数据，如月、李度或者年。
    （4）以不同的方式来表现数据，如以地区、或者每一地区内按不同销售渠道、不同产品来表现。
    （5）需要包含数据元素之间的复杂计算，如在某一地区的每一销售渠道的期望利润与销售收入之间的分析
    （6）能够快速地响应用户的查询，以便用户的分析思考过程不受系统影响
     OLAP服务器允许用熟悉的工具方便地存取不同的数据源。快速响应时间是OLAP中的关键因素。它分批处理报表，应用程序中的信息必须快速可得，以便执行进一步的分析。为了使分析过程变得容易，OLAP应用程序经常以诸如电子表格这样容易识的形式提交数据。OLTP是操作人员和低层管理人员利用计算机网络对数据库中的数据进行查询、增加、删除、修改等操作，以完成事务处理工作。

- **OLTP的特点**

**OLTP以快速事务响应和频繁的数据修改为特征**，用户利用数据库快速地处理具体业务。**OLTP应用时有频繁的写操作，所以数据库要提供数据锁、事务日志等机制。OLTP应用要求多个查询并行，以便将每个查询的执行分布到一个处理器上。**
与OLAP应用程序不同，**OLTP应用程序包含大量相对简单的事务。对这些事务通常只是需要获取或更新其中的一小部分数据，且这些表之间的关系通常是很简单的**
现代的数据库存储有数以万计的数据，经常每天处理成千上万的事务，**OLTP数据库在查找业务数据时是非常有效的**。但在为决策者提供综合汇总性数据时则显得力不从心。这就需要OLAP技术。**OLAP是一项以灵活、可用和及时的方式构造、处理和表示综合数据的技术**。例如，下面一个简单的问题：查看1999年西南地区的销售情况，数据按省、季度和产品分类。首先要从OLTP的数据库中抽取数据，这需要大量的时间：然后，还要用大量的时间来查询检索该年四个季度每个月的销售数据等。而用OLAP技术则可以在几秒钟内完成这样的问题

  **OLTP的特点在于事务量大，但事务内容比较简单且重复率高**。大量的数据操作主要涉及的是一些增加、删除、修改操作，一般仅仅涉及一张或几张表的少数记录，因此**OLTP适合于处理高度结构化的信息**。与其相适应，在数据组织方面**OLTP以应用为核心，是应用驱动的，数据模型采用E-R模型**
  OLTP处理的数据是高度结构化的，涉及的事务比较简单，因此复杂的表关联不会严重影响性能。反之，决策支持系统的一个查询可能涉及数万条记录。这时复杂的联接操作会严重影响性能。在OLTP系统中，数据访问路径是已知的，至少是相对固定的，应用程序可以在事务中使用具体的数据结构如表、索引等。而决策支持系统使用的数据不仅有结构化数据，而且有非结构化数据，用户常常是在想要某种数据前才决定去分析该数据。因此数据仓库系统中一定要为用户设计出更为简明的数据分析模型，这样才能为决策支持提供更为透明的数据访问

- OLAP和OLTP对比图

  | OLAP                             | OLTP                           |
  | -------------------------------- | ------------------------------ |
  | 数据库**导出**数据或数据仓库数据 | 数据库**原始**数据             |
  | 综合性数据                       | 细节性数据                     |
  | **历史数据**                     | **当前数据**                   |
  | **不可更新，周期性刷新**         | **经常更新**                   |
  | 一次性处理**数据量大**           | 一次性处理**数据量小**         |
  | **响应时间合理**                 | **响应时间要求高**             |
  | **用户数量相对少**               | **用户数量大**                 |
  | 面向决策人员，支持**管理需要**   | 面向操作人员，支持**日常操作** |
  | **面向分析**，**分析驱动**       | **面向应用**，**事务驱动**     |
  | 提供高效的存储能力               | 事务量大，内容简单，重复率高   |

## New Sql数据库（读一下）

> 特点：支持关系数据模型和使用SQL作为主要接口
>
> 目前Newsql系统可通过架构、SQL引擎和数据分片分成三类

  NewSQL是一种新型关系数据库管理系统，是对各种新的可扩展和高性能数据库的简称，这类数据库不仅具有NoSQL对海量数据的存储管理能力，试图为联机事务处理（OLTP）读写工作负载提供与NoSQL系统相同的可伸缩性能，还保持了传统数据库支持ACID和SQL等特性。

## 主流数据库（关系型和非关系型）（不考，自补）

### 关系型数据库

#### MySQL数据库

    \[[下载地址](https://www.mysql.com/downloads/)\]  
　　MySQL是最受欢迎的开源SQL数据库管理系统，它由 MySQL AB开发、发布和支持（后被sun公司收购，最终被oracle收购）。MySQL AB是一家基于MySQL开发人员的商业公司，它是一家使用了一种成功的商业模式来结合开源价值和方法论的第二代开源公司。MySQL是MySQL AB的注册商标。  
　　MySQL是一个快速的、多线程、多用户和健壮的SQL数据库服务器。MySQL服务器支持关键任务、重负载生产系统的使用，也可以将它嵌入到一个大配置(mass- deployed)的软件中去。    
　　**1、定位：**  
　　开源、多平台、关系型数据库  
　　目前使用最广泛、流行度最高的的开源数据库。  
　　**2、特点：**  
    (1)支持事务，符合关系型数据库原理，符合ACID，支持多数SQL规范，以二维表方式组织数据，有插件式存储引擎，支持多种存储引擎格式  
    (2)用编译安装的方式，或者二进制包的方式，按照“安装软件-创建实例-库表用户初始化”，可以很快完成数据库部署  
    (3)使用标准的SQL语句进行数据库管理，简单SQL语句的并发和性能较好，对视图、存储过程、函数、触发器等支持的不是太好  
    (4)在命令行界面有一些常用的命令显示状态和性能，在图形界面方面，有比较多的开源监控工具来监控和记录数据库的状态，比如zabbix，nagios，cacti，lepus等  
    (5)逻辑备份 mysqldump/mysqldumper ，物理备份 用xtrabackup等工具进行备份；  
    (6)MySQL高可用有多种方案，官方有基础的master-slave主从复制，新版本的innodb cluster，第三方的有MHA等高可用方案；  
    (7)MySQL水平拆分，可以通过水平拆分proxy中间进行逻辑映射和拆分，扩大MySQL数据库的并发能力和吞吐量。  
    **3、适用场景：**  
    默认的innodb存储引擎，支持高并发，简单的绝大部分OLTP场景；  
    Tokudb存储引擎，使用高并发insert的场景；  
    Inforbright存储引擎，可以进行列压缩和OLAP统计查询场景；  
    **4、选择注意：**  
    使用MySQL进行OLTP业务时，需要注意数据量级，如果数据量级过大，需要进行水平拆分；  
    如果有OLAP需求，可以结合其他架构综合考虑。

  

####  Microsoft SQL Server数据库

    \[[官网下载地址](https://www.microsoft.com/zh-cn/sql-server/sql-server-downloads)\] \[[破解下载地址](http://msdn.itellyou.cn/)\]  
    SQL Server是由微软开发的数据库管理系统，是Web上最流行的用于存储数据的数据库，它已广泛用于电子商务、银行、保险、电力等与数据库有关的行业。  
    目前最新版本是SQL Server 2005，它只能在Windows上运行，操作系统的系统稳定性对数据库十分重要。并行实施和共存模型并不成熟，很难处理日益增多的用户数和数据卷，伸缩性有限。  
    SQL Server 提供了众多的Web和电子商务功能，如对XML和Internet标准的丰富支持，通过Web对数据进行轻松安全的访问，具有强大的、灵活的、基于Web的和安全的应用程序管理等。而且，由于其易操作性及其友好的操作界面，深受广大用户的喜爱。    
    **1、定位：**  
    商业、Windows平台、关系型数据库  
    最早接触、与微软体系结合紧密的的商业数据库，属于“微软技术体系”  
    **2、特点：**  
    (1)支持事务，符合关系型数据库原理，符合ACID，支持多数SQL规范，以二维表方式组织数据  
    (2)在Windows平台，用图形界面进行软件安装；  
    使用：在Windows平台，使用SQL Server Mangement Studio图形界面进行安装；  
    (3)一般通过Windows资源管理和SQL server图形工具进行系统和数据库性能显示；  
    (4)通常用第三方备份恢复软件进行备份恢复；  
    高可用：通过共享存储和双机热备的方式，可以实现SQL Server数据库的高可用；  
    (5) SQL Server数据库集群采用共存存储的方式，通过硬件垂直升级来对数据库集群进行扩展；  
    **3、适用场景：**  
    大多数OLTP场景（与微软体系配合）  
    **4、选择注意：**  
    SQL Server与微软技术体系结合比较紧密，绝大多数工作，都是通过图形界面完成，对于习惯使用命令行的DBA可能会有不习惯；  
    SQL server对双引号，大小写，元信息的管理和处理方式，与其他数据库很不相同，需要注意；  
    使用SQL Server满足OLTP业务，会有比较好的效果，但对于大数据量的OLAP业务，最好还是选用专门的OLAP架构，不要在同一个SQL Server实例上混用OLTP和OLAP业务；  
    **SQL server属于商业软件，需要注意版权和licence授权费用；**

  

####  [Oracle](https://so.csdn.net/so/search?q=Oracle&spm=1001.2101.3001.7020)数据库

    \[[下载地址](https://www.oracle.com/technetwork/cn/database/enterprise-edition/downloads/index.html)\]  
    Oracle Database，又名Oracle RDBMS，或简称Oracle。是甲骨文公司的一款关系数据库管理系统。它是在数据库领域一直处于领先地位的产品。可以说Oracle数据库系统是目前世界上流行的关系数据库管理系统，系统可移植性好、使用方便、功能强，适用于各类大、中、小、微机环境。它是一种高效率、可靠性好的 适应高吞吐量的数据库解决方案。  
    **1、定位：**  
    商业、多平台、关系型数据库  
    功能最强大、最复杂、市场占比最高的商业数据库  
    **2、特点：**  
    (1)支持事务，符合关系型数据库原理，符合ACID，支持多数SQL规范，以二维表方式组织数据  
    (2)Oracle单实例数据库部署相对容易，但Oracle RAC集群环境，部署的步骤和依赖条件都比较多；  
    (3)通常使用命令行工具，进行各种数据库的管理，通常也可以用shell脚本和python脚本提高Oracle数据库管理效率；各种管理功能，都比较强大；  
    (4)Oracle官方有比较全面的监控工具，常用的第三方监控平台，如zabbix,cacti,lepus等都有对Oracle数据库的各项指标的完善监控；  
    (5)支持冷备份和热备份，可以用 exp/imp , expdp/impdp等进行逻辑备份和恢复，可以使用强大的RMAN工具进行专业的物理热备份和恢复；  
    (6)Oracle数据库的高可用架构，可以用第三方双机热备软件，结合Oracle单实例实现；可以使用Oracle Dataguard，实现master和standby的备份；可以使用 Oracle RAC集群实现实例级别的高可用和负载均衡，使用ASM实现存储级别的高可用；  
    (7)由于Oracle集群采用共享存储的方式，一般只能通过垂直硬件升级进行升级；  
    **3、适用场景：**  
    绝大多数OLTP场景，部分OLAP  
    **4、选择注意：**  
    Oracle从架构到运维，可以说是最难的数据库，学习和使用难度较高。

  

####  [Postgresql](https://so.csdn.net/so/search?q=Postgresql&spm=1001.2101.3001.7020)数据库

    \[[下载地址](https://www.postgresql.org/download/)\]  
    PostgreSQL是以加州大学伯克利分校计算机系开发的 POSTGRES，现在已经更名为PostgreSQL，版本 4.2为基础的对象关系型数据库管理系统（ORDBMS）。PostgreSQL支持大部分 SQL标准并且提供了许多其他现代特性：复杂查询、外键、触发器、视图、事务完整性、MVCC。同样，PostgreSQL 可以用许多方法扩展，比如， 通过增加新的数据类型、函数、操作符、聚集函数、索引。免费使用、修改、和分发 PostgreSQL，不管是私用、商用、还是学术研究使用。  
    PostgreSQL 是一个免费的对象-关系数据库服务器(数据库管理系统)，它在灵活的 BSD-风格许可证下发行。它提供了相对其他开放源代码数据库系统(比如 MySQL 和 Firebird)，和专有系统(比如 Oracle、Sybase、IBM 的 DB2 和 Microsoft SQL Server)之外的另一种选择。    
    **1、定位：**  
    开源、多平台、关系型数据库，功能最强大的开源数据库。  
    **2、特点：**  
    (1)支持事务，符合关系型数据库原理，符合ACID，支持多数SQL规范，以二维表方式组织数据；  
    (2)postgresql需要先准备好Python等环境，然后编译安装软件，初始化数据库，启动实例，整个部署过程相对比较清晰；  
    (3)postgresql数据库可以使用命令行方式进行管理，也可以通过pgadmin图形工具进行管理；各种管理功能，都比较强大；  
    (4) 可以再命令行中查看各种性能视图和状态视图；相对其他其他数据库，并没有太好的图形监控工具和平台；  
    (5)支持冷备份和热备份，可以用 COPY命令进行逻辑导出和导入；用pgdump和pgrestore进行物理备份和恢复；  
    (6)postgresql 官方支持 master-standby复制；也可以用Slony-I第三方组件进行数据库同步；  
    (7)postgresql可以通过修改源码实现的postgres-XC实现水平扩展；  
    **3、适用场景：**  
    绝大多数OLTP场景，部分OLAP  
    适合目前互联网需要的一些信息，比如地理位置信息处理；  
    以postgresql作为底层数据库的greenplum[数据仓库](https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93&spm=1001.2101.3001.7020)，是主流的MPP数据仓库；  
    基于postgresql的TimeScaleDB，是目前比较火的[时序数据库](https://so.csdn.net/so/search?q=%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93&spm=1001.2101.3001.7020)之一；  
    **4、选择注意：**  
    Postgresql的架构、使用难度、功能性介于Oracle数据库和MySQL数据库之间，但因其开源的推动，各方面也有不错的发展；  
    Postgresql目前还没有比较主流和好用的监控平台，这是postgresql数据库目前存在的一个不足。

####  Sybase数据库

    \[[下载地址](https://www.sap.com/products/sybase-ase.html)\]  
    美国Sybase公司研制的一种关系型数据库系统，是一种典型的UNIX或WindowsNT平台上客户机/服务器环境下的大型数据库系统。  
    Sybase提供了一套应用程序编程接口和库，可以与非Sybase数据源及服务器集成，允许在多个数据库之间复制数据，适于创建多层应用。系统具有完备的触发器、存储过程、规则以及完整性定义，支持优化查询，具有较好的数据安全性。  
    Sybase通常与SybaseSQLAnywhere用于客户机/服务器环境，前者作为服务器数据库，后者为客户机数据库，采用该公司研制的PowerBuilder为开发工具，在我国大中型系统中具有广泛的应用。  

  

####  DB2数据库

    \[[下载地址](https://www.ibm.com/analytics/cn/zh/technology/db2/)\]  
    DB2主要应用于大型应用系统，具有较好的可伸缩性，可支持从大型机到单用户环境，应用于所有常见的服务器操作系统平台下。  
    DB2提供了高层次的数据利用性、完整性、安全性、可恢复性，以及小规模到大规模应用程序的执行能力，具有与平台无关的基本功能和SQL命令。DB2采用了数据分级技术，能够使大型机数据很方便地下载到LAN数据库服务器，使得客户机/服务器用户和基于LAN的应用程序可以访问大型机数据，并使数据库本地化及远程连接透明化。  
    DB2以拥有一个非常完备的查询优化器而著称，其外部连接改善了查询性能，并支持多任务并行查询。 DB2具有很好的网络支持能力，每个子系统可以连接十几万个分布式用户，可同时激活上千个活动线程，对大型分布式应用系统尤为适用。  

  

#### Access数据库

    \[[官网下载地址](http://www.accessoft.com/download.html)\] \[[破解下载地址](http://msdn.itellyou.cn/)\]  
    Microsoft Office Access是由微软发布的关系数据库管理系统。它结合了 MicrosoftJet Database Engine 和 图形用户界面两项特点，是 Microsoft Office 的系统程序之一。  
    Microsoft Office Access是微软把数据库引擎的图形用户界面和软件开发工具结合在一起的一个数据库管理系统。它是微软OFFICE的一个成员, 在包括专业版和更高版本的office版本里面被单独出售。  
    MS ACCESS以它自己的格式将数据存储在基于Access Jet的数据库引擎里。它还可以直接导入或者链接数据(这些数据存储在其他应用程序和数据库)。  
    软件开发人员和数据架构师可以使用Microsoft Access开发应用软件,“高级用户”可以使用它来构建软件应用程序。和其他办公应用程序一样，ACCESS支持Visual Basic宏语言,它是一个面向对象的编程语言,可以引用各种对象，包括DAO(数据访问对象),ActiveX数据对象,以及许多其他的ActiveX组件。可视对象用于显示表和报表，他们的方法和属性是在VBA编程环境下，VBA代码模块可以声明和调用Windows操作系统函数。    
    (1)完善地管理各种数据库对象，具有强大的数据组织、用户管理、安全检查等功能。  
    (2)强大的数据处理功能  
    (2)强大的数据处理功能(3)可以方便地生成各种数据对象，利用存储的数据建立窗体和报表，可视性好  
    (4)作为Office套件的一部分，可以与Office集成，实现无缝连接  
    (5)能够利用Web检索和发布数据，实现与Internet的连接。 Access主要适用于中小型应用系统，或作为客户机/服务器系统中的客户端数据库。

  


### [非关系型数据库](https://so.csdn.net/so/search?q=%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&spm=1001.2101.3001.7020)

####  [Mongodb](https://so.csdn.net/so/search?q=Mongodb&spm=1001.2101.3001.7020)数据库

    \[[下载地址](https://www.mongodb.com/download-center)\]  
    MongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。  
    MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。  
![mongoDB](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243943.jpeg)  
    **1、定位：**  
    开源、多平台、文档型nosql数据库  
    非常主流的文档型nosql数据库，“最像关系型数据库”，定位于“灵活”的nosql数据库  
    **2、特点：**  
    (1)数据文件存储格式为BSON，模式自由，整体架构与关系型数据库有对应关系，具有较好的高可用性和伸缩性，有插件式存储引擎，新版本默认是writedtiger存储引擎；  
    (2)部署比较简答，下载软件，设置好配置文件即可启动服务；  
    (3)不支持SQL语句，使用与SQL对应的json方式管理数据库；  
    (4)有比较丰富的监控和性能命令，官方有比较完善的图形监控系统，但需要购买；  
    (5)支持冷备份和热备份，可以使用mongoexport/mongimport进行逻辑备份，也可以使用基于oplog的mongodump/mongorestore物理热备份；  
    (6)MongoDB master-slave主从复制：在master节点上加 --master参数，从数据库加 -slave和-source参数，就可以实现同步，这种目前不建议；ReplicaSets复制集，在mongodb 1.6之后，开发了新的 replicaset，着呢家了故障自动切换和自动修复成员节点，各个DB将数据一致，建议使用这种方式；可以测试读写分离和故障转移；  
    (7)mongodb海量数据水平拆分，将数据分别存储在sharding各个节点上，构建出分布式集群。Sharding架构由 底层多个mongodb Shared Server，config水平拆分配置库config server，前端路由 route process，三部分构成。Sharding集群底层可以是mongodb单实例，也可以高可用的replicaSet复制集。  
    **3、适用场景：**  
    网站后台数据库：mongodb非常适合实话实说插入、更新与查询，并可以实时复制和高伸缩性，适合更新迭代快、需求变更多、以对象为主的网站应用；  
    小文件系统：对于json文件，二进制数据，适合用mongodb进行存储和查询  
    日志分析系统：对于数据量大的日志文件，IM会话消息记录，适合用mongodb来保存和查询；  
    缓存系统：mongodb数据库也会使用大量的内存，合理的设计，也可以作为缓存系统使用；不过目前缓存系统使用更多的方案是 memcached和redis。  
    **4、选择注意：**  
    Mongodb不适合的场景：  
    高度事务性的系统：即传统的OLTP业务，mongodb，乃至其他nosql，对事务性支持都不太好；  
    传统的统计分析应用：即传统的OLAP业务，需要高度优化的查询方式，mongodb支持不好；  
    使用SQL语句比较方便的业务：mongodb是json类型的查询方式，虽然也灵活，但不如用SQL方便，如果业务和适合SQL，则就不太合适mongodb了。

  

####  Redis数据库

    \[[下载地址](https://redis.io/)\]  
    redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。  
    Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。存盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。  
![Redis](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243944.jpeg)  
    **1、定位：**  
    开源、Linux平台、key-value键值型Nosql数据库  
    简单稳定，非常主流的、全数据in-momory、定位于“快”的键值型nosql数据库  
    **2、特点：**  
    (1)命令执行速度非常看，读写性能可达10万/秒；数据结构是key-value类似字典的功能，可以键过期-缓存，发布订阅-消息系统，简单的事物功能；  
    (2)用下载软件介质，编译安装的方式，可以很快完成数据库部署；服务启动redis-server，可以用默认配置、运行参数配置、配置文件启动，三种方式；redis在Linux平台支撑较好，官方没有Windows版本，微软维护了一个分支；  
    (3)用redis-cli客户端连接，一般用简单的 set ,get,del 进行数据管理； 在单实例redis的基础上，进行可以数据持久化，主从复制，高可用和分布式等功能；  
    (4)在命令行界面有一些常用的命令显示状态和性能，在图形界面方面，有开源监控工具来监控和记录数据库的状态，比如cachecloud；  
    (5)直接备份成物理问价的RDB持久化，基于AOF日志的实时AOF持久化  
    (6)官方的 redis sentinel哨兵高可用集群  
    (7)官方基于分配槽的 redis cluster分布式集群  
    **3、适用场景：**  
    缓存  
    基础消息队列系统  
    排行榜系统  
    计数器使用  
    社交网站的点赞、粉丝、下拉刷新等应用；  
    **4、选择注意：**  
    Redis的使用场景，是redis适合的解决的问题，也有不适合解决的问题。  
    从数据规模角度讲，小数据规模使用redis比较合适，大数据规模使用redis不合适；(大数据规模，在一定程度上，可以用SSDB替代redis使用)；  
    从数据冷热角度看，热数据适合放在redis中，冷数据不适合放在redis中。

  

####  [Hbase](https://so.csdn.net/so/search?q=Hbase&spm=1001.2101.3001.7020)数据库

    \[[下载地址](https://hbase.apache.org/downloads.html)\]  
    HBase是一个分布式的、面向列的开源数据库，该技术来源于 Fay Chang 所撰写的Google论文“Bigtable：一个结构化数据的分布式存储系统”。就像Bigtable利用了Google文件系统（File System）所提供的分布式数据存储一样，HBase在Hadoop之上提供了类似于Bigtable的能力。  
    HBase是Apache的Hadoop项目的子项目。HBase不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据库。另一个不同的是HBase基于列的而不是基于行的模式。  
![HBASE](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243945.png)  
    **1、定位：**  
    开源、Linux平台、列存储nosql数据库  
    可用于海量数据存储、与Hadoop生态圈结合、定位于“大”的列存储nosql数据库  
    **2、特点：**  
    (1)命令执行速度非常看，读写性能可达10万/秒；数据结构是key-value类似字典的功能，可以键过期-缓存，发布订阅-消息系统，简单的事物功能；  
    (2)相对其他数据库，hbase的部署比较复杂，依赖Hadoop，zookeeper等组件，Hbase集群包括一个mater节点，多个regionServer，zookeeper管理所有regionServer，需要依次部署Hadoop、zookeeper之后，再部署HBASE集群；  
    (3)用redis-cli客户端连接，一般用简单的 set ,get,del 进行数据管理； 在单实例redis的基础上，进行可以数据持久化，主从复制，高可用和分布式等功能；  
    (4)在命令行界面有一些常用的命令显示状态和性能，在图形界面方面，有开源监控工具来监控和记录数据库的状态，比如cachecloud；  
    (5)Hbase一般用作海量数据的仓库，本身通过多层副本来保证数据安全性，不用进行专门的备份  
    (6)HBASE集群基于Hadoop，需要依次部署Hadoop单机模式、集群模式、HA模式，通过Hadoop HA实现高可用；  
    (7)HBASE以集群形式，依次是单机模式，伪分布模式，完全分布模式，底层基于HDFS，zookeeper可以很好地进行扩展；  
    **3、适用场景：**  
    两大用途：  
    用于简单数据写入和海量、结构简单数据查询的业务场景；  
    用于成为其他数据库备份和下沉的数据库；  
    **4、选择注意：**  
    Hbase不适合的场景：对数据分析需求高，需要能够用sql或者简单的MapReduce实现分析需求的业务场景，不适合用Hbase；  
    单表数据量，不超过千万时，使用Hbase，体现不出Hbase的优势，而且会比较慢，不适合用Hbase。

  

####  Memcaced数据库

    \[[下载地址](http://memcached.org/downloads)\]  
    Memcaced是一个开源的、高性能的、具有分布式内存对象的缓存系统。通过它可以减轻数据库负载，加速动态的web应用，最初版本由LiveJoumal 的Brad Fitzpatrick在2003年开发完成。目前全球有非常多的用户都在使用它来架构主机的大负载网站或提升主机的高访问网站的响应速度。注意：Memcache 是这个项目的名称，而Memcached是服务端的主程序文件名。  
    缓存一般用来保存一些进程被存取的对象或数据，通过缓存来存取对象或数据要比在磁盘上存取块很多，前者是内存，后者是磁盘、Memcached是一种纯内存缓存系统，把经常存取的对象或数据缓存在memcached的内存中，这些被缓存的数据被程序通过API的方式被读取，memcached里面的数据就像一张巨大的hash表，数据以key-value对的方式存在。Memcached通过缓存经常被存取的对象或数据，从而减轻频繁读取数据库的压力，提高网站的响应速度，构建出快速更快的可扩展的Web应用。  

# 标准化和知识产权基础知识

![image-20240322093634778](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243946.png)

## 标准化基础知识（了解）

![image-20240417185939091](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243947.png)

![image-20240417190058862](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243948.png)

![image-20240417190254483](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243949.png)

![image-20240417190343399](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243950.png)

![image-20240417190436745](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243951.png)



## 知识产权概念

### 知识产权

知识产权（也称为智慧财产权）是指人们基于自己的智力活动创造的成果和经营管理活动中的经验、知识而依法享有的权利

  **知识产权可分为工业产权和著作权两类：**

1. **工业产权**

   **包括专利、实用新型、工业品外观设计、商标、服务标记、产商名称、产地标记或原产地名称**、制止不正当竞争等内容。商业秘密、微生物技术和遗传基因技术也属于工业产权保护的对象。一些国家可以通过申请专利对计算机软件进行专利保护

2. **著作权**

   **也称为版权。是指作者对其创作的作品享有的人身权和财产权**。人身权**包括发表权、署名权、修改权和保护作品完整权**等；财产权包括作品的使用权和获得报酬权，即以复制、表演、播放、展览、发行、摄制电影、电视、录像或者改编、翻译、注释、编辑等方式使用作品的权力，以及许可他人以上述方式使用作品并由此获得报酬的权利

### 知识产权特点

1. **无形性**

   **知识产权是一种无形财产权**。指的是治理创作性成果（也称知识产品），是一种没有形体的精神财富

2. **双重性**

   某些**知识产权具有财产权和人身权双重性**，例如著作权，其财产权属性主要体现在所有人享有的独占权以及许可他人使用而获得报酬的权利，所有人可以通过独自实施获得收益，也可以通过有偿许可他人实施获得收益，还可以像有形财产那样进行买卖或抵押：其人身权属性主要是指署名权等。有的知识产权具有单一的属性，例如，发现权只具有名誉权属性，而没有财产权属性：商业秘密只具有财产权属性，而没有人身权属性：专利权、商标权主要体现为财产权。

3. **确认性**

   无形的智力创作性成果不像有形财产那样直观可见，因此，**智力创作性成果的财产权需要依法审查确认**，以得到法律保护。在我国，发明人所完成的发明，其实用新型或者外观设计已经具有价值和使用价值，但是，**其完成人尚不能自动获得专利权**，完成人必须依照专利法的有关规定向国家专利局提出专利申请，专利局依照法定程序进行审查，申请符合专利法规定条件的，由专利局做出授予专利权的决定，颁发专利证书，只有当专利局发布授权公告后，其完成人才享有该项知识产权。

4. **独占性**

   由于智力成果具有可以同时被多个主体所使用的特点，因此，法律授予知识
   产权一种专有权，具有独占性。**未经权利人许可，任何单位或个人不得使用**，否则就构成侵权应承担相应的法律责任。

5. **地域性**

   知识产权具有严格的地域性特点，即各国主管机关依照本国法律授予的**知识产权，只能在其本国领域内受法律保护**，例如中国专利局授予的专利权或中国商标局核准的商标专用权，只能在中国领域内受保护，其他国家则不给予保护。外国人在我国领域外使用中国专利局授权的发明专利，不侵犯我国专利权。所以，我国公民、法人完成的发明创造**要想在外国受保护，必须在外国申请专利**。**著作权**虽然**自动产生，但它受地域限制，我国法律对外国人的作品并不都给予保护**，只保护共同参加国际条约国家的公民作品。同样，公约的其他成员国也按照公约规定，对我国公民和法人的作品给予保护。还有按照两国的双边协定，相互给予对方国民的作品保护。

6. **时效性（重点）**

   知识产权具有法定的保护期限，一旦保护期限届满，权力将自动终止，成为设为公众可以自由使用的知识。我国**发明专利的保护期为20年，实用新型专利权和外观设计专利权的期限为10年，均自专利申请日起计算**。我国公民的**作品发表权的保护期为作者终身及其死亡后50年**。**商标权的保护期限自核准注册之日起10年内有效**，但可以根据所有人的需要无限地续展权力期限，**在期限届满前6个月内申请续展注册，每次注册有效期为10年，次数不限**。如果预期不办理续展，则商标权也将终止

## 计算机软件著作权

### 著作权的主体

计算机软件著作权的主体**指享有著作权的人**。**包括公民、法人和其他组织**

![image-20240421144436697](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243952.png)

### 著作权的客体（重点）

指著作权法保护的计算机软件著作权的范围（受保护的对象）。根据《中华人民共和国著作权法》第三条和《中华人民共和国计算机软件保护条例》第二条的规定，**著作权法保护的计算机软件是指计算机程序及其相关文档**。著作权法规定**对计算机软件的保护是指计算机软件的著作权人或者受让者依法享有著作权的各种权力**

1. **计算机程序**。根据《中华人民共和国计算机软件保护条例》第三条第一款的规定，计算机程序是**指为了得到某种结果而可以由计算机等具有信息处理能力的装置执行的代码化指令序列，或者可被自动转换成代码化指令序列的符号化语句序列**。计算机程序**包括源程序和目标程序**，同一程序的源程序文本和目标程序文本视为同一软件作品。
2. **计算机软件的文档**。根据《中华人民共和国计算机软件保护条例》第三条第二款的规定，计算机程序的文档是**指用自然语言或者形式化语言所编写的文字资料和图表**，**用来描述程序**的内容、组成、设计、功能规格、开发情况、测试结果及使用方法等。文档**一般以程序设计说明书、流程图和用户手册等表现。**

> **不包括开发软件所用的操作方法**

### 著作权法保护的条件（重点）

依法受到保护的计算机软件作品必须符合下列条件：

1. **独立创作。受保护的软件必须有开发者独立创作，任何肤质或抄袭他人开发的软件不能获得著作权**。程序的功能设计往往被认为是程序的思想概念，根据**著作权法不保护思想观念的原则**，**任何人可以设计具有类似功能的另一件软件作品**。但是如果用了他人软件作品的逻辑步骤的组合方式，则对他人软件构成侵权。

2. **可被感知**。受著作权法保护的作品应当是作者创作思想在固定载体上的一种实际表达。如果作者的创作思想未表达出来，不可以被感知，就不能得到著作权法的保护。因此，《中华人民共和国计算机软件保护条例》规定，**受保护的软件必须固定在某种有形物体上，例如固定在存储器、磁盘和磁带等设备上，也可以是其他的有形物，如纸张等。**

3. **逻辑合理。逻辑判断功能是计算机系统的基本功能**。因此，受著作权法保护的计算机软件作品必须具备合理的逻辑思想，并以正确的逻辑步骤表现出来，才能达到软件的设计功能。

   《计算机软件保护条例》第六条规定，除计算机软件的程序和文档外，**著作权法不保护计算机软件开发所用的思想、概念、发现、原理、算法、处理过程和运算方法**。也就是说，**利用已有的上述内容开发软件，并不构成侵权**。因为开发软件时采用的思想、概念等均属于计算机软件基本理论的范围，是设计开发软件不可或缺的理论依据，属于社会共有领域，不能被个人专有。

### 著作权的权利（重点）

《著作权法》规定，软件作品享有两种权力：一类是软件著作权的**人身权（精神权力）**；另一类是软件著作权的**财产权（经济权利）**

1. 计算机软件的著作**人身权**
   1. **发表权**。指决定软件作品是否**公之于众的权力**，即软件作品完成后，以复制、展示、发行或者翻译等方式使软件作品在一定数量不特定人的范围内公开。发表权的**具体内容包括软件作品的发表的时间、发表的形式以及发表的地点等**
   2. **开发者身份权（也成为著名权**）。**指**作者为表面身份在软件作品中**著自己名字的权力**。开发者的身份权**不随软件开发者的消亡而丧失，且时间无限**
2. 计算机软件的著作**财产权**
   1. **使用权**。使用权即在不损害社会公共利益的前提下，以复制、修改、发行、翻译、注释等方式合作软件的权利
   2. **复制权**。复制权即将软件作品制作一份或多份的行为。复制权就**是版权所有人决定实施或不实施上述复制行为**或者禁止他人复制其受保护作品的权利
   3. **修改权**。修改权即对软件进行增补、删节，或者改变指令、语句顺序等以提高、完善原软件作品的做法。修改权即**指作者享有的修改或者授权他人修改软件作品的权利**
   4. **发行权**。发行是指为满足公众的合理需求，通过出售、出租等方式向公众提供一定数量的作品复制件。**发行权即以出售或赠与方式向公众提供软件的原件或者复制件的权利。**
   5. **翻译权**。翻译是指以不同于原软件作品的一种程序语言转换该作品原使用的程序语言，而重现软件作品内容的创作。简单地说，**翻译权是指将原软件从一种程序语言转换成另一种程序语言的权利。**
   6.  **注释权**。软件作品的注释是指**对软件作品中的程序语句进行解释**，以使更好地理解软件作品。注释权是指著作权人对自己的作品享有进行注释的权利
   7. **信息网络传播权**。信息网络传播权是**以有线或者无线信息网络方式向公众提供软件作品**，使公众可在其个人选定的时间和地点获得软件作品的权利
   8. **出租权**。出租权即**有偿许可他人临时使用计算机软件的复制件的权利**，但是，计算机软件不是出租的主要标的除外
   9. **使用许可权和获得报酬权**。使用许可权和获得报酬权**即许可他人以上述方式使用软件作品的权利**（许可他人行使软件著作权中的财产权）和依照约定或者有关法律规定获得报酬的权利。
   10. **转让权**。转让权**即向他人转让软件的使用权和使用许可权的权利**。软件著作权人可以全部或者部分转让软件著作权中的财产权
3. **软件合法持有人的权力**
   1. **根据**使用的**需要把软件装入**计算机等能**存储信息的装置内**。
   2. 根据需要进行**必要的复制**
   3. 为了**防止复制品损坏而制作备份复制品**。这些复制品不得通过任何方式提供给他人使用，并在所有人丧失该合法复制品所有权时，负责将备份复制品销毁
   4. 为了把该软件用于实际的计算机应用环境或者改进其功能性能而进行必要的修改。但是，除合同约定外，未经该软件著作权人许可，不得向任何第三方提供修改后的软件。

### 软件著作权的行使

![image-20240421162308793](https://picture-bed-1352320518.cos.ap-guangzhou.myqcloud.com/assets/20250411111243953.png)

### 软件著作权的保护期（重点）

《著作权法》和《计算机软件保护条例》规定，计算机软件**著作权的权力自软件开发完成之日起生效，保护期为50年**。保护期**满，则除开发者身份权以外，其他权力终止**。一旦计算机软件著作权**超出保护期，软件就进入共有领域**。计算机软件著作权人的单位终止和计算机软件著作权人的公民死亡均无合法继承人时，除开发者身份权以外，该软件的其他权力进入共有领域。进入后将成为社会公共财富，**公众可无偿使用**

> **注意：前面的是著名权，而不是著作权，著名权是终生的**

### 软件著作权的归属（重点）

我国著作权法对**著作权的归属采取了“创作主义”原则，明确规定著作权属于作者，除非另有规定**。《中华人民共和国计算机软件保护条例》第九条规定，“软件著作权属于软件开发者，本条例另有规定的情况除外”。这是我国计算机软件著作权归属的基本原则。
计算机软件开发者是计算机软件著作权的原始主体，也是享有权利最完整的主体。软件作品是开发者从事智力创作活动所取得的智力成果，是脑力劳动的结品。其开发创作行为使开发者直接取得该计算机软件的著作权。因此，《中华人民共和国计算机软件保护条例》第九条明确规定“软件著作权属于软件开发者”，即以软件开发的事实来确定著作权的归属，**谁完成了计算机软件的创作开发工作，其软件的著作权就归谁享有。**

#### 职务开发软件著作权的归属（重点）

> **非职务软件著作权(著作权是自己）的三个条件**
>
> 1. 不是执行本职工作的结果
> 2. 与本职工作没有直接的关系
> 3. 没有使用受雇单位的任何物质技术条件

**职务软件作品**是**指公民在单位任职期间为执行本单位工作任务所开发的计算机软件作品**。《中华人民共和国计算机软件保护条例》第十三条作了明确的规定，即**公民在单位任职期间所开发的软件，如果是执行本职工作的结果，即针对本职工作中明确指定的开发目标所开发的：或者是从事本职工作活动所预见的结果或者自然的结果，则该软件的著作权属于该单位**：或者主要使用了单位的专用设备、未公开的专门信息等物资技术条件所开发并由法人或者其他组织承担责任的软件。根据《中华人民共和国计算机软件保护条例》规定，可以得出这样的结论：当公民作为某单位的员时，如其开发的软件属于执行本职工作的结果，该软件著作权应当归单位享有。**若开发的软件不是执行本职工作的结果，其著作权就不属于单位享**有。**如果该员主要使用了单位的设备**，按照《中华人民共和国计算机软件保护条例》第十三条第三款的规定，**其著作权不能属于该雇员个人享有。**

​    对于公民在非职务期间创作的计算机程序，其著作权属于某项软件作品的开发单位，还是事直接创作开发软件作品的个人，可按照《中华人民共和国计算机软件保护条例》第十三条规定的三条标准确定

1. **所开发的软件作品不是执行其本职工作的结果**

   任何受于一个单位的人员，都会被安排在一定的工作岗位和分派相应的工作任务。完成分派的工作任务就是他的本职工作，本职工作的直接成果也就是其工作任务的不断完成。当然，具体工作成果又会产生许多效益、产生范围更广的结果。但是，该条标准指的是员本职工作最直接的成果。**若员开发创作的软件不是执行本职工作的结果，则构成非职务计算机软件著作权的条件之一**

2. **开发的软件作品与开发者在单位中从事的工作内容无直接联系**

   如果该雇员在单位担任软件开发工作，引起争议的软件作品不能与其本职工作中明确指定的开发日标有关，软件作品的内容也不能与其本职工作所开发的软件的功能、逻辑思维和重要数据有关。**若员所开发的软件作品与其本职工作没有直接的关系，则构成非职务计算机软件著作权的第二个条件。**

3. **开发的软件作品未使用单位的物质技术条件。**

   开发创作软件作品所使用的物质技术条件，即开发软件作品所必须的设备、数据、资金和其他软件开发环境，不属于雇员所在的单位所有。**若没有使用受雇单位的任何物质技术条件，则构成非职务软件著作权的第三个条件。**

   ​	雇员进行本职工作以外的软件开发创作，必须同时符合上述三个条件，才能算是非职务软件作品，员个人才享有软件著作权。**常有软件开发符合前两个条件，但使用了单位的技术**情报资料、计算机**设备等物质技术条件的情况**。处理此种情况**较好的方法是对该软件著作权的归属应当由单位和员双方协商确定，如对于公民在非职务期间利用单位物质条件创作的与单位业务范围无关的计算机程序，其著作权属于创作程序的作者，但作者许可第三人使用软件时，应当支付单位合理的物质条件使用费，如计算机机时费等。若通过协商不能解决，按上述三条标准作出界定。**

#### 合作开发软件著作权的归属

   合作开发软件是**指两个或两个以上公民、法人或其他组织订立协议，共同参加某项计算机软件的开发并分享软件著作权的形式**。《中华人民共和国计算机软件保护条例》第十条规定：由两个以上的自然人、法人或者其他组织合作开发的软件，其**著作权的归属由合作开发者签订书面合同约定**。无书面合同或者合同未作明确约定，合作开发的**软件可以分割使用的，开发者对各白开发的部分可以单独享有著作权：但是，行使著作权时，不得扩展到合作开发的软件整体的著作权**。合作开发的软件**不能分割使用的，其著作权由合作开发者共同享有，通过协商致行使**：**如不能协商一致，又无正当理由，任何一方不得阻止他方行使除转让权以外的其他权利，但是所得收益应合理分配给所有合作开发者**。”根据此规定，对合作开发软件著作权的归属应掌握以下4点：
    （1）由两个以上的单位、公民共同开发完成的软件属于合作开发的软件。对于合作开发的软件，其**著作权的归属一般是由各合作开发者共同享有**。但**如果有软件著作权的协议，则按照协议确定软件著作权的归属**
    （2）由于合作开发软件著作权是由两个以上单位或者个人共同享有，因而为了避免在软件著作权的行使中产生纠纷，规定“**合作开发的软件，其著作权的归属由合作开发者签订书面合司约定”**
    （3）对于合作开发的软件著作权按以下规定执行：“无书面合同或者合同未作明确约定合作开发的**软件可以分割使用**的，开发者对各自开发的部分可以单独享有著作权：但是，行使作权时，不得扩展到合作开发的软件整体的著作权。合作开发的软件**不能分割使用**的，其著作权由合作开发者共同享有，通过协商一致行使；如不能协商一致，又无正当理由，任何一方不得阻止他方行使除转让权以外的其他权利，但是所得收益应合理分配给所有合作开发者。

​	（4）合作开发者对于软件著作权中的**转让权不得单独行使**。因为转让权的行使将涉及软件著作权权利主体的改变，所以软件的合作开发者在行使转让权时，**必须与各合作开发者协商主征得同意**的情况下放能使该项专有权利

#### 委托开发的软件著作权的归属

委托开发的软件作品属于著作权法规定的委托软件作品。委托开发软件作品著作权关系的建立，一般由委托方与受委托方订立合同而成立。委托开发软件作品关系中，**委托方的责任主要是提供资金、设备等物质条件，并不直接参与开发软件作品的创作开发活动。受托方的主要责任是根据委托合同规定的目标开发出符合条件的软件**。关于委托开发软件著作权的归属，《中华人民共和国计算机软件保护条例》第十一条规定：“**接受他人委托开发的软件，其著作权的归属由委托者与受委托者签订书面合同约定**：**无书面合同或者合同未作明确约定的，其著作权由受托人享有**。”根据该条的规定，委托开发的软件著作权的归属按以下标准确定：
（1）委托开发软件作品须根据委托方的要求，由委托方与受托方以合同确定的权利和义务的关系而进行开发。因此，**软件作品著作权归属应当作为合同的重要条款予以明确约定**。对于当事人已经在合同中约定软件著作权归属关系的，如事后发生纠纷，软件著作权的归属仍应当据委托开发软件的合同来确定。

 （2）若在委托开发软件活动中，委托者与受委托者**没有签订书面协议，或者**在协议中**未**对软件著作权归属**作出明确的约定，则软件著作权属于受委托者，即属于实际完成软件的开发者**

#### 接受任务开发的软件著作权的归属

​     根据社会经济发展的需要，对于一些涉及国家基础项目或者重点设施的计算机软件，往往采取由政府有关部门或上级单位下达任务方式，完成软件的开发工作。对于下达任务开发的软件，其著作权的归属关系，《中华人民共和国计算机软件保护条例》第十二条作出了明确的规定：“**由国家机关下达任务开发的软件，著作权的归属与行使由项目任务书或者合同规定；项目任务书或者合同中未作明确规定，软件著作权由接受任务的法人或者其他组织享有**。”根据该规定，国家或上级下达任务开发的软件著作权归属应按以下两条标准确定：
​    （1）下达任务开发的软件著作权的归属关系，首先应以项目任务书的规定或者双方的合同约定为准。
​    （2）下达任务的项目任务书或者双方订立的合同中未对软件著作权归属作出明确的规定或者约定的，其软件著作权属于接受并实际完成开发软件任务的单位

#### 著作权主体变更后著作权的归属

​    计算机软件著作权的主体，因一定的法律事实而发生变更。如作为软件著作权人的公民的死亡，单位的变更，软件著作权的转让以及人民法院对软件著作权的归属作出裁判等。软件著作权主体的变更必然引起软件作权归属的变化。对此，《中华人民共和国计算机软件保护条例》也作了一些规定。因计算机软件主体变更引起的权属变化有以下几种：
​    （1）**公民继承的软件权利归属**
​    《中华人民共和国计算机软件保护条例》第十五条规定：“在软件著作权的保护期内，软件著作权的继承者可根据《中华人民共和国继承法》的有关规定，**继承**本条例第八条项规定的**除署名权以外的其他权利**。”按照该条的规定，软件著作权的合法继承人**依法享有继承**被继承人享有的**软件著作权的使用权、使用许可权和获得报酬权等权利**。继承权的取得、继承顺序等均按照继承法的规定进行。
​    （2）**单位变更后软件权利归属**
​    《中华人民共和国计算机软件保护条例》第十五条规定：“软件著作权属于法人或其他组织的，**法人或其他组织变更、终止后，其著作权在本条例规定的保护期内由承受其权利义务的法人或其他组织享有**。”按照该条的规定，作为软件著作权人的单位发生变更（如单位的合并、破产等），**而其享有的软件著作权仍处在法定的保护期限内，可以由合法的权利承受单位享有原始著作权人所享有的各项权利**。依法承受软件著作权的单位，成为该软件的后续著作权人，可在法定的条件下行使所承受的各项专有权利。一般认为，“各项权利”包括署名权等著作人身权在内的全部权利
​    （3）**权利转让后软件著作权归属**
​    《中华人民共和国计算机软件保护条例》第二十条规定：“转让软件著作权的，当事人**应当订立书面合同**。”计算机软件著作财产权按照该条的规定发生转让后，必然引起著作权主体的变化，产生新的软件著作权归属关系。软件权利的转让应当根据我国有关法规以签订、执行

（4）**司法判决、裁定引起的软件著作权归属问题**
计算机软件著作权是公民、法人和其他组织享有的一项重要的民事权利。因而在民事权利行使、流转的过程中，难免发生涉及计算机软件著作权作为标的物的民事、经济关系，也难免发生争议和纠纷。争议和纠纷发生后由人民法院的民事判决、裁定而产生软件著作权主体的变更，引起软件著作权归属问题。因司法裁判引起软件著作权的归属问题主要有**4类**：

1. 第一类是由**人民法院**对著作权归属纠纷中权利的最终归属**作出司法裁判，从而变更了计算机软件著作权原有归属**：
2. 第二类是计算机软件的著作权人为民事法律关系中的**债务人**（债务形成的原因可能多种多样，**如合同关系或者损害赔偿关系等**），**人民法院将其软件著作财产权判归债权人享有抵债：**
3. 第三类是人民法院作出**民事判决判令**软件著作权人**履行民事给付义务**，在判决生效后执行程序中，**其无其他财产可供执行，将软件著作财产权执行给对方折抵债务：**
4. 第四类是根据破产法的规定，**软件著作权人被破产还债，软件著作财产权作为法律规定的破产财产构成的“其他财产权利”，作为破产财产由人民法院判决分配**

（5）**保护期限届满权利失**
    软件著作权的法定**保护期限可以确定计算机软件的主体能否依法变更**。如果软件著作权已过保护期，该软件进入公有领域，便丧失了专有权，也就没有必要改变权利主体了。根据《中华人民共和国计算机软件保护条例》的规定，**计算机软件著作权主体变更必须在该软件著作权的保护期限内进行，转让活动的发生不改变该软件著作权的保护期**。这也就是说，**转让活动也不能延长该软件著作权的保护期限**

### 计算机软件著作权侵权的鉴别

侵犯计算机软件著作权的违法行为的鉴别，主要依靠保护知识产权的相关法律来判断。违反《中华人民共和国著作权法》《中华人民共和国计算机软件保护条例》等法律禁止的行为，便是侵犯计算机著作权的违法行为，这是鉴别违法行为的本质原则。对于法律规定不禁止，也不违反相关法律基本原则的行为，不认为是违法行为。在法律无明文具体条款规定的情况下，违背《中华人民共和国著作权法》和《中华人民共和国计算机软件保护条例》等法律的基本原则，以及社会主义公共生活准则和社会善良风俗的行为，也应该视为违法行为。**在一般情况下损害他人著作财产权或人身权的行为，总是违法行为。**

#### 计算机软件著作权侵权行为

​    根据《中华人民共和国计算机软件保护条例》第二十三条的规定：“凡是行为人主观上具有故意或者过失对著作权法和计算机软件保护条例保护的计算机软件人身权和财产权实施侵害行为的，都构成计算机软件的侵权行为。”该条规定的侵犯计算机软件著作权的情况，是认定软件著作权侵权行为的法律依据。计算机软件侵权行为主要有以下几种
​    **（1）未经软件著作权人的同意而发表或者登记其软件作品**。软件著作人享有对软件作品公开发表权，未经允许著作权人以外的任何其他人都无权擅自发表特定的软件作品。如果实施这种行为，就构成**侵犯著作权人的发表权**

**（2）将他人开发的软件当作自己的作品发表或者登记**。此种行为主要**侵犯了软件著作权的开发者身份权和署名权**。侵权行为人欺世盗名，窃软件开发者的劳动成果，将他人开发的软件作品假冒为自己的作品而署名发表。只要行为人实施了这种行为，不管其发表该作品是否经过软件著作人的同意，都构成侵权。

​    **（3）未经合作者的同意将与他人合作开发的软件当作自己独立完成的作品发表或者登记**。此种侵权行为发生在软件作品的合作开发者之间。作为合作开发的软件，软件作品的开发者身份为全体开发者，软件作品的发表权也应由全体开发者共同行使。如果未经其他开发者同意，又将合作开发的软件当作自己的独创作品发表，即构成本条规定的侵权行为。

​    **（4）在他人开发的软件上署名或者更改他人开发的软件上的署名**。这种行为是指在他人开发的软件作品上添加自己的署名，或者替代软件开发者署名以及将软件作品上开发者的署名进行更改的行为。这种行为**侵犯了软件著作人的开发者身份权及署名权**。此种行为**与第二条规定行为的区别**主要**是对已发表的软件作品实施的行为**

​    **（5）未经软件著作权人或者其合法受让者的许可，修改、翻译其软件作品**。此种行为是**侵犯了著作权人或其合法受让者的使用权中的修改权、翻译权**。对不同版本计算机软件，新版本住往是旧版本的提高和改善。这种提高和改善实质上是对原软件作品的修改、演绎。此种行为应征得软件作品原版本著作权人的同意，否则构成侵权。如果征得软件作品著作人的同意，因修改和改善新增加的部分，创作者应享有著作权

​    **（6）未经软件著作权人或其合法受让者的许可，复制或部分复制其软件作品**。此种行为**侵犯了著作权人或其合法受让者的使用权中的复制权**。计算机软件的复制权是计算机软件最重要的著作财产权，也是通常计算机软件侵权行为的对象。这是由于软件载体价格相对低廉，复制软件简单易行效率极高，而销售非法复制的软件即可获得高额利润。因此，**复制是常见的侵权行为，是防止和打击的主要对象**。当软件著作权经当事人的约定**合法转让给转让者以后，软件开发者未经允许不得复制该软件，否则也构成本条规定的侵权行为。**

​    **（7）未经软件著作权人及其合法受让者同意，向公众发行、出租其软件的复制品**。此种行为**侵犯**了著作权人或其合法受让者的**发行权与出租权。**

​    **（8）未经软件著作权人或其合法受让者同意，向任何第三方办理软件权利许可或转让事宜**。这种行为**侵犯**了软件著作权人或其合法受让者的使用**许可权和转让权。**

​    **（9）未经软件著作权人及其合法受让者同意，通过信息网络传播著作权人的软件**。这种行为**侵犯**了软件著作权人或其合法受让者的**信息网络传播权**。

​     **（10）侵犯计算机软件著作权存在着共同侵权行为**。**二人以上共同实施**《中华人民共和国计算机软件保护条例》第二十三条和二十四条规定的**侵权行为，构成共同侵权行为**。对行为人并没有实施《中华人民共和国计算机软件保护条例》第二十三和二十四条规定的行为，**但实施了向侵权行为人进行侵权活动提供设备、场所或解密软件，或者为侵权复制品提供仓储、运输、条件等行为，构成共同侵权应当在行为人之间具有共同故意或过失**。其构成的要件有两个：

1. **行为人的过错是共同的，而不论行为人的行为在整个侵权行为过程中所起的作用如何：**
2. **行为人主观上要有故意或过失的过错**。如果这个要件具备，各个行为人实施的侵权行为虽然各不相同，也同样构成共同侵权。**两个要件如果缺乏一个，不构成共同的侵权，或者是不构成任何侵权。**

#### 不构成计算机软件侵权的合理使用行为

​    《中华人民共和国计算机软件保护条例》第八条第四项和第十六条规定，**获得使用权或使用许可权（视合同条款）后，可以对软件进行复制而无需通知著作权人，亦不构成侵权**。对于合法**持有软件复制品的单位、公民在不经著作权人的同意的情况下，亦享有复制与修改权**。合法持有软件复制品的单位、公民，在不经软件著作权人同意的情况下，**可以**根据自己使用的需要**将软件装入计算机**，为了存档也**可以制作备份复制品**，为了把软件用于实际的计算机环境或者改进其功能时**也可以进行必要的修改，但是备份制品和修改后的文本不能以任何方式提供给他人，超过以上权利，**即视为侵权行为**。区分合理使用与非合理使用的判别标准一般有：

（1）软件作品是否合法取得。这是合理使用的基础
（2）使用目的是非商业营利性，**如果使用的目的是为商业性营利，就不属合理使用的范围**

（3）合理使用一般为少量的使用，所谓**少量的界限根据其使用的目的以行业惯例和人们的般常识综合确定**。超过通常被认为的少量界限，即可被认为不属于合理使用
    《中华人民共和国计算机软件保护条例》第十七条规定：“为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件的方式使用软件的，可以不经软件著作权人许可，不向其支付报酬。

#### 计算机著作权软件侵权的识别

​    计算机软件明显区别于其他著作权法保护的客体，它具有以下特点
​     **（1）技术性**。计算机软件的技术性是指其创作开发的高技术性。具有一定规模的软件的创作开发，**一般开发难度大**、周期长、投资高，需要良好组织，严密管理，且各方面人员配合协作，借助现代化高技术和高科技工具生产创作。
​    **（2）依赖性**。计算机程序的依赖性是指人们对其的感知依赖于计算机的特性。著作权保护的其他作品一般都可以依赖人的感觉器官所直接感知。但计算机程序则不能被人们所直接感知，它的内容只能依赖计算机等专用设备才能被充分表现出来，才能被人们所感知。
​    **（3）多样性**。计算机程序的多样性是指计算机程序表达的多样性。计算机程序的表达较著作权法保护的其他对象特殊，其既能以源代码表达，还可以以日标代码和微码等表达，表达形式多样。计算机程序表达的存储媒体也多种多样，同一种程序分别可以被存储在纸张、磁盘、磁带、光盘和集成电路上等。计算机程序的载体大多数精巧灵便。此外，计算机程序的内容与表达难以严格区别界定
​    **（4）运行性**。计算机程序的运行性是指计算机程序功能的运行性。计算机程序不同于一般的文字作品，它主要的功能在于使用。也就是说，计算机程序的功能只能通过对程序的使用、运行才能充分体现出来。计算机程序采用数字化形式存储、转换，复制品与原作品一般无明显区别

​	根据计算机软件的特点，对计算机软件侵权行为的识别可以**将发生争议的某一计算机程序与比照物（权利明确的正版计算机程序）进行对比和鉴别，从两个软件的相似性或完全相同来判断，做出侵权认定**。软件作品常常表现为计算机程序的不唯一性，即**两个运行结果相同的计算机程序**，或者**两个计算机软件的源代码程序不相似或不完全相似**，前者**不一定构成侵权**，而**后者不一定不构成侵权。**

### 软件著作权侵权的法律责任（了解）

#### 民事责任

​      犯计算机著作权以及有关权益的民事责任是指公民、法人或其他组织因侵犯著作权发生的后果依法应承担的法律责任。当**侵权人侵害他人的著作财产权或著作人身权，造成权利人财产上的或非财产的损失，侵权人不履行赔偿义务，法律即强制侵权人承担赔偿损失的民事责任**。《中华人民共和国计算机软件保护条例》第二十三条规定了侵犯计算机著作权的民事责任即侵犯著作权或者与著作权有关的权利的，**侵权人应当按照权利人的实际损失给予赔偿：实际损失难以计算的，可以按照侵权人的违法所得给予赔偿。赔偿数额还应当包括权利人为制止侵权行为所支付的合理开支**。权利人的实际损失或者侵权人的违法所得**不能确定的，由人民法院根据侵权行为的情节，判决给予五十万元以下的赔偿**。有下列侵权行为的，应当根据情况，承担停止侵害、消除影响、公开赔礼道款、赔偿损失等民事责任：
​    （1）未经软件著作权人许可发表或者登记其软件的。
​    （2）将他人软件当作自己的软件发表或者登记的。
​    （3）未经合作者许可，将与他人合作开发的软件当作自己单独完成的作品发表或者登记的

​	（4）在他人软件上署名或者涂改他人软件上的署名的
​    （5）未经软件著作权人许可，修改、翻译其软件的
​    （6）其他侵犯软件著作权的行为。

#### 行政责任

​    《中华人民共和国计算机软件保护条例》第二十四条规定了相应的行政责任，即对侵犯软件著作权行为，**著作权行政管理部门应当责令停止违法行为，没收非法所得，没收、销毁侵权复制品，并可处以每件一百元或者货值金额二至五倍的罚款**。有下列侵权行为的，应当根据情况，承担停止侵害、消除影响、公开赔礼道、赔偿损失等行政责任：
​     （1）复制或者部分复制著作权人软件的。
​     （2）向公众发行、出租、通过信息网络传播著作权人的软件的
​    （3）故意避开或者破坏著作权人为保护其软件而采取的技术措施的
​    （4）故意删除或者改变软件权利管理电子信息的
​     （5）许可他人行使或者转让著作权人的软件著作权的

#### 刑事责任

​    侵权行为触犯刑律的，侵权者应当承担刑事责任。《中华人民共和国刑法》第二百一十七条、二百一十八条和二百二十条规定，构成侵犯著作权罪、销售侵权复制品罪的，由司法机关追究刑事责任。

## 计算机软件的商业秘密权

### 商业秘密

  **1）商业秘密的定义**
    《中华人民共和国反不正当竞争法》中商业秘密**定义为“不为公众所知悉的、能为权利人带来经济利益、具有实用性并经权利人采取保密措施的技术信息和经营信息**”。**经营秘密和技术秘密是商业秘密的基本内容**。经营秘密，即**未公开的经营信息**，是指与生产经营销售活动有关的经营方法、管理方法、产销策略、货源情报、客户名单、标底和标书内容等专有知识。技术秘密，即**未公开的技术信息**，是指与产品生产和制造有关的技术快、生产方案、工艺流程、设计图纸、化学配方、技术情报等专有知识。

> **商业秘密权收法律保护的期限是不确定的，一旦被公众所知悉，既可以成为公众自由使用的知识**

​    **2）商业秘密的构成条件**
​    商业秘密的构成条件是：**商业秘密必须具有未公开性**，即不为公众所知悉；**商业秘密必须具有实用性**，即能为权利人带来经济效益：**商业秘密必须具有保密性**，即采取了保密措施。一项商业秘密**受到法律保护的依据，是必须具备上述构成商业秘密的三个条件，当缺少上述三个条件之一就会造成商业秘密丧失保护。**
​     3）商业秘密权
​    **商业秘密是一种无形的信息财产**。与有形财产相区别，商业秘密不占据空间，不易被权利人所控制，不发生有形损耗，其权利是一种无形财产权
​    4）计算机软件与商业秘密
​    《中华人民共和国反不正当竞争法》保护计算机软件，是以计算机软件中是否包含着“商业秘密”为必要条件的。而计算机软件是人类知识、智慧、经验和创造性劳动的成果，本身就具有商业秘密的特征，即包含着技术秘密和经营秘密。即使是软件尚未开发完成，在软件开发中所形成的知识内容也可构成商业秘密。

### 计算机软件商业秘密的侵权

​    **侵犯商业秘密是指行为人**（负有约定的保密义务的合同当事人；实施侵权行为的第三人侵犯本单位商业秘密的行为人）**未经权利人**（商业秘密的合法控制人）**的许可，以非法手段**（包括直接从权利人那里取商业秘密并加以公开或使用：通过第三人取权利人的商业秘密并加以公开或使用）**获取**计算机软件商业秘密**并加以公开或使用的行为**。根据《中华人民共和国反不正当竞争法》第十条的规定，侵犯计算机软件商业秘密的具体表现形式主要有：
​    （1）以盗罚、利诱、迫或其他**不正当手段获取**权利人的计算机软件商业秘密。盗窃商业秘密，包括单位内部人员盗、外部人员盗窃、内外勾结盗窃等手段；以利诱手段获取商业秘密，通常指行为人向掌握商业秘密的人员提供财物或其他优惠条件，诱使其向行为人提供商业秘密；以迫手段获取商业秘密，是指行为人采取威、强迫手段，使他人在受强制的情况下提供商业秘密：以其他不正当手段获取商业秘密。
​    （2）披露、使用或**允许他人使用以不正当手段获取的**计算机软件商业秘密。披露是指将权利人的商业秘密向第三人透露或向不特定的其他人公开，使其失去秘密价值：使用或允许他人使用是指非法使用他人商业秘密的具体情形。如果以非法手段获取商业秘密的行为人将该秘密再行披露或使用，即构成双重的侵权：若第三人从侵权人那里获悉了商业秘密而将秘密披露或使用，同样构成侵权
​    （3）**违反**约定或违反权利人有关**保守商业秘密的要求**，披露、使用或允许他人使用其所掌握的计算机软件商业秘密。合法掌握计算机软件商业秘密的人，可能是与权利人有合同关系的对方当事人，也可能是权利人的单位工作人员或其他知情人，他们违反合同约定或单位规定的保密义务，将其所掌握的商业秘密擅自公开，或自己使用，或许可他人使用，即构成侵犯商业秘密。
​    （4）**第三人在明知或应知前述违法行为的情况下**，仍然从侵权人那里获取、使用或披露他人的计算机软件商业秘密。这是一种间接的侵权行为

### 计算机软件商业秘密侵权的法律责任（略）

  根据《中华人民共和国反不正当竞争法》和《中华人民共和国刑法》的规定，计算机软件商业秘密的侵权者将承担行政责任、民事责任以及刑事责任

   （1）**侵权者的行政责任**。《中华人民共和国反不正当竞争法》第二十五条规定了相应的行政责任，即对侵犯商业秘密的行为，监督检查部门应当贵令停止违法行为，而后可以根据侵权的情节依法处以1万元以上20万元以下的罚款。
    （2）**侵权者的民事责任**。计算机软件商业秘密的侵权者的侵权行为对权利人的经营造成经济上的损失时，侵权者应当承担经济损害赔偿的民事责任。《中华人民共和国反不正当竞争法》第二十条规定了侵犯商业秘密的民事责任，即经营者违反该法规定，给被侵害的经营者造成损害的，应当承担损害赔偿责任。被侵害的经营者的合法权益受到损害的，可以向人民法院提起诉讼。
    （3）**侵权者的刑事责任**。侵权者以盗、利诱、协迫或其他不正当手段获取权利人的计算机软件商业秘密：披露、使用或允许他人使用以不正当手段获取的计算机软件商业秘密：违反约定或违反权利人有关保守商业秘密的要求，披露、使用或允许他人使用其所掌握的计算机软件商业秘密，其侵权行为对权利人造成重大损害的，侵权者应当承担刑事责任。《中华人民共和国刑法》第二百一十九条规定了侵犯商业秘密罪，即实施侵犯商业秘密行为，给商业秘密的权利人造成重大损失的，处3年以下有期徒刑或者拘役，并处或者单处罚金；造成特别严重后果的，处3年以上7年以下有期徒刑，并处罚金

## 专利权概述

### 专利权的保护对象与特征

​	**发明创造是产生专利权的基础**。发明创造是**指发明、实用新型和外观设计，是我国专利法主要保护的对象**。《中华人民共和国专利法实施细则》第二条第一款规定：“专利法所称的发明，是指对产品、方法或者其改进所提出的技术方案。”实用新型（也称小发明）则因国而异，《中华人民共和国专利法实施细则》第二条第二款规定：“实用新型是指对产品的形状、构造或者其组合所提出的新的技术方案。”外观设计是指对产品的形状、图案、色彩或者它们的结合所做出的富有美感的并适于工业应用的新设计。
专利的发明创造是无形的智力创造性成果，不像有形财产那样直观可见，必须经专利主管机关依照法定程序审查确定，在未经审批以前，任何一项发明创造都不得成为专利

**下列各项属于专利法不适用的对象，因此不授予专利权。**

1. **违反**国家法律、社会公德或者害公共利益的发明创造
2. 科学发现，即人们通过自己的智力劳动**对客观世界已经存在的但未揭示出来的规律性质和现象等的认识。**
3. **智力活动的规则和方法**，即人们进行推理、分析、判断、运算、处理、记忆等思维活动的规则和方法
4. 病的诊断和治疗方法，即以活的人或者动物为实施对象，并**以防病治病为目的，是医护人员的经验体现**，而且因被诊断和治疗的对象不同而有区别，不能在工业上应用，**不具有实用性**。
5. 动物和植物品种，但是**动物植物品种的生产方法，可以依照专利法规定授予专利权**
6. 用**原子核变换方法获得的物质**，即用核裂变或核聚变方法获得的单质或化合物

### 授予专利权的条件

​    授予**专利权的条件是指一项发明创造获得专利权应当具备的实质性条件**。一项发明或者实用新型获得专利权的实质**条件为新颗性、创造性和实用性。**

​    （1）**新颖性**。新颖性是指在**申请日以前没有同样的发明**或实用新型**在国内外出版物公开发表过、在国内公开使用过或以其他方式为公众所知**，也没有同样的发明或实用新型由他人向专利局提出过申请并且记载在申请日以后公布的专利申请文件中。在某些特殊情况下，尽管申请专利的发明或者实用新型在申请日或者优先权日前公开，但在一定的期限内提出专利申请的，仍然具有新颖性。我国专利法规定，**申请专利的发明创造在申请日以前6个月内，有下列情况之一的，不丧失新颗性**：

​    ①在中国政府主办或者承认的国际展览会上首次展出的

​    ②在规定的学术会议或者技术会议上首次发表的

​	③他人未经申请人同意而泄露其内容的

​    （2）**创造性**。创造性是指同申请日以前已有的技术相比，该发明有突出的实质性特点和显的进步，该实用新型**有实质性特点和进步**。例如，申请专利的发明解决了人们渴望解决但一直没有解决的技术难题申请专利的发明克服了技术偏见；申请专利的发明取得了意想不到的技术效果：申请专利的发明在商业上获得成功。一项发明专利是否具有创造性，前提是该项发明具备新颗性。

​    （3）**实用性。实用性是指该发明或者实用新型能够制造或者使用**，并且能够产生积极的效果，即不造成环境污染、能源或者资源的严重浪费，损害人体健康。如果申请专利的发明或者实用新型缺乏技术手段：申请专利的技术方案违背自然规律：**利用独一无二自然条件所完成的技术方案，则不具有实用性**

​	我国专利法规定，**外观设计获得专利权的实质条件为新颖性和美观性**。新颖性是指申请专利的外观设计与其申请日以前已经在国内外出版物上公开发表的外观设计不相同或者不相近似：与其申请日前已在国内公开使用过的外观设计不相同或者不相近似。美观性是指外观设计被使用在产品上时能使人产生一种美感，增加产品对消费者的吸引力

### 专利的申请

**1）专利申请权**
	公民、法人或者其他组织依据法律规定或者合同约定享有的就发明创造向专利局提出专利申请的权利（专利申请权）。**一项发明创造产生的专利申请权归谁所有**，主要有由法律直接规定的情况和依合同约定的情况。**专利申请权可以转让**，不论专利申请权在哪一个时间段转让，原专利申请人便因此失专利申请权，由受让人获得相应的专利申请权。**专利申请权可以被继承或赠与。专利申请人死亡后，其依法享有的专利申请权可以作为遗产，由其合法继承人继承**。
**2）专利申请人**
	专利申请人是指对某项发明创造依法律规定或者合同约定享有专利申请权的公民、法人或者其他组织。**专利申请人包括职务发明创造的单位；非职务发明创造的专利申请人为完成发明创造的发明人或者设计人；共同发明创造的专利申请人是共同发明人或者设计人，或者其所属单位： 委托发明创造的专利申请人为合同约定的人； 受让人**

**3）专利申请的原则（重点）**

​	专利申请日及其代理人在办理各种手续时都**应该采用书面形式**。一份专利申请文件只能就一项发明创造提出专利申请，即“**一份申请一份发明”原则**。**两个或两个以上的人分别就同样的发明创造申请专利的，专利授权给最先申请人；若同一时间申请的，则双方各自协商应给由谁来作为申请专利的人，若没有协商通过，则谁都不授予专利**

**4）专利申请文件**
      发明或者实用新型申请文件**包括请求书、说明书、说明书摘要和权利要求书。外观设计专利申请文件包括请求书、图片或照片。**
**5）专利申请日**
      专利申请日（**也称关键日**）是专利局或者专利局指定的**专利申请受理代办处收到完整专利申请文件的日期。如果申请文件是邮寄的，以寄出的邮日为申请日**。
**6）专利中请的审批**
      专利局收到发明专利申请后，**一个必要程序是初步审查**，经初步审查认为**符合本法要求的，自申请日起满18个月，即行公布（公布申请），专利局可根据申请人的请求，早日公布其申请。自申请日起三年内，专利局可以根据申请人随时提出的请求，对其申请进行实质审查。实质审查是专利局对申请专利的发明的新颖性、创造性和实用性等依法进行审查的法定程序**。我国专利法规定：“实用新型和外观设计专利申请经初步审查没有发现驳回理由的，专利局应当做出授予实用新型专利权或者外观设计专利权的决定，发给相应的专利证书，并予以登记和公布。”由此规定可知，**对实用新型和外观设计专利申请只进行初步审查，不进行实质审查**。
**7）申请权的丧失与恢复**
        专利法及其实施细则有许多条款规定，如果**申请人在法定期间或者专利局所指定的期限内未办理相应的手续或者没有提交有关文件，其申请就被视为撤回或者丧失提出某项请求的权利，或者导致有关权利终止后果**。因耽误期限而**丧失权利之后，可以在自障碍消除后2个月内，最迟自法定期限或者指定期限届满后2年内或者自收到专利局通知之日起2个月内，请求恢复其权利。**

### 专利权行使

​    **1）专利权的归属**
​    根据《中华人民共和国专利法》的规定，**执行本单位的任务或者主要是利用本单位的物质条件所完成的职务发明创造，申请专利的权利属于该单位**。申请被批准后，专利权归该单位持有（单位为专利权人）。执行本单位的任务所完成的职务发明创造是指：
​     **（1）在本职工作中做出的发明创造
​     （2）履行本单位交付的本职工作之外的任务所做出的发明创造
​    （3）工作变动（退职、退休或者调离）后短期内做出的，与其在原单位承担的本职工作或者原单位分配的任务有关的发明创造**
​    本单位的物质技术条件包括本单位的资金、设备、零部件、原材料或者不对外公开的技术资料等。
​    **非职务发明创造，申请专利的权利属于发明人或者设计人；在中国境内的外资企业和中外合资经营企业的工作人员完成的职务发明创造，申请专利的权利属于该企业**，申请被批准后，专利权归申请的企业或者个人所有：**两个以上单位协作**或者一个单位接受其他单位委托的研究、设计任务所完成的发明创造，**除另有协议的以外，申请专利的权利属于完成或者共同完成的单位**，申请被批准后，专利权归申请的单位所有或者持有。
​    **2）专利权人的权利**
​    **专利权是一种具有财产权属性的独占权以及由其衍生出来的相应处理权。专利权人的权利包括独占实施权、转让权、实施许可权、放弃权和标记权等。专利权人有缴纳专利年费（也称专利维持费）和实际实施已获专利的发明创造两项基本义务**
​    专利权人通过专利实施许可合同将其依法取得的对某项发明创造的实施权**转移**给非专利权人行使。任何单位或者个人实施他人专利的，除《中华人民共和国专利法》第十四条规定的以外，**都必须与专利权人订立书面实施许可合同，向专利权人支付专利使用费。被许可人无权允许合同规定以外的任何单位或者个人实施该专利。专利实施许可的种类包括独占许可、独家许可、普通许可和部分许可。**

### 专利权的限制

​    根据《中华人民共和国专利法》的规定，发明专利权的保护期限为自申请日起20年；使用新型专利和外观设计专利权的保护期限为子申请人起10年。发明创造专利的法律效力所及的范围如下：

1. 发明或者使用新型战略性的保护范围以及权力要求的内容为准，说明书及附图可以用于解释权力要求

2. 外观设计专利权的保护范围以表示在图片或者照片中的该外观设计专利产品为准。

   ​	**公告授予专利权后，任何单位或个人认为该专利权的授予不符合专利法规定条件的，可以向专利复查委员会提出宜告该专利权无效的请求。专利复审委员会对这种请求进行审查，做出宜告专利权无效或维持专利权的决定**。我国专利法规定，提出无效宜告请求的时间（启动无效宣告程序的时间）始于“自专利局公告授予专利权之日起”。
   ​     专利权**因某种法律事实**的发生而**导致其效力消灭的情形称为专利权终**止。导致专利权终止的法律事实如下：
   ​    **（1）保护期限届满
   ​    （2）在专利权保护期限届满前，专利权人以书面形式向专利局声明放弃专利权
   ​    （3）在专利权的保护期限内，专利权人没有按照法律的规定交年费。专利权终止日应为上年度期满日。**
   ​     专利权的限制是指专利法允许第三人在某些特殊情况下，可以不经专利权人许可而实施其专利，且其实施行为并不构成侵权的一种法律制度。专利权限制的种类包括强制许可、不视为侵犯专利权的行为和国家计划许可。

### 专利侵权行为

​    专利侵权行为是指在专利权的有效期限内，任何单位或者个人在未经专利权人许可，也没有其他法定事由的情况下，擅白以营利为日的实施专利的行为。专利侵权行为主要包括如下方面：
​    （1）为生产经营目的制造、使用、销售他人专利产品，或者使用他人专利方法以及使用销售依照该专利方法直接获得的产品
​    （2）为生产经营目的制造、销售他人外观设计专利产品
​    （3）进口**依照他人专利方法**直接获得的产品。
​    （4）**未经许可**，在其产品的包装上标明他人的专利标记和专利号。
​    （5）用非专利产品冒充专利产品的或者用非专利方法**冒充**专利方法等。
​    对未经专利权人许可，实施其专利的侵权行为，专利权人或者利害关系人可以请求专利管理机关处理。在专利侵权纠纷发生后，专利权人或者利害关系人既可以请求专利管理机关处理，又可以请求人民法院审理。**侵犯专利权的诉讼时效为2年**，自专利权人或者利害关系人知道或者应当知道侵权行为之日起计算。如果诉讼时效期限届满，专利权人或者利害关系人不能再请求人民法院保护，同时也不能再向专利管理机关请求保护

## 各知识产权保护期限

| 课题类型                     | 权力类型                                                     | 保护期限                                               |
| ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------ |
| 公民作品                     | 署名权、修改权、保护作品完整权                               | 没有限制                                               |
|                              | **发表权、使用权和获得报酬权**                               | 作者终生及其死亡后**50年**的12月31日                   |
| 单位作品                     | **发表权、使用权和获得报酬权**                               | **50年**，若未发表则不保护                             |
| 公民软件产品                 | **署名权、修改权**                                           | **没有限制**                                           |
|                              | **发表权**、复制权、发行权、出租权、信 息网络传播权、翻译权、**使用许可权**、获得报酬权、转让权 | 终生及其死亡后**50年**。合作开发则以最后死亡的作者为准 |
| 单位软件产品                 | **发表权**、复制权、发行权、出租权、信 息网络传播权、翻译权、**使用许可权**、获得报酬权、转让权 | **50年**                                               |
| **注册商标**                 |                                                              | 有效期**10年**，期满后**6月内可续住**                  |
| **发明专利权**               |                                                              | **20年**                                               |
| **实用新型和外观设计专利权** |                                                              | **10年**                                               |
| **商业秘密**                 |                                                              | **不确定，公开后公众可用**                             |

> **可以看出**
>
> 1. **发表和使用权都是50年**
> 2. **著名权和修改权没有限制**
> 3. **专利20年**
> 4. **实用和外观专利10年**
> 5. **商标10年**
> 6. **商业秘密不确定**

## 知识产权人的确定

<table border="1" cellspacing="0" style="width:600px;"><tbody><tr><td colspan="2" style="text-align:center;vertical-align:middle;width:109.5pt;"><strong>情况说明</strong></td><td style="border-color:#000000;text-align:center;vertical-align:middle;width:334.2pt;"><strong>判断说明</strong></td><td style="border-color:#000000;text-align:center;vertical-align:middle;width:266.65pt;"><strong>&nbsp; 归属</strong></td></tr><tr><td rowspan="3" style="text-align:center;vertical-align:middle;width:56.25pt;">作品</td><td rowspan="3" style="text-align:center;vertical-align:middle;width:53.25pt;">职务作品</td><td style="border-color:#000000;text-align:left;vertical-align:middle;width:334.2pt;">利用单位的物质技术条件进行创作,并除署名权外其他著作权归单位 由单位承担责任的</td><td style="border-color:#000000;text-align:left;vertical-align:middle;width:266.65pt;">除署名权外其他著作权归单位</td></tr><tr><td style="border-color:#000000;text-align:left;vertical-align:middle;width:334.2pt;">有合同约定,其著作权属于单位</td><td style="border-color:#000000;text-align:left;vertical-align:middle;width:266.65pt;">除署名权外其他著作权归单位</td></tr><tr><td style="border-color:#000000;text-align:left;vertical-align:middle;width:334.2pt;">其他</td><td style="text-align:left;vertical-align:middle;width:266.65pt;">作者拥有著作权,单位有权在业 务范围内优先使用</td></tr><tr><td rowspan="3" style="border-color:#000000;text-align:center;vertical-align:middle;width:56.25pt;">软件</td><td rowspan="3" style="border-color:#000000;text-align:center;vertical-align:middle;width:53.25pt;">职务作品</td><td style="border-color:#000000;text-align:left;vertical-align:middle;width:334.2pt;">属于本职工作中明确规定的开发目标</td><td style="border-color:#000000;text-align:left;vertical-align:middle;width:266.65pt;">单位享有著作权</td></tr><tr><td style="border-color:#000000;text-align:left;vertical-align:middle;width:334.2pt;">属于从事本职工作话动的结果</td><td style="border-color:#000000;text-align:left;vertical-align:middle;width:266.65pt;">单位享有著作权</td></tr><tr><td style="border-color:#000000;text-align:left;vertical-align:middle;width:334.2pt;">使用了单位资金、专用设备、未公开的 信息等物质、技术条件,并由单位或组 织承担责任的软件</td><td style="border-color:#000000;text-align:left;vertical-align:middle;width:266.65pt;">单位享有著作权</td></tr><tr><td rowspan="4" style="border-color:#000000;text-align:center;vertical-align:middle;width:56.25pt;">作品软件</td><td rowspan="2" style="text-align:center;vertical-align:middle;width:53.25pt;">委托创作</td><td style="border-color:#000000;text-align:left;vertical-align:middle;width:334.2pt;">有合同约定,著作权归委托方</td><td style="border-color:#000000;text-align:left;vertical-align:middle;width:266.65pt;">委托方</td></tr><tr><td style="border-color:#000000;text-align:left;vertical-align:middle;width:334.2pt;">合同中未约定著作权归属</td><td style="border-color:#000000;text-align:left;vertical-align:middle;width:266.65pt;">创作方</td></tr><tr><td rowspan="2" style="text-align:center;vertical-align:middle;width:53.25pt;">合作开发</td><td style="border-color:#000000;text-align:left;vertical-align:middle;width:334.2pt;">只进行组织、提供咨询意见、物质条件或者进行其他辅助工作</td><td style="border-color:#000000;text-align:left;vertical-align:middle;width:266.65pt;">不享有著作权</td></tr><tr><td style="border-color:#000000;text-align:left;vertical-align:middle;width:334.2pt;">共同创作的</td><td style="border-color:#000000;text-align:left;vertical-align:middle;width:266.65pt;">共同享有,技入头比例。 成果可分割的,可分开申请。</td></tr><tr><td colspan="2" style="text-align:center;vertical-align:middle;width:109.5pt;">商标</td><td colspan="2" style="text-align:center;vertical-align:middle;">谁先申请谁拥有(除知名商标的非法抢注) 同时申请,则根据谁先使用(需提供证据)</td></tr><tr><td colspan="2" style="text-align:center;vertical-align:middle;width:109.5pt;">专利</td><td colspan="2" style="text-align:center;vertical-align:middle;">无法提供证据,协商归属,无效时使用抽签(但不可不确定) 谁先申请谁拥有, 同时申请则协商归属,但不能够同时驳回双方的专利申请</td></tr></tbody></table>

> 可以看出，对于**职务作品**而言，**署名权属于个人**外其余都是公司
